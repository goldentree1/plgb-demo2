var $=Object.defineProperty;var W=(c,e,s)=>e in c?$(c,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):c[e]=s;var S=(c,e,s)=>W(c,typeof e!="symbol"?e+"":e,s);import{L as G}from"./browser-DdKr-yeI.js";import{A as Q}from"./AbortablePromiseCache-Bzbqdtb1.js";import{Q as j}from"./index-C2MZngrH.js";import{i as v}from"./inflate-BR9lAfBt.js";import{R as Z}from"./remoteFile-B4_2tkev.js";import{O as q}from"./Observable-m8LxMG-T.js";import{a2 as J,a3 as K}from"./index-DUxFddIG.js";const H=BigInt(32);function X(c,e,s){const i=+!!s,n=+!s;return BigInt(c.getInt32(e,s)*n+c.getInt32(e+4,s)*i)<<H|BigInt(c.getUint32(e,s)*i+c.getUint32(e+4,s)*n)}function Y(c,e,s){const i=c.getUint32(e,s),n=c.getUint32(e+4,s),r=+!!s,t=+!s;return BigInt(i*t+n*r)<<H|BigInt(i*r+n*t)}"getBigInt64"in DataView||(DataView.prototype.getBigInt64=function(c,e){return X(this,c,e)});"getBigUint64"in DataView||(DataView.prototype.getBigUint64=function(c,e){return Y(this,c,e)});class V{constructor(e){S(this,"ranges");this.ranges=e}get min(){return this.ranges[0].min}get max(){return this.ranges.at(-1).max}contains(e){for(const s of this.ranges)if(s.min<=e&&s.max>=e)return!0;return!1}isContiguous(){return this.ranges.length>1}getRanges(){return this.ranges.map(e=>new V([{min:e.min,max:e.max}]))}toString(){return this.ranges.map(e=>`[${e.min}-${e.max}]`).join(",")}union(e){const s=[...this.getRanges(),...e.getRanges()].sort((r,t)=>r.min<t.min?-1:r.min>t.min?1:r.max<t.max?-1:t.max>r.max?1:0),i=[];let n=s[0];for(const r of s)r.min>n.max+1?(i.push(n),n=r):r.max>n.max&&(n=new V([{min:n.min,max:r.max}]));return i.push(n),i.length===1?i[0]:new V(i)}}function tt(c){return v(c.subarray(2),void 0)}class et extends Error{constructor(s){super(s);S(this,"code");this.code="ERR_ABORTED"}}function nt(c){c.sort((n,r)=>n.offset-r.offset);const e=[];let s,i;for(const n of c)s&&i&&n.offset-i<=2e3?(s.length=s.length+n.length-i+n.offset,s.blocks.push(n)):e.push(s={blocks:[n],length:n.length,offset:n.offset}),i=s.offset+s.length;return e}function M(c){if(c&&c.aborted)if(typeof DOMException>"u"){const e=new et("aborted");throw e.code="ERR_ABORTED",e}else throw new DOMException("aborted","AbortError")}const _=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function E(c,e,s,i){return c<i&&e>=s}class rt{constructor(e,s,i,n,r){S(this,"bbi");S(this,"refsByName");S(this,"cirTreeOffset");S(this,"isCompressed");S(this,"blockType");S(this,"cirTreePromise");S(this,"featureCache",new Q({cache:new j({maxSize:1e3}),fill:async({length:e,offset:s},i)=>this.bbi.read(e,s,{signal:i})}));if(this.bbi=e,this.refsByName=s,this.cirTreeOffset=i,this.isCompressed=n,this.blockType=r,!(i>=0))throw new Error("invalid cirTreeOffset!")}async readWigData(e,s,i,n,r){try{const t=this.refsByName[e];t===void 0&&n.complete();const f={chrId:t,start:s,end:i};this.cirTreePromise||(this.cirTreePromise=this.bbi.read(48,this.cirTreeOffset,r));const m=await this.cirTreePromise,x=new DataView(m.buffer).getUint32(4,!0);let U=[],w=0;const u=(B,y,p)=>{try{const l=B.subarray(y),d=new DataView(l.buffer,l.byteOffset,l.length);let o=0;const k=d.getUint8(o);o+=2;const F=d.getUint16(o,!0);if(o+=2,k===1){const N=[];for(let I=0;I<F;I++){const T=d.getUint32(o,!0);o+=4;const C=d.getUint32(o,!0);o+=4;const R=d.getUint32(o,!0);o+=4;const P=d.getUint32(o,!0);o+=4;const z=Number(d.getBigUint64(o,!0));o+=8;const A=Number(d.getBigUint64(o,!0));o+=8,N.push({startChrom:T,startBase:C,endBase:P,endChrom:R,blockOffset:z,blockSize:A,offset:o})}U=U.concat(N.filter(I=>h(I)).map(I=>({offset:I.blockOffset,length:I.blockSize})))}else if(k===0){const N=[];for(let T=0;T<F;T++){const C=d.getUint32(o,!0);o+=4;const R=d.getUint32(o,!0);o+=4;const P=d.getUint32(o,!0);o+=4;const z=d.getUint32(o,!0);o+=4;const A=Number(d.getBigUint64(o,!0));o+=8,N.push({startChrom:C,startBase:R,endChrom:P,endBase:z,blockOffset:A,offset:o})}const I=N.filter(T=>h(T)).map(T=>T.blockOffset);I.length>0&&O(I,p+1)}}catch(b){n.error(b)}},h=B=>{const{startChrom:y,startBase:p,endChrom:b,endBase:l}=B;return(y<t||y===t&&p<=i)&&(b>t||b===t&&l>=s)},a=async(B,y,p)=>{try{const b=y.max-y.min,l=y.min,d=await this.featureCache.get(`${b}_${l}`,{length:b,offset:l},r==null?void 0:r.signal);for(const o of B)y.contains(o)&&(u(d,o-l,p),w-=1,w===0&&this.readFeatures(n,U,{...r,request:f}).catch(k=>{n.error(k)}))}catch(b){n.error(b)}},O=(B,y)=>{try{w+=B.length;const p=4+x*32;let b=new V([{min:B[0],max:B[0]+p}]);for(let l=1;l<B.length;l+=1){const d=new V([{min:B[l],max:B[l]+p}]);b=b.union(d)}b.getRanges().map(l=>a(B,l,y))}catch(p){n.error(p)}};O([this.cirTreeOffset+48],1);return}catch(t){n.error(t)}}parseSummaryBlock(e,s,i){const n=[];let r=s;const t=new DataView(e.buffer,e.byteOffset,e.length);for(;r<e.byteLength;){const f=t.getUint32(r,!0);r+=4;const m=t.getUint32(r,!0);r+=4;const g=t.getUint32(r,!0);r+=4;const x=t.getUint32(r,!0);r+=4;const U=t.getFloat32(r,!0);r+=4;const w=t.getFloat32(r,!0);r+=4;const u=t.getFloat32(r,!0);r+=4,r+=4,(!i||f===i.chrId&&E(m,g,i.start,i.end))&&n.push({start:m,end:g,maxScore:w,minScore:U,summary:!0,score:u/(x||1)})}return n}parseBigBedBlock(e,s,i,n){const r=[];let t=s;const f=e,m=new DataView(f.buffer,f.byteOffset,f.length);for(;t<e.byteLength;){const g=t,x=m.getUint32(t,!0);t+=4;const U=m.getInt32(t,!0);t+=4;const w=m.getInt32(t,!0);t+=4;let u=t;for(;u<e.length&&e[u]!==0;u++);const h=e.subarray(t,u),a=(_==null?void 0:_.decode(h))??h.toString();t=u+1,r.push({chromId:x,start:U,end:w,rest:a,uniqueId:`bb-${i+g}`})}return n?r.filter(g=>E(g.start,g.end,n.start,n.end)):r}parseBigWigBlock(e,s,i){const n=e.subarray(s),r=new DataView(n.buffer,n.byteOffset,n.length);let t=0;t+=4;const f=r.getInt32(t,!0);t+=8;const m=r.getUint32(t,!0);t+=4;const g=r.getUint32(t,!0);t+=4;const x=r.getUint8(t);t+=2;const U=r.getUint16(t,!0);t+=2;const w=new Array(U);switch(x){case 1:{for(let u=0;u<U;u++){const h=r.getInt32(t,!0);t+=4;const a=r.getInt32(t,!0);t+=4;const O=r.getFloat32(t,!0);t+=4,w[u]={start:h,end:a,score:O}}break}case 2:{for(let u=0;u<U;u++){const h=r.getInt32(t,!0);t+=4;const a=r.getFloat32(t,!0);t+=4,w[u]={score:a,start:h,end:h+g}}break}case 3:{for(let u=0;u<U;u++){const h=r.getFloat32(t,!0);t+=4;const a=f+u*m;w[u]={score:h,start:a,end:a+g}}break}}return i?w.filter(u=>E(u.start,u.end,i.start,i.end)):w}async readFeatures(e,s,i={}){try{const{blockType:n,isCompressed:r}=this,{signal:t,request:f}=i,m=nt(s);M(t),await Promise.all(m.map(async g=>{M(t);const{length:x,offset:U}=g,w=await this.featureCache.get(`${x}_${U}`,g,t);for(const u of g.blocks){M(t);let h=w.subarray(u.offset-g.offset);switch(r&&(h=tt(h)),M(t),n){case"summary":{e.next(this.parseSummaryBlock(h,0,f));break}case"bigwig":{e.next(this.parseBigWigBlock(h,0,f));break}case"bigbed":{e.next(this.parseBigBedBlock(h,0,u.offset*256,f));break}default:console.warn(`Don't know what to do with ${n}`)}}})),e.complete()}catch(n){e.error(n)}}}const st=-2003829722,L=-2021002517;function D(c){return new DataView(c.buffer,c.byteOffset,c.length)}class mt{constructor(e){S(this,"bbi");S(this,"headerP");S(this,"renameRefSeqs");const{filehandle:s,renameRefSeqs:i=t=>t,path:n,url:r}=e;if(this.renameRefSeqs=i,s)this.bbi=s;else if(r)this.bbi=new Z(r);else if(n)this.bbi=new G(n);else throw new Error("no file given")}getHeader(e){return this.headerP||(this.headerP=this._getHeader(e).catch(s=>{throw this.headerP=void 0,s})),this.headerP}async _getHeader(e){const s=await this._getMainHeader(e),i=await this._readChromTree(s,e);return{...s,...i}}async _getMainHeader(e,s=2e3){const i=await this.bbi.read(s,0,e),n=D(i),r=n.getInt32(0,!0);if(r!==st&&r!==L)throw new Error("not a BigWig/BigBed file");let t=0;const f=n.getInt32(t,!0);t+=4;const m=n.getUint16(t,!0);t+=2;const g=n.getUint16(t,!0);t+=2;const x=Number(n.getBigUint64(t,!0));t+=8;const U=Number(n.getBigUint64(t,!0));t+=8;const w=Number(n.getBigUint64(t,!0));t+=8;const u=n.getUint16(t,!0);t+=2;const h=n.getUint16(t,!0);t+=2;const a=Number(n.getBigUint64(t,!0));t+=8;const O=Number(n.getBigUint64(t,!0));t+=8;const B=n.getUint32(t,!0);t+=4;const y=Number(n.getBigUint64(t,!0));t+=8;const p=[];for(let o=0;o<g;o++){const k=n.getUint32(t,!0);t+=4;const F=n.getUint32(t,!0);t+=4;const N=Number(n.getBigUint64(t,!0));t+=8;const I=Number(n.getBigUint64(t,!0));t+=8,p.push({reductionLevel:k,reserved:F,dataOffset:N,indexOffset:I})}const b=f===L?"bigbed":"bigwig";if(a>s||O>s-40)return this._getMainHeader(e,s*2);let l;if(O){const o=i.subarray(O);let k=0;const F=D(o),N=Number(F.getBigUint64(k,!0));k+=8;const I=F.getFloat64(k,!0);k+=8;const T=F.getFloat64(k,!0);k+=8;const C=F.getFloat64(k,!0);k+=8;const R=F.getFloat64(k,!0);k+=8,l={scoreMin:I,scoreMax:T,scoreSum:C,scoreSumSquares:R,basesCovered:N}}else throw new Error("no stats");const d=new TextDecoder("utf8");return{zoomLevels:p,magic:f,extHeaderOffset:y,numZoomLevels:g,fieldCount:u,totalSummary:l,definedFieldCount:h,uncompressBufSize:B,asOffset:a,chromTreeOffset:x,totalSummaryOffset:O,unzoomedDataOffset:U,unzoomedIndexOffset:w,fileType:b,version:m,autoSql:a?d.decode(i.subarray(a,i.indexOf(0,a))):""}}async _readChromTree(e,s){const i=[],n={},r=e.chromTreeOffset,t=D(await this.bbi.read(32,r,s));let f=0;f+=4,f+=4;const m=t.getUint32(f,!0);f+=4;const g=t.getUint32(f,!0);f+=4,f+=8;const x=new TextDecoder("utf8"),U=async w=>{const u=await this.bbi.read(4,w),h=D(u);let a=0;const O=h.getUint8(a);a+=1,a+=1;const B=h.getUint16(a,!0);if(a+=2,O){const y=await this.bbi.read(B*(m+g),w+a),p=D(y);a=0;for(let b=0;b<B;b++){const l=x.decode(y.subarray(a,a+m)).replaceAll("\0","");a+=m;const d=p.getUint32(a,!0);a+=4;const o=p.getUint32(a,!0);a+=4,n[this.renameRefSeqs(l)]=d,i[d]={name:l,id:d,length:o}}}else{const y=[],p=D(await this.bbi.read(B*(m+8),w+a));a=0;for(let b=0;b<B;b++){a+=m;const l=Number(p.getBigUint64(a,!0));a+=8,y.push(U(l))}await Promise.all(y)}};return await U(r+32),{refsByName:n,refsByNumber:i}}async getUnzoomedView(e){const{unzoomedIndexOffset:s,refsByName:i,uncompressBufSize:n,fileType:r}=await this.getHeader(e);return new rt(this.bbi,i,s,n>0,r)}async getFeatureStream(e,s,i,n){await this.getHeader(n);const r=this.renameRefSeqs(e);let t;const{basesPerSpan:f,scale:m}=n||{};return f?t=await this.getView(1/f,n):m?t=await this.getView(m,n):t=await this.getView(1,n),new q(g=>{t.readWigData(r,s,i,g,n).catch(x=>{g.error(x)})})}async getFeatures(e,s,i,n){const r=await this.getFeatureStream(e,s,i,n);return(await J(r.pipe(K()))).flat()}}export{mt as B,rt as a};
//# sourceMappingURL=bbi-B3vGekDV.js.map
