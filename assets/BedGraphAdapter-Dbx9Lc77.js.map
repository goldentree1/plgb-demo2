{"version":3,"file":"BedGraphAdapter-Dbx9Lc77.js","sources":["../../node_modules/@jbrowse/plugin-bed/esm/BedGraphAdapter/BedGraphAdapter.js"],"sourcesContent":["import { IntervalTree } from '@flatten-js/interval-tree';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { SimpleFeature, fetchAndMaybeUnzip } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { parseLineByLine } from '@jbrowse/core/util/parseLineByLine';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nexport default class BedGraphAdapter extends BaseFeatureDataAdapter {\n    constructor() {\n        super(...arguments);\n        this.intervalTrees = {};\n    }\n    async getNames() {\n        const { header, columnNames } = await this.loadData();\n        if (columnNames.length) {\n            return columnNames;\n        }\n        const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f);\n        const defline = defs.at(-1);\n        return (defline === null || defline === void 0 ? void 0 : defline.includes('\\t'))\n            ? defline\n                .slice(1)\n                .split('\\t')\n                .map(field => field.trim())\n            : undefined;\n    }\n    async loadFeatureIntervalTreeHelper(refName) {\n        var _a;\n        const { features } = await this.loadData();\n        const lines = features[refName];\n        if (!lines) {\n            return undefined;\n        }\n        const names = ((_a = (await this.getNames())) === null || _a === void 0 ? void 0 : _a.slice(3)) || [];\n        const intervalTree = new IntervalTree();\n        for (let i = 0, l = lines.length; i < l; i++) {\n            const line = lines[i];\n            const [refName, s, e, ...rest] = line.split('\\t');\n            for (let j = 0, l2 = rest.length; j < l2; j++) {\n                const uniqueId = `${this.id}-${refName}-${i}-${j}`;\n                const start = +s;\n                const end = +e;\n                const score = +rest[j];\n                const source = names[j] || `col${j}`;\n                if (score) {\n                    intervalTree.insert([start, end], new SimpleFeature({\n                        id: uniqueId,\n                        data: {\n                            refName,\n                            start,\n                            end,\n                            score,\n                            source,\n                        },\n                    }));\n                }\n            }\n        }\n        return intervalTree;\n    }\n    async getRefNames(opts = {}) {\n        const { features } = await this.loadData(opts);\n        return Object.keys(features);\n    }\n    async loadDataP(opts = {}) {\n        const pm = this.pluginManager;\n        const bedLoc = this.getConf('bedGraphLocation');\n        const buffer = await fetchAndMaybeUnzip(openLocation(bedLoc, pm), opts);\n        const features = {};\n        const headerLines = [];\n        parseLineByLine(buffer, line => {\n            if (line.startsWith('#')) {\n                headerLines.push(line);\n            }\n            else {\n                const tab = line.indexOf('\\t');\n                const refName = line.slice(0, tab);\n                if (!features[refName]) {\n                    features[refName] = [];\n                }\n                features[refName].push(line);\n            }\n            return true;\n        }, opts.statusCallback);\n        const columnNames = this.getConf('columnNames');\n        return {\n            header: headerLines.join('\\n'),\n            features,\n            columnNames,\n        };\n    }\n    async loadFeatureIntervalTree(refName) {\n        if (!this.intervalTrees[refName]) {\n            this.intervalTrees[refName] = this.loadFeatureIntervalTreeHelper(refName).catch((e) => {\n                this.intervalTrees[refName] = undefined;\n                throw e;\n            });\n        }\n        return this.intervalTrees[refName];\n    }\n    async loadData(opts = {}) {\n        if (!this.bedFeatures) {\n            this.bedFeatures = this.loadDataP(opts).catch((e) => {\n                this.bedFeatures = undefined;\n                throw e;\n            });\n        }\n        return this.bedFeatures;\n    }\n    getFeatures(query, _opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { start, end, refName } = query;\n            const intervalTree = await this.loadFeatureIntervalTree(refName);\n            for (const feature of (intervalTree === null || intervalTree === void 0 ? void 0 : intervalTree.search([start, end])) || []) {\n                observer.next(feature);\n            }\n            observer.complete();\n        });\n    }\n}\n"],"names":["BedGraphAdapter","BaseFeatureDataAdapter","header","columnNames","defline","f","field","refName","_a","features","lines","names","intervalTree","IntervalTree","i","l","line","s","e","rest","j","l2","uniqueId","start","end","score","source","SimpleFeature","opts","pm","bedLoc","buffer","fetchAndMaybeUnzip","openLocation","headerLines","parseLineByLine","tab","query","_opts","ObservableCreate","observer","feature"],"mappings":"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","x_google_ignoreList":[0]}