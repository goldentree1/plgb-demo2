import{B as F}from"./index-D8SKdkWL.js";import{r as O}from"./rxjs-CJV8ZOVO.js";import{S as M}from"./simpleFeature-BDpsMtgI.js";import{bu as j,u as C,R,bU as T,a2 as $,a3 as P}from"./index-DUxFddIG.js";import{g as I,a as N}from"./getMaximumModificationAtEachPosition-maSfsFLt.js";function G({feature:s,bins:t,region:e}){const o=s.get("start"),d=s.get("end"),n=s.get("strand"),p=e.end-e.start;for(let r=o;r<d+1;r++){const c=r-e.start;c>=0&&c<p&&(t[c]===void 0&&(t[c]={depth:0,readsCounted:0,ref:{probabilities:[],entryDepth:0,"-1":0,0:0,1:0},snps:{},mods:{},nonmods:{},delskips:{},noncov:{}}),r!==d&&(t[c].depth++,t[c].readsCounted++,t[c].ref.entryDepth++,t[c].ref[n]++))}}function L(s){return E(s.type)?1:s.length}function E(s){return s==="softclip"||s==="hardclip"||s==="insertion"}function k(s,t,e,o){let d=s[e][o];d===void 0&&(d=s[e][o]={entryDepth:0,probabilities:[],"-1":0,0:0,1:0}),d.entryDepth++,d[t]++}function A(s,t,e,o,d){let n=s[e][o];n===void 0&&(n=s[e][o]={entryDepth:0,probabilities:[],"-1":0,0:0,1:0}),n.entryDepth++,n.probabilities.push(d),n[t]++}function B({feature:s,region:t,bins:e,skipmap:o}){var d;const n=s.get("start"),p=s.get("strand"),r=(d=s.get("mismatches"))!==null&&d!==void 0?d:[];for(const c of r){const l=n+c.start,i=L(c),w=l+i;for(let a=l;a<l+i;a++){const u=a-t.start;if(u>=0&&u<e.length){const f=e[u],{base:h,altbase:m,type:S}=c,D=E(S);S==="deletion"||S==="skip"?(k(f,p,"delskips",S),f.depth--):D?k(f,p,"noncov",S):(k(f,p,"snps",h),f.ref.entryDepth--,f.ref[p]--,f.refbase=m)}}if(c.type==="skip"){const a=s.get("tags"),u=(a==null?void 0:a.XS)||(a==null?void 0:a.TS),f=a==null?void 0:a.ts,h=u==="+"?1:u==="-"?-1:(f==="+"?1:u==="-"?-1:0)*p,m=`${l}_${w}_${h}`;o[m]===void 0&&(o[m]={feature:s,start:l,end:w,strand:p,effectiveStrand:h,score:0}),o[m].score++}}}function U({feature:s,colorBy:t,region:e,bins:o,regionSequence:d}){var n,p,r,c,l;const i=s.get("start"),w=s.get("strand"),a=s.get("end"),u=(n=t==null?void 0:t.modifications)===null||n===void 0?void 0:n.twoColor,f=(p=t==null?void 0:t.modifications)===null||p===void 0?void 0:p.isolatedModification,h=s.get("seq"),S=((c=(r=t==null?void 0:t.modifications)===null||r===void 0?void 0:r.threshold)!==null&&c!==void 0?c:10)/100;if(!h)return;const D=j(s.get("CIGAR"));(l=I(s,D))===null||l===void 0||l.forEach(({allProbs:b,prob:g,type:q},x)=>{if(f&&q!==f||g<S)return;const v=x+i-e.start;if(v>=0&&v<o.length&&x+i<a){o[v]===void 0&&(o[v]={depth:0,readsCounted:0,snps:{},ref:{probabilities:[],entryDepth:0,"-1":0,0:0,1:0},mods:{},nonmods:{},delskips:{},noncov:{}});const _=o[v];_.refbase=d[v];const y=1-C.sum(b);u&&y>C.max(b)?A(_,w,"nonmods",`nonmod_${q}`,y):A(_,w,"mods",`mod_${q}`,g)}})}function V({feature:s,region:t,bins:e,regionSequence:o}){var d;const n=s.get("start"),p=s.get("end"),r=s.get("strand"),c=s.get("seq"),l=(d=s.get("mismatches"))!==null&&d!==void 0?d:[],i=o.toLowerCase();if(c){const w=j(s.get("CIGAR")),{methBins:a,methProbs:u}=N(s,w),f=l.filter(h=>h.type==="deletion");for(let h=0;h<p-n;h++){const m=h+n,S=i[m-t.start+1],D=i[m-t.start+2];if(S==="c"&&D==="g"){const b=e[m-t.start],g=e[m-t.start+1],q=a[h],x=a[h+1],v=u[h],_=u[h+1];q&&(v===void 0||v>.5)||x&&(_===void 0||_>.5)?(b&&(A(b,r,"mods","cpg_meth",v||0),b.ref.entryDepth--,b.ref[r]--),g&&(A(g,r,"mods","cpg_meth",_||0),g.ref.entryDepth--,g.ref[r]--)):(b&&(f.some(y=>C.doesIntersect2(m,m+1,y.start+n,y.start+n+y.length))||(A(b,r,"nonmods","cpg_unmeth",1-(v||0)),b.ref.entryDepth--,b.ref[r]--)),g&&(f.some(y=>C.doesIntersect2(m+1,m+2,y.start+n,y.start+n+y.length))||(A(g,r,"nonmods","cpg_unmeth",1-(_||0)),g.ref.entryDepth--,g.ref[r]--)))}}}}async function W({fetchSequence:s,features:t,region:e,opts:o}){const{stopToken:d,colorBy:n}=o,p={},r=[],c=Math.max(0,e.start-1),l=e.start-c;let i,w=performance.now();for(const a of t)performance.now()-w>400&&(R.checkStopToken(d),w=performance.now()),G({feature:a,bins:r,region:e}),(n==null?void 0:n.type)==="modifications"?(i??(i=await s({...e,start:c,end:e.end+1})||""),U({feature:a,colorBy:n,bins:r,region:e,regionSequence:i.slice(l)})):(n==null?void 0:n.type)==="methylation"&&(i??(i=await s({...e,start:c,end:e.end+1})||""),V({feature:a,bins:r,region:e,regionSequence:i})),B({feature:a,skipmap:p,bins:r,region:e});for(const a of r)a&&(a.mods=Object.fromEntries(Object.entries(a.mods).map(([u,f])=>[u,{...f,avgProbability:f.probabilities.length?C.sum(f.probabilities)/f.probabilities.length:void 0}])),a.nonmods=Object.fromEntries(Object.entries(a.nonmods).map(([u,f])=>[u,{...f,avgProbability:f.probabilities.length?C.sum(f.probabilities)/f.probabilities.length:void 0}])));return{bins:r,skipmap:p}}class Q extends F.BaseFeatureDataAdapter{async configure(){var t,e;const o=this.getConf("subadapter"),d=o.sequenceAdapter,n=await((t=this.getSubAdapter)===null||t===void 0?void 0:t.call(this,o)),p=d?await((e=this.getSubAdapter)===null||e===void 0?void 0:e.call(this,d)):void 0;if(!n)throw new Error("Failed to get subadapter");return{subadapter:n.dataAdapter,sequenceAdapter:p==null?void 0:p.dataAdapter}}async fetchSequence(t){const{sequenceAdapter:e}=await this.configure();if(e)return T(t,e)}getFeatures(t,e={}){return O.ObservableCreate(async o=>{const{subadapter:d}=await this.configure(),n=await $(d.getFeatures(t,e).pipe(P())),{bins:p,skipmap:r}=await W({features:n,region:t,opts:e,fetchSequence:l=>this.fetchSequence(l)});let c=0;for(const l of p){if(l){const i=t.start+c;o.next(new M({id:`${this.id}-${i}`,data:{score:l.depth,snpinfo:l,start:i,end:i+1,refName:t.refName}}))}c++}for(const[l,i]of Object.entries(r))o.next(new M({id:l,data:{type:"skip",start:i.start,end:i.end,strand:i.strand,score:i.score,effectiveStrand:i.effectiveStrand}}));o.complete()},e.stopToken)}async getMultiRegionFeatureDensityStats(t,e){const{subadapter:o}=await this.configure();return o.getMultiRegionFeatureDensityStats(t,e)}async getRefNames(t={}){const{subadapter:e}=await this.configure();return e.getRefNames(t)}}export{Q as default};
//# sourceMappingURL=SNPCoverageAdapter-DFyZUK5z.js.map
