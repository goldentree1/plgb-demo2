var y=Object.defineProperty;var I=(o,e,t)=>e in o?y(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t;var f=(o,e,t)=>I(o,typeof e!="symbol"?e+"":e,t);import{I as L,Z as b}from"./inflate-BR9lAfBt.js";import{L as p}from"./browser-DdKr-yeI.js";import{I as k,a as B}from"./IndexedFastaAdapter-Csi0Fml0.js";import{a4 as u}from"./index-DUxFddIG.js";import"./AbortablePromiseCache-Bzbqdtb1.js";import"./index-D8SKdkWL.js";import"./QuickLRU-D2viNZlG.js";import"./rxjs-CJV8ZOVO.js";const m=65536,z=m*m;function g(o,e=0){const t=o[e]|o[e+1]<<8|o[e+2]<<16|o[e+3]<<24;return((o[e+4]|o[e+5]<<8|o[e+6]<<16|o[e+7]<<24)>>>0)*z+(t>>>0)}const d=1;function w(o,e,t){const n=e[d],s=t?t[d]:1/0;return n<=o&&s>o?0:n<o?-1:1}class F{constructor({filehandle:e}){f(this,"filehandle");f(this,"index");this.filehandle=e}_getIndex(){return this.index||(this.index=this._readIndex().catch(e=>{throw this.index=void 0,e})),this.index}async _readIndex(){const e=await this.filehandle.read(8,0),t=g(e);if(!t)return[[0,0]];const n=new Array(t+1);n[0]=[0,0];const s=16*t;if(s>Number.MAX_SAFE_INTEGER)throw new TypeError("integer overflow");const r=await this.filehandle.read(s,8);for(let i=0;i<t;i+=1){const c=g(r,i*16),a=g(r,i*16+8);n[i+1]=[c,a]}return n}async getLastBlock(){return(await this._getIndex()).at(-1)}async getRelevantBlocksForRead(e,t){const n=t+e;if(e===0)return[];const s=await this._getIndex(),r=[];let i=0,c=s.length-1,a=Math.floor(s.length/2),l=w(t,s[a],s[a+1]);for(;l!==0;)l>0?c=a-1:l<0&&(i=a+1),a=Math.ceil((c-i)/2)+i,l=w(t,s[a],s[a+1]);r.push(s[a]);let h=a+1;for(;h<s.length&&(r.push(s[h]),!(s[h][d]>=n));h+=1);return r[r.length-1][d]<n&&r.push([]),r}}function P(o){let e=0;for(const t of o)e+=t.length;return e}function _(o,e){const t=new Uint8Array(e??P(o));let n=0;for(const s of o)t.set(s,n),n+=s.length;return t}async function A(o){try{let e,t=0,n;const s=[];let r=0;do{const i=o.subarray(t);if(n=new L(void 0),{strm:e}=n,n.push(i,b),n.err)throw new Error(n.msg);t+=e.next_in;const c=n.result;s.push(c),r+=c.length}while(e.avail_in);return _(s,r)}catch(e){throw/incorrect header check/.exec(`${e}`)?new Error("problem decompressing block: incorrect gzip header check"):e}}class x{constructor({filehandle:e,gziFilehandle:t}){f(this,"filehandle");f(this,"gzi");this.filehandle=e,this.gzi=new F({filehandle:t})}async _readAndUncompressBlock(e,t){let n=t;n||(n=(await this.filehandle.stat()).size);const s=n-e,r=await this.filehandle.read(s,e);return A(r)}async read(e,t){const n=await this.gzi.getRelevantBlocksForRead(e,t),s=[];for(let r=0;r<n.length-1;r+=1){const i=await this._readAndUncompressBlock(n[r][0],n[r+1][0]),[,c]=n[r],a=c>=t?0:t-c,l=Math.min(t+e,c+i.length)-c;a>=0&&a<i.length&&s.push(i.subarray(a,l))}return _(s)}}class E extends k{constructor({fasta:e,path:t,fai:n,faiPath:s,gzi:r,gziPath:i}){super({fasta:e,path:t,fai:n,faiPath:s}),e&&r?this.fasta=new x({filehandle:e,gziFilehandle:r}):t&&i&&(this.fasta=new x({filehandle:new p(t),gziFilehandle:new p(i)}))}}class W extends B{async setupPre(){const e=this.getConf("fastaLocation"),t=this.getConf("faiLocation"),n=this.getConf("gziLocation"),s={fasta:u.openLocation(e,this.pluginManager),fai:u.openLocation(t,this.pluginManager),gzi:u.openLocation(n,this.pluginManager)};return{fasta:new E(s)}}}export{W as default};
//# sourceMappingURL=BgzipFastaAdapter-Dd9tdMEJ.js.map
