import{I as g}from"./main-BANj1I0n.js";import{V as w,a as x}from"./index-Cbr4IzfO.js";import{B as M}from"./index-DYe7vadA.js";import{i as d,u as y}from"./rpcWorker-X0469dqW.js";import{r as F}from"./rxjs-DQbUCOsY.js";import{p as T}from"./parseLineByLine-B_OL93YM.js";function L(f,t=()=>{}){const s=[],e={};return T.parseLineByLine(f,a=>{if(a.startsWith("#"))s.push(a);else{const r=a.indexOf("	"),n=a.slice(0,r);e[n]||(e[n]=[]),e[n].push(a)}return!0},t),{header:s.join(`
`),featureMap:e}}class b extends M.BaseFeatureDataAdapter{constructor(){super(...arguments),this.calculatedIntervalTreeMap={}}async getHeader(){const{header:t}=await this.setup();return t}async getMetadata(){const{parser:t}=await this.setup();return t.getMetadata()}async setupP(t){const{statusCallback:s=()=>{}}=t||{},e=d.openLocation(this.getConf("vcfLocation"),this.pluginManager),a=await y.fetchAndMaybeUnzip(e,t),{header:r,featureMap:n}=L(a,s),i=new w({header:r}),c=Object.fromEntries(Object.entries(n).map(([o,p])=>[o,u=>{if(!this.calculatedIntervalTreeMap[o]){u==null||u("Parsing VCF data");let m=0;const h=new g;for(const v of p){const l=new x({variant:i.parseLine(v),parser:i,id:`${this.id}-${o}-${m++}`});h.insert([l.get("start"),l.get("end")],l)}this.calculatedIntervalTreeMap[o]=h}return this.calculatedIntervalTreeMap[o]}]));return{header:r,parser:i,intervalTreeMap:c}}async setup(){return this.vcfFeatures||(this.vcfFeatures=this.setupP().catch(t=>{throw this.vcfFeatures=void 0,t})),this.vcfFeatures}async getRefNames(t={}){const{intervalTreeMap:s}=await this.setup();return Object.keys(s)}getFeatures(t,s={}){return F.ObservableCreate(async e=>{var a;try{const{start:r,end:n,refName:i}=t,{intervalTreeMap:c}=await this.setup();for(const o of((a=c[i])===null||a===void 0?void 0:a.call(c,s.statusCallback).search([r,n]))||[])e.next(o);e.complete()}catch(r){e.error(r)}},s.stopToken)}async getSources(){const t=this.getConf("samplesTsvLocation");if(t.uri===""||t.uri==="/path/to/samples.tsv"){const{parser:s}=await this.setup();return s.samples.map(e=>({name:e}))}else{const e=(await d.openLocation(t).readFile("utf8")).split(/\n|\r\n|\r/),a=e[0].split("	"),{parser:r}=await this.setup(),n=new Set(r.samples);return e.slice(1).map(i=>{const c=i.split("	");return{name:c[0],...Object.fromEntries(c.slice(1).map((o,p)=>[a[p+1],o]))}}).filter(i=>n.has(i.name))}}}b.capabilities=["getFeatures","getRefNames"];export{b as default};
//# sourceMappingURL=VcfAdapter-4FYrI4qZ.js.map
