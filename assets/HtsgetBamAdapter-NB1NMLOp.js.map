{"version":3,"file":"HtsgetBamAdapter-NB1NMLOp.js","sources":["../node_modules/@gmod/bam/esm/htsget.js","../node_modules/@jbrowse/plugin-alignments/esm/HtsgetBamAdapter/HtsgetBamAdapter.js"],"sourcesContent":["import { unzip } from '@gmod/bgzf-filehandle';\nimport BamFile, { BAM_MAGIC } from \"./bamFile.js\";\nimport { parseHeaderText } from \"./sam.js\";\nimport { concatUint8Array } from \"./util.js\";\nasync function concat(arr, opts) {\n    const res = await Promise.all(arr.map(async (chunk) => {\n        const { url, headers } = chunk;\n        if (url.startsWith('data:')) {\n            // pass base64 data url to fetch to decode to buffer\n            // https://stackoverflow.com/a/54123275/2129219\n            const res = await fetch(url);\n            if (!res.ok) {\n                throw new Error('failed to decode base64');\n            }\n            const ret = await res.arrayBuffer();\n            return new Uint8Array(ret);\n        }\n        else {\n            // remove referer header, it is not even allowed to be specified\n            // @ts-expect-error\n            const { referer, ...rest } = headers;\n            const res = await fetch(url, {\n                ...opts,\n                headers: { ...opts?.headers, ...rest },\n            });\n            if (!res.ok) {\n                throw new Error(`HTTP ${res.status} fetching ${url}: ${await res.text()}`);\n            }\n            return new Uint8Array(await res.arrayBuffer());\n        }\n    }));\n    return concatUint8Array(await Promise.all(res.map(elt => unzip(elt))));\n}\nexport default class HtsgetFile extends BamFile {\n    constructor(args) {\n        super({ htsget: true });\n        this.baseUrl = args.baseUrl;\n        this.trackId = args.trackId;\n    }\n    async *streamRecordsForRange(chr, min, max, opts) {\n        const base = `${this.baseUrl}/${this.trackId}`;\n        const url = `${base}?referenceName=${chr}&start=${min}&end=${max}&format=BAM`;\n        const chrId = this.chrToIndex?.[chr];\n        if (chrId === undefined) {\n            yield [];\n        }\n        else {\n            const result = await fetch(url, { ...opts });\n            if (!result.ok) {\n                throw new Error(`HTTP ${result.status} fetching ${url}: ${await result.text()}`);\n            }\n            const data = await result.json();\n            const uncba = await concat(data.htsget.urls.slice(1), opts);\n            yield* this._fetchChunkFeatures([\n                // fake stuff to pretend to be a Chunk\n                {\n                    buffer: uncba,\n                    _fetchedSize: undefined,\n                    bin: 0,\n                    compareTo() {\n                        return 0;\n                    },\n                    toUniqueString() {\n                        return `${chr}_${min}_${max}`;\n                    },\n                    fetchedSize() {\n                        return 0;\n                    },\n                    minv: {\n                        dataPosition: 0,\n                        blockPosition: 0,\n                        compareTo: () => 0,\n                    },\n                    maxv: {\n                        dataPosition: Number.MAX_SAFE_INTEGER,\n                        blockPosition: 0,\n                        compareTo: () => 0,\n                    },\n                    toString() {\n                        return `${chr}_${min}_${max}`;\n                    },\n                },\n            ], chrId, min, max, opts);\n        }\n    }\n    // @ts-expect-error\n    async _readChunk({ chunk }) {\n        if (!chunk.buffer) {\n            throw new Error('expected chunk.buffer in htsget');\n        }\n        return {\n            data: chunk.buffer,\n            cpositions: [],\n            dpositions: [],\n            chunk,\n        };\n    }\n    async getHeader(opts = {}) {\n        const url = `${this.baseUrl}/${this.trackId}?referenceName=na&class=header`;\n        const result = await fetch(url, opts);\n        if (!result.ok) {\n            throw new Error(`HTTP ${result.status} fetching ${url}: ${await result.text()}`);\n        }\n        const data = await result.json();\n        const uncba = await concat(data.htsget.urls, opts);\n        const dataView = new DataView(uncba.buffer);\n        if (dataView.getInt32(0, true) !== BAM_MAGIC) {\n            throw new Error('Not a BAM file');\n        }\n        const headLen = dataView.getInt32(4, true);\n        const decoder = new TextDecoder('utf8');\n        const headerText = decoder.decode(uncba.subarray(8, 8 + headLen));\n        const samHeader = parseHeaderText(headerText);\n        // use the @SQ lines in the header to figure out the\n        // mapping between ref ref ID numbers and names\n        const idToName = [];\n        const nameToId = {};\n        const sqLines = samHeader.filter(l => l.tag === 'SQ');\n        for (const [refId, sqLine] of sqLines.entries()) {\n            let refName = '';\n            let length = 0;\n            for (const item of sqLine.data) {\n                if (item.tag === 'SN') {\n                    refName = item.value;\n                }\n                else if (item.tag === 'LN') {\n                    length = +item.value;\n                }\n            }\n            nameToId[refName] = refId;\n            idToName[refId] = { refName, length };\n        }\n        this.chrToIndex = nameToId;\n        this.indexToChr = idToName;\n        return samHeader;\n    }\n}\n//# sourceMappingURL=htsget.js.map","import { HtsgetFile } from '@gmod/bam';\nimport BamAdapter from '../BamAdapter/BamAdapter';\nexport default class HtsgetBamAdapter extends BamAdapter {\n    async configurePre() {\n        const htsgetBase = this.getConf('htsgetBase');\n        const htsgetTrackId = this.getConf('htsgetTrackId');\n        const bam = new HtsgetFile({\n            baseUrl: htsgetBase,\n            trackId: htsgetTrackId,\n        });\n        const adapterConfig = this.getConf('sequenceAdapter');\n        if (adapterConfig && this.getSubAdapter) {\n            const adapter = await this.getSubAdapter(adapterConfig);\n            return {\n                bam,\n                sequenceAdapter: adapter.dataAdapter,\n            };\n        }\n        return { bam };\n    }\n}\n"],"names":["concat","arr","opts","res","chunk","url","headers","ret","referer","rest","concatUint8Array","elt","unzip","HtsgetFile","BamFile","args","chr","min","max","chrId","_a","result","data","uncba","dataView","BAM_MAGIC","headLen","headerText","samHeader","parseHeaderText","idToName","nameToId","sqLines","l","refId","sqLine","refName","length","item","HtsgetBamAdapter","BamAdapter","htsgetBase","htsgetTrackId","bam","adapterConfig","adapter"],"mappings":"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","x_google_ignoreList":[0,1]}