class m{constructor(e,t){this.low=e,this.high=t}get max(){return this.clone()}less_than(e){return this.low<e.low||this.low===e.low&&this.high<e.high}equal_to(e){return this.low===e.low&&this.high===e.high}intersect(e){return!this.not_intersect(e)}not_intersect(e){return this.high<e.low||e.high<this.low}merge(e){const t=this.low===void 0?e.low:this.low<e.low?this.low:e.low,i=this.high===void 0?e.high:this.high>e.high?this.high:e.high,r=this.clone();return r.low=t,r.high=i,r}output(){return[this.low,this.high]}comparable_less_than(e,t){return e<t}}class c extends m{clone(){return new c(this.low,this.high)}}const l=1,s=0;class h{constructor(e,t,i=null,r=null,n=null,o=s){if(this.left=i,this.right=r,this.parent=n,this.color=o,this.item={key:void 0,values:[]},t!==void 0&&this.item.values.push(t),e!==void 0)if(Array.isArray(e)){const[a,_]=e;if(!Number.isNaN(a)&&!Number.isNaN(_)){let u=a,f=_;u>f&&([u,f]=[f,u]),this.item.key=new c(u,f)}}else this.item.key=e;this.max=this.item.key?this.item.key.max:void 0}isNil(){return this.item.key===void 0&&this.item.values.length===0&&this.left===null&&this.right===null&&this.color===s}requireKey(){if(!this.item.key)throw new Error("Node key is undefined (nil/sentinel). Operation is not applicable.");return this.item.key}less_than(e){const t=this.requireKey(),i=e.requireKey();return t.less_than(i)}_value_equal(e){const t=this.item.values[0],i=e.item.values[0];return t&&i&&t.equal_to?t.equal_to(i):t===i}equal_to(e){const t=this.requireKey(),i=e.requireKey();return t.equal_to(i)}intersect(e){const t=this.requireKey(),i=e.requireKey();return t.intersect(i)}copy_data(e){this.item.key=e.item.key,this.item.values=e.item.values.slice()}update_max(){this.max=this.item.key?this.item.key.max:void 0,this.right&&this.right.max&&(this.max=this.max?this.max.merge(this.right.max):this.right.max),this.left&&this.left.max&&(this.max=this.max?this.max.merge(this.left.max):this.left.max)}not_intersect_left_subtree(e){if(!this.left)return!0;const t=this.left.max?this.left.max.high:this.left.item.key.high,i=this.requireKey(),r=e.requireKey();return i.comparable_less_than(t,r.low)}not_intersect_right_subtree(e){if(!this.right)return!0;const t=this.right.max?this.right.max.low:this.right.item.key.low,i=this.requireKey(),r=e.requireKey();return i.comparable_less_than(r.high,t)}}class p{constructor(){this.root=null,this.nil_node=new h}get size(){let e=0;return this.tree_walk(this.root,t=>e+=t.item.values.length),e}get keys(){const e=[];return this.tree_walk(this.root,t=>e.push(t.item.key.output())),e}get values(){const e=[];return this.tree_walk(this.root,t=>{for(const i of t.item.values)e.push(i)}),e}get items(){const e=[];return this.tree_walk(this.root,t=>{const i=t.item.key.output();for(const r of t.item.values)e.push({key:i,value:r})}),e}isEmpty(){return this.root==null||this.root===this.nil_node}clear(){this.root=null}insert(e,t=e){if(e===void 0)return;const i=this.tree_search(this.root,new h(e));if(i)return i.item.values.push(t),i;const r=new h(e,t,this.nil_node,this.nil_node,null,l);return this.tree_insert(r),this.recalc_max(r),r}exist(e,t=e){const i=this.tree_search(this.root,new h(e));return i?arguments.length<2||t===e?!0:i.item.values.some(r=>r&&r.equal_to?r.equal_to(t):r===t):!1}remove(e,t=e){const i=this.tree_search(this.root,new h(e));if(!i)return;if(arguments.length<2)return this.tree_delete(i),i;const r=i.item.values.findIndex(n=>n&&n.equal_to?n.equal_to(t):n===t);if(r>=0)return i.item.values.splice(r,1),i.item.values.length===0&&this.tree_delete(i),i}search(e,t=(i,r)=>i===r?r.output():i){const i=new h(e),r=[];this.tree_search_interval(this.root,i,r);const n=[];for(const o of r)for(const a of o.item.values)n.push(t(a,o.item.key));return n}intersect_any(e){const t=new h(e);return this.tree_find_any_interval(this.root,t)}forEach(e){this.tree_walk(this.root,t=>{for(const i of t.item.values)e(t.item.key,i)})}map(e){const t=new p;return this.tree_walk(this.root,i=>{for(const r of i.item.values)t.insert(i.item.key,e(r,i.item.key))}),t}*iterate(e,t=(i,r)=>i===r?r.output():i){let i=null;for(e?i=this.tree_search_nearest_forward(this.root,new h(e)):this.root&&(i=this.local_minimum(this.root));i;){for(const r of i.item.values)yield t(r,i.item.key);i=this.tree_successor(i)}}recalc_max(e){let t=e;for(;t.parent!=null;)t.parent.update_max(),t=t.parent}tree_insert(e){let t=this.root,i=null;if(this.root==null||this.root===this.nil_node)this.root=e;else{for(;t!==this.nil_node;)i=t,e.less_than(t)?t=t.left:t=t.right;e.parent=i,e.less_than(i)?i.left=e:i.right=e}this.insert_fixup(e)}insert_fixup(e){let t,i;for(t=e;t!==this.root&&t.parent.color===l;)t.parent===t.parent.parent.left?(i=t.parent.parent.right,i.color===l?(t.parent.color=s,i.color=s,t.parent.parent.color=l,t=t.parent.parent):(t===t.parent.right&&(t=t.parent,this.rotate_left(t)),t.parent.color=s,t.parent.parent.color=l,this.rotate_right(t.parent.parent))):(i=t.parent.parent.left,i.color===l?(t.parent.color=s,i.color=s,t.parent.parent.color=l,t=t.parent.parent):(t===t.parent.left&&(t=t.parent,this.rotate_right(t)),t.parent.color=s,t.parent.parent.color=l,this.rotate_left(t.parent.parent)));this.root.color=s}tree_delete(e){let t,i;e.left===this.nil_node||e.right===this.nil_node?t=e:t=this.tree_successor(e),t.left!==this.nil_node?i=t.left:i=t.right,i.parent=t.parent,t===this.root?this.root=i:(t===t.parent.left?t.parent.left=i:t.parent.right=i,t.parent.update_max()),this.recalc_max(i),t!==e&&(e.copy_data(t),e.update_max(),this.recalc_max(e)),t.color===s&&this.delete_fixup(i)}delete_fixup(e){let t=e,i;for(;t!==this.root&&t.parent!=null&&t.color===s;)t===t.parent.left?(i=t.parent.right,i.color===l&&(i.color=s,t.parent.color=l,this.rotate_left(t.parent),i=t.parent.right),i.left.color===s&&i.right.color===s?(i.color=l,t=t.parent):(i.right.color===s&&(i.color=l,i.left.color=s,this.rotate_right(i),i=t.parent.right),i.color=t.parent.color,t.parent.color=s,i.right.color=s,this.rotate_left(t.parent),t=this.root)):(i=t.parent.left,i.color===l&&(i.color=s,t.parent.color=l,this.rotate_right(t.parent),i=t.parent.left),i.left.color===s&&i.right.color===s?(i.color=l,t=t.parent):(i.left.color===s&&(i.color=l,i.right.color=s,this.rotate_left(i),i=t.parent.left),i.color=t.parent.color,t.parent.color=s,i.left.color=s,this.rotate_right(t.parent),t=this.root));t.color=s}tree_search(e,t){if(!(e==null||e===this.nil_node))return t.equal_to(e)?e:t.less_than(e)?this.tree_search(e.left,t):this.tree_search(e.right,t)}tree_search_nearest_forward(e,t){let i=null,r=e;for(;r&&r!==this.nil_node;)r.less_than(t)?r.intersect(t)?(i=r,r=r.left):r=r.right:((!i||r.less_than(i))&&(i=r),r=r.left);return i||null}tree_search_interval(e,t,i){e!=null&&e!==this.nil_node&&(e.left!==this.nil_node&&!e.not_intersect_left_subtree(t)&&this.tree_search_interval(e.left,t,i),e.intersect(t)&&i.push(e),e.right!==this.nil_node&&!e.not_intersect_right_subtree(t)&&this.tree_search_interval(e.right,t,i))}tree_find_any_interval(e,t){let i=!1;return e!=null&&e!==this.nil_node&&(e.left!==this.nil_node&&!e.not_intersect_left_subtree(t)&&(i=this.tree_find_any_interval(e.left,t)),i||(i=e.intersect(t)),!i&&e.right!==this.nil_node&&!e.not_intersect_right_subtree(t)&&(i=this.tree_find_any_interval(e.right,t))),i}local_minimum(e){let t=e;for(;t.left!=null&&t.left!==this.nil_node;)t=t.left;return t}local_maximum(e){let t=e;for(;t.right!=null&&t.right!==this.nil_node;)t=t.right;return t}tree_successor(e){let t,i,r;if(e.right!==this.nil_node)t=this.local_minimum(e.right);else{for(i=e,r=e.parent;r!=null&&r.right===i;)i=r,r=r.parent;t=r}return t}rotate_left(e){const t=e.right;e.right=t.left,t.left!==this.nil_node&&(t.left.parent=e),t.parent=e.parent,e===this.root?this.root=t:e===e.parent.left?e.parent.left=t:e.parent.right=t,t.left=e,e.parent=t,e!==null&&e!==this.nil_node&&e.update_max(),t!=null&&t!==this.nil_node&&t.update_max()}rotate_right(e){const t=e.left;e.left=t.right,t.right!==this.nil_node&&(t.right.parent=e),t.parent=e.parent,e===this.root?this.root=t:e===e.parent.left?e.parent.left=t:e.parent.right=t,t.right=e,e.parent=t,e!==null&&e!==this.nil_node&&e.update_max(),t!=null&&t!==this.nil_node&&t.update_max()}tree_walk(e,t){e!=null&&e!==this.nil_node&&(this.tree_walk(e.left,t),t(e),this.tree_walk(e.right,t))}testRedBlackProperty(){let e=!0;return this.tree_walk(this.root,function(t){t.color===l&&(t.left.color===s&&t.right.color===s||(e=!1))}),e}testBlackHeightProperty(e){let t=0,i=0,r=0;if(e.color===s&&t++,e.left!==this.nil_node?i=this.testBlackHeightProperty(e.left):i=1,e.right!==this.nil_node?r=this.testBlackHeightProperty(e.right):r=1,i!==r)throw new Error("Red-black height property violated");return t+=i,t}}export{p as I};
//# sourceMappingURL=main-BANj1I0n.js.map
