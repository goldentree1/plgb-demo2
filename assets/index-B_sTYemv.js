import{bv as E,u as R}from"./index-DUxFddIG.js";function F(p,t,e){const r=Object.create(null),i=e.length,a=t.length,l=9,s=58;let n=0;if(p==="GT"){for(let o=0;o<i;o++){const u=n;for(;n<a&&t.charCodeAt(n)!==l;)n++;r[e[o]]=t.slice(u,n),n++}return r}const c=p.indexOf("GT");if(c===-1)return r;if(c===0){for(let o=0;o<i;o++){const u=n;for(;n<a&&t.charCodeAt(n)!==s&&t.charCodeAt(n)!==l;)n++;for(r[e[o]]=t.slice(u,n);n<a&&t.charCodeAt(n)!==l;)n++;n++}return r}let f=0;for(let o=0;o<c;o++)p.charCodeAt(o)===s&&f++;for(let o=0;o<i;o++){const u=n;let d=n;for(;d<a&&t.charCodeAt(d)!==l;)d++;let N=0,g=u;for(let D=u;D<=d;D++)if(D===d||t.charCodeAt(D)===s){if(N===f){r[e[o]]=t.slice(g,D);break}N++,g=D+1}n=d+1}return r}function v(p){const t=[],e=[];let r=!1,i=!1;const a=p.length;for(let l=0;l<a;l++){const s=p[l];s==='"'?(r=!r,e.push(s)):s==="["?(i=!0,e.push(s)):s==="]"?(i=!1,e.push(s)):s===","&&!r&&!i?(t.push(e.join("").trim()),e.length=0):e.push(s)}return e.length>0&&t.push(e.join("").trim()),t}function C(p,t){const e=p.indexOf(t);return[p.slice(0,e),p.slice(e+1)]}function L(p){const t=p.slice(1,-1),e=v(t),r=[];for(let i=0;i<e.length;i++){const a=e[i],[l,s]=C(a,"=");if(s&&s.startsWith("[")&&s.endsWith("]")){const n=s.slice(1,-1).split(",");for(let c=0;c<n.length;c++)n[c]=n[c].trim();r.push([l,n])}else s&&s.startsWith('"')&&s.endsWith('"')?r.push([l,s.slice(1,-1)]):r.push([l,s])}return Object.fromEntries(r)}const A={InfoFields:{AA:{Number:1,Type:"String",Description:"Ancestral allele"},AC:{Number:"A",Type:"Integer",Description:"Allele count in genotypes, for each ALT allele, in the same order as listed"},AD:{Number:"R",Type:"Integer",Description:"Total read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},AF:{Number:"A",Type:"Float",Description:"Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)"},AN:{Number:1,Type:"Integer",Description:"Total number of alleles in called genotypes"},BQ:{Number:1,Type:"Float",Description:"RMS base quality"},CIGAR:{Number:1,Type:"Float",Description:"Cigar string describing how to align an alternate allele to the reference allele"},DB:{Number:0,Type:"Flag",Description:"dbSNP membership"},DP:{Number:1,Type:"Integer",Description:"combined depth across samples"},END:{Number:1,Type:"Integer",Description:"End position (for use with symbolic alleles)"},H2:{Number:0,Type:"Flag",Description:"HapMap2 membership"},H3:{Number:0,Type:"Flag",Description:"HapMap3 membership"},MQ:{Number:1,Type:null,Description:"RMS mapping quality"},MQ0:{Number:1,Type:"Integer",Description:"Number of MAPQ == 0 reads"},NS:{Number:1,Type:"Integer",Description:"Number of samples with data"},SB:{Number:4,Type:"Integer",Description:"Strand bias"},SOMATIC:{Number:0,Type:"Flag",Description:"Somatic mutation (for cancer genomics)"},VALIDATED:{Number:0,Type:"Flag",Description:"Validated by follow-up experiment"},"1000G":{Number:0,Type:"Flag",Description:"1000 Genomes membership"},IMPRECISE:{Number:0,Type:"Flag",Description:"Imprecise structural variation"},NOVEL:{Number:0,Type:"Flag",Description:"Indicates a novel structural variation"},SVTYPE:{Number:1,Type:"String",Description:"Type of structural variant"},SVLEN:{Number:null,Type:"Integer",Description:"Difference in length between REF and ALT alleles"},CIPOS:{Number:2,Type:"Integer",Description:"Confidence interval around POS for imprecise variants"},CIEND:{Number:2,Type:"Integer",Description:"Confidence interval around END for imprecise variants"},HOMLEN:{Type:"Integer",Description:"Length of base pair identical micro-homology at event breakpoints"},HOMSEQ:{Type:"String",Description:"Sequence of base pair identical micro-homology at event breakpoints"},BKPTID:{Type:"String",Description:"ID of the assembled alternate allele in the assembly file"},MEINFO:{Number:4,Type:"String",Description:"Mobile element info of the form NAME,START,END,POLARITY"},METRANS:{Number:4,Type:"String",Description:"Mobile element transduction info of the form CHR,START,END,POLARITY"},DGVID:{Number:1,Type:"String",Description:"ID of this element in Database of Genomic Variation"},DBVARID:{Number:1,Type:"String",Description:"ID of this element in DBVAR"},DBRIPID:{Number:1,Type:"String",Description:"ID of this element in DBRIP"},MATEID:{Number:null,Type:"String",Description:"ID of mate breakends"},PARID:{Number:1,Type:"String",Description:"ID of partner breakend"},EVENT:{Number:1,Type:"String",Description:"ID of event associated to breakend"},CILEN:{Number:2,Type:"Integer",Description:"Confidence interval around the inserted material between breakend"},DPADJ:{Type:"Integer",Description:"Read Depth of adjacency"},CN:{Number:1,Type:"Integer",Description:"Copy number of segment containing breakend"},CNADJ:{Number:null,Type:"Integer",Description:"Copy number of adjacency"},CICN:{Number:2,Type:"Integer",Description:"Confidence interval around copy number for the segment"},CICNADJ:{Number:null,Type:"Integer",Description:"Confidence interval around copy number for the adjacency"}},GenotypeFields:{AD:{Number:"R",Type:"Integer",Description:"Read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},DP:{Number:1,Type:"Integer",Description:"Read depth"},EC:{Number:"A",Type:"Integer",Description:"Expected alternate allele counts"},FT:{Number:1,Type:"String",Description:'Filter indicating if this genotype was "called"'},GL:{Number:"G",Type:"Float",Description:"Genotype likelihoods"},GP:{Number:"G",Type:"Float",Description:"Genotype posterior probabilities"},GQ:{Number:1,Type:"Integer",Description:"Conditional genotype quality"},GT:{Number:1,Type:"String",Description:"Genotype"},HQ:{Number:2,Type:"Integer",Description:"Haplotype quality"},MQ:{Number:1,Type:"Integer",Description:"RMS mapping quality"},PL:{Number:"G",Type:"Integer",Description:"Phred-scaled genotype likelihoods rounded to the closest integer"},PQ:{Number:1,Type:"Integer",Description:"Phasing quality"},PS:{Number:1,Type:"Integer",Description:"Phase set"}},AltTypes:{DEL:{Description:"Deletion relative to the reference"},INS:{Description:"Insertion of novel sequence relative to the reference"},DUP:{Description:"Region of elevated copy number relative to the reference"},INV:{Description:"Inversion of reference sequence"},CNV:{Description:"Copy number variable region (may be both deletion and duplication)"},"DUP:TANDEM":{Description:"Tandem duplication"},"DEL:ME":{Description:"Deletion of mobile element relative to the reference"},"INS:ME":{Description:"Insertion of a mobile element relative to the reference"},NON_REF:{Description:"Represents any possible alternative allele at this location"},"*":{Description:"Represents any possible alternative allele at this location"}},FilterTypes:{PASS:{Description:"Passed all filters"}}};function M(p){try{return decodeURIComponent(p)}catch{return p}}class G{constructor({header:t,strict:e=!0}){if(!t.length)throw new Error("empty header received");const r=t.split(/[\r\n]+/).filter(Boolean);if(!r.length)throw new Error("no non-empty header lines specified");this.strict=e,this.metadata={INFO:{...A.InfoFields},FORMAT:{...A.GenotypeFields},ALT:{...A.AltTypes},FILTER:{...A.FilterTypes}};let i;for(let n=0;n<r.length;n++){const c=r[n];if(c.startsWith("#"))c.startsWith("##")?this.parseMetadata(c):i=c;else throw new Error(`Bad line in header:
${c}`)}if(!i)throw new Error("No format line found in header");const a=i.trim().split("	"),l=a.slice(0,8),s=["#CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO"];if(a.length<8)throw new Error(`VCF header missing columns:
${i}`);if(l.length!==s.length||!l.every((n,c)=>n===s[c]))throw new Error(`VCF column headers not correct:
${i}`);this.samples=a.slice(9)}parseInfo(t){var s;const e={},r=t.includes("%"),i=t.split(";"),a=this.metadata.INFO,l=i.length;for(let n=0;n<l;n++){const c=i[n],f=c.indexOf("="),o=f===-1?c:c.slice(0,f),u=f===-1?void 0:c.slice(f+1),d=(s=a[o])==null?void 0:s.Type;if(d==="Flag")e[o]=!0;else if(!u)e[o]=!0;else{const N=d==="Integer"||d==="Float",g=u.split(","),D=g.length;if(r){const h=[];for(let m=0;m<D;m++){const b=g[m];if(b===".")h.push(void 0);else{const y=M(b);h.push(N?Number(y):y)}}e[o]=h}else{const h=[];for(let m=0;m<D;m++){const b=g[m];b==="."?h.push(void 0):h.push(N?Number(b):b)}e[o]=h}}}return e}parseSamples(t,e){var i;const r={};if(t){const a=e.split("	"),l=t.split(":"),s=this.metadata.FORMAT,n=[];for(let o=0;o<l.length;o++){const u=(i=s[l[o]])==null?void 0:i.Type;n.push(u==="Integer"||u==="Float")}const c=l.length,f=this.samples.length;for(let o=0;o<f;o++){const u=this.samples[o],d={},N=a[o],g=N.length;let D=0,h=0;for(let m=0;m<=g;m++)if(m===g||N[m]===":"){const b=N.slice(D,m);if(b===""||b===".")d[l[h]]=void 0;else{const y=b.split(","),I=[];if(n[h])for(let T=0;T<y.length;T++){const S=y[T];I.push(S==="."?void 0:+S)}else for(let T=0;T<y.length;T++){const S=y[T];I.push(S==="."?void 0:S)}d[l[h]]=I}if(D=m+1,h+=1,h>=c)break}r[u]=d}}return r}parseMetadata(t){const e=/^##(.+?)=(.*)/.exec(t.trim());if(!e)throw new Error(`Line is not a valid metadata line: ${t}`);const[r,i]=e.slice(1,3),a=r;if(i!=null&&i.startsWith("<")){a in this.metadata||(this.metadata[a]={});const[l,s]=this.parseStructuredMetaVal(i);l?this.metadata[a][l]=s:this.metadata[a]=s}else this.metadata[a]=i}parseStructuredMetaVal(t){const e=L(t),r=e.ID;return delete e.ID,"Number"in e&&(Number.isNaN(Number(e.Number))||(e.Number=Number(e.Number))),[r,e]}getMetadata(...t){let e=this.metadata;const r=t.length;for(let i=0;i<r;i++)if(e=e[t[i]],!e)return e;return e}parseLine(t){let e=0,r=0;for(;e<t.length&&r<9;)t[e]==="	"&&(r+=1),e+=1;const i=r===9?e-1:e,a=t.slice(0,i).split("	"),l=t.slice(i+1),[s,n,c,f,o,u,d]=a,N=s,g=+n,D=c==="."?void 0:c.split(";"),h=f,m=o==="."?void 0:o.split(","),b=u==="."?void 0:+u,y=d==="."?void 0:d.split(";"),I=a[8];if(this.strict&&!a[7])throw new Error("no INFO field specified, must contain at least a '.' (turn off strict mode to allow)");const T=a[7]===void 0||a[7]==="."?{}:this.parseInfo(a[7]);return{CHROM:N,POS:g,ALT:m,INFO:T,REF:h,FILTER:(y==null?void 0:y.length)===1&&y[0]==="PASS"?"PASS":y,ID:D,QUAL:b,FORMAT:I,SAMPLES:()=>this.parseSamples(a[8]??"",l),GENOTYPES:()=>F(a[8]??"",l,this.samples)}}}function P(p,t){const{REF:e="",ALT:r,POS:i,CHROM:a,ID:l}=p,s=i-1,[n,c]=E(e,r,t);return{refName:a,start:s,end:O(p),description:c,type:n,name:l==null?void 0:l.join(",")}}function O(p){var t;const{POS:e,REF:r="",ALT:i=[]}=p,a=i.includes("<TRA>"),l=e-1;if(i.some(n=>n.includes("<"))){const n=p.INFO;if(n.END&&!a)return+n.END[0];const c=[];if(n.SVLEN&&!a){const f=n.SVLEN;for(let o=0;o<f.length;o++){const u=f[o];!((t=i[o])===null||t===void 0)&&t.startsWith("<INS")?c.push(1):c.push(Math.abs(+u))}return l+R.max(c)}}return l+r.length}class V{constructor(t){this.variant=t.variant,this.parser=t.parser,this.data=P(this.variant,this.parser),this._id=t.id}get(t){var e;return t==="samples"?this.variant.SAMPLES():t==="genotypes"?this.variant.GENOTYPES():(e=this.data[t])!==null&&e!==void 0?e:this.variant[t]}parent(){}children(){}id(){return this._id}toJSON(){const{SAMPLES:t,GENOTYPES:e,...r}=this.variant;return{uniqueId:this._id,...r,...this.data,samples:this.variant.SAMPLES()}}}export{G as V,V as a};
//# sourceMappingURL=index-B_sTYemv.js.map
