{"version":3,"file":"NCListAdapter-MDHx5Oqk.js","sources":["../node_modules/@gmod/nclist/esm/array_representation.js","../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js","../node_modules/@gmod/nclist/esm/util.js","../node_modules/@gmod/nclist/esm/lazy_array.js","../node_modules/@gmod/nclist/esm/nclist.js","../node_modules/@gmod/nclist/esm/feature_store.js","../node_modules/@jbrowse/plugin-legacy-jbrowse/esm/NCListAdapter/NCListFeature.js","../node_modules/@jbrowse/plugin-legacy-jbrowse/esm/NCListAdapter/NCListAdapter.js"],"sourcesContent":["//@ts-nocheck\n/**\n * @class ArrayRepr\n *\n * Class for operating on indexed array representations of objects.\n *\n * For example, if we have a lot of objects with similar attributes, e.g.:\n *\n * <pre class=\"code\">\n *     [\n *         {start: 1, end: 2, strand: -1},\n *         {start: 5, end: 6, strand: 1},\n *         ...\n *     ]\n * </pre>\n *\n * @description\n * we can represent them more compactly (e.g., in JSON) something like this:\n *\n * <pre class=\"code\">\n *     class = [\"start\", \"end\", \"strand\"]\n *     [\n *         [1, 2, -1],\n *         [5, 6, 1],\n *         ...\n *     ]\n * </pre>\n *\n * If we want to represent a few different kinds of objects in our big list,\n * we can have multiple \"class\" arrays, and tag each object to identify\n * which \"class\" array describes it.\n *\n * For example, if we have a lot of instances of a few types of objects,\n * like this:\n *\n * <pre class=\"code\">\n *     [\n *         {start: 1, end: 2, strand: 1, id: 1},\n *         {start: 5, end: 6, strand: 1, id: 2},\n *         ...\n *         {start: 10, end: 20, chunk: 1},\n *         {start: 30, end: 40, chunk: 2},\n *         ...\n *     ]\n * </pre>\n *\n * We could use the first array position to indicate the \"class\" for the\n * object, like this:\n *\n * <pre class=\"code\">\n *     classes = [[\"start\", \"end\", \"strand\", \"id\"], [\"start\", \"end\", \"chunk\"]]\n *     [\n *         [0, 1, 2, 1, 1],\n *         [0, 5, 6, 1, 2],\n *         ...\n *         [1, 10, 20, 1],\n *         [1, 30, 40, 1]\n *     ]\n * </pre>\n *\n * Also, if we occasionally want to add an ad-hoc attribute, we could just\n * stick an optional dictionary onto the end:\n *\n * <pre class=\"code\">\n *     classes = [[\"start\", \"end\", \"strand\", \"id\"], [\"start\", \"end\", \"chunk\"]]\n *     [\n *         [0, 1, 2, 1, 1],\n *         [0, 5, 6, 1, 2, {foo: 1}]\n *     ]\n * </pre>\n *\n * Given that individual objects are being represented by arrays, generic\n * code needs some way to differentiate arrays that are meant to be objects\n * from arrays that are actually meant to be arrays.\n * So for each class, we include a dict with <attribute name>: true mappings\n * for each attribute that is meant to be an array.\n *\n * Also, in cases where some attribute values are the same for all objects\n * in a particular set, it may be convenient to define a \"prototype\"\n * with default values for all objects in the set\n *\n * In the end, we get something like this:\n *\n * <pre class=\"code\">\n *     classes=[\n *         {'attributes': ['Start', 'End', 'Subfeatures'],\n *          'proto': {'Chrom': 'chr1'},\n *          'isArrayAttr': {Subfeatures: true}}\n *         ]\n * </pre>\n *\n * That's what this class facilitates.\n */\nclass ArrayRepr {\n    constructor(classes) {\n        this.classes = classes;\n        this.fields = [];\n        for (let cl = 0; cl < classes.length; cl += 1) {\n            this.fields[cl] = {};\n            for (let f = 0; f < classes[cl].attributes.length; f += 1) {\n                this.fields[cl][classes[cl].attributes[f]] = f + 1;\n            }\n            if (classes[cl].proto === undefined) {\n                classes[cl].proto = {};\n            }\n            if (classes[cl].isArrayAttr === undefined) {\n                classes[cl].isArrayAttr = {};\n            }\n        }\n    }\n    /**\n     * @private\n     */\n    attrIndices(attr) {\n        return this.classes.map(x => x.attributes.indexOf(attr) + 1 ||\n            x.attributes.indexOf(attr.toLowerCase()) + 1 ||\n            undefined);\n    }\n    get(obj, attr) {\n        if (attr in this.fields[obj[0]]) {\n            return obj[this.fields[obj[0]][attr]];\n        }\n        // try lowercase\n        const lcattr = attr.toLowerCase();\n        if (lcattr in this.fields[obj[0]]) {\n            return obj[this.fields[obj[0]][lcattr]];\n        }\n        const adhocIndex = this.classes[obj[0]].attributes.length + 1;\n        if (adhocIndex >= obj.length || !(attr in obj[adhocIndex])) {\n            if (attr in this.classes[obj[0]].proto) {\n                return this.classes[obj[0]].proto[attr];\n            }\n            return undefined;\n        }\n        return obj[adhocIndex][attr];\n    }\n    makeSetter(attr) {\n        return (obj, val) => {\n            this.set(obj, attr, val);\n        };\n    }\n    makeGetter(attr) {\n        return obj => {\n            return this.get(obj, attr);\n        };\n    }\n    makeFastGetter(attr) {\n        // can be used only if attr is guaranteed to be in\n        // the \"classes\" array for this object\n        const indices = this.attrIndices(attr);\n        return function get(obj) {\n            if (indices[obj[0]] !== undefined) {\n                return obj[indices[obj[0]]];\n            }\n            return undefined;\n        };\n    }\n    // construct(self, obj, klass) {\n    //   const result = new Array(self.classes[klass].length)\n    //   Object.keys(obj).forEach(attr => {\n    //     this.set(result, attr, obj[attr])\n    //   })\n    //   return result\n    // }\n    /**\n     * Returns fast pre-compiled getter and setter functions for use with\n     * Arrays that use this representation.\n     * When the returned <code>get</code> and <code>set</code> functions are\n     * added as methods to an Array that contains data in this\n     * representation, they provide fast access by name to the data.\n     *\n     * @returns {Object} <code>{ get: function() {...}, set: function(val) {...} }</code>\n     *\n     * @example\n     * var accessors = attrs.accessors();\n     * var feature = get_feature_from_someplace();\n     * feature.get = accessors.get;\n     * // print out the feature start and end\n     * console.log( feature.get('start') + ',' + feature.get('end') );\n     */\n    accessors() {\n        if (!this._accessors) {\n            this._accessors = this._makeAccessors();\n        }\n        return this._accessors;\n    }\n    /**\n     * @private\n     */\n    _makeAccessors() {\n        const indices = {};\n        const accessors = {\n            get(field) {\n                const f = this.get.field_accessors[field.toLowerCase()];\n                if (f) {\n                    return f.call(this);\n                }\n                return undefined;\n            },\n            set(field, val) {\n                const f = this.set.field_accessors[field];\n                if (f) {\n                    return f.call(this, val);\n                }\n                return undefined;\n            },\n            tags() {\n                return tags[this[0]] || [];\n            },\n        };\n        accessors.get.field_accessors = {};\n        accessors.set.field_accessors = {};\n        // make a data structure as: { attr_name: [offset,offset,offset], }\n        // that will be convenient for finding the location of the attr\n        // for a given class like: indexForAttr{attrname}[classnum]\n        this.classes.forEach((cdef, classnum) => {\n            ;\n            (cdef.attributes || []).forEach((attrname, offset) => {\n                indices[attrname] = indices[attrname] || [];\n                indices[attrname][classnum] = offset + 1;\n                attrname = attrname.toLowerCase();\n                indices[attrname] = indices[attrname] || [];\n                indices[attrname][classnum] = offset + 1;\n            });\n        });\n        // lowercase all the class attributes\n        const tags = this.classes.map(c => c.attributes);\n        // use that to make precalculated get and set accessors for each field\n        Object.keys(indices).forEach(attrname => {\n            const attrIndices = indices[attrname];\n            // get\n            accessors.get.field_accessors[attrname] = !attrIndices\n                ? function get() {\n                    return undefined;\n                }\n                : function get() {\n                    return this[attrIndices[this[0]]];\n                };\n            // // set\n            // accessors.set.field_accessors[attrname] = !attrIndices\n            //   ? () => undefined\n            //   : v => {\n            //       this[attrIndices[this[0]]] = v\n            //       return v\n            //     }\n        });\n        return accessors;\n    }\n}\nexport default ArrayRepr;\n/*\n\nCopyright (c) 2007-2010 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n//# sourceMappingURL=array_representation.js.map","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.resolveURI = factory());\n})(this, (function () { 'use strict';\n\n    // Matches the scheme of a URL, eg \"http://\"\n    const schemeRegex = /^[\\w+.-]+:\\/\\//;\n    /**\n     * Matches the parts of a URL:\n     * 1. Scheme, including \":\", guaranteed.\n     * 2. User/password, including \"@\", optional.\n     * 3. Host, guaranteed.\n     * 4. Port, including \":\", optional.\n     * 5. Path, including \"/\", optional.\n     * 6. Query, including \"?\", optional.\n     * 7. Hash, including \"#\", optional.\n     */\n    const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n    /**\n     * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n     * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n     *\n     * 1. Host, optional.\n     * 2. Path, which may include \"/\", guaranteed.\n     * 3. Query, including \"?\", optional.\n     * 4. Hash, including \"#\", optional.\n     */\n    const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n    function isAbsoluteUrl(input) {\n        return schemeRegex.test(input);\n    }\n    function isSchemeRelativeUrl(input) {\n        return input.startsWith('//');\n    }\n    function isAbsolutePath(input) {\n        return input.startsWith('/');\n    }\n    function isFileUrl(input) {\n        return input.startsWith('file:');\n    }\n    function isRelative(input) {\n        return /^[.?#]/.test(input);\n    }\n    function parseAbsoluteUrl(input) {\n        const match = urlRegex.exec(input);\n        return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n    }\n    function parseFileUrl(input) {\n        const match = fileRegex.exec(input);\n        const path = match[2];\n        return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n    }\n    function makeUrl(scheme, user, host, port, path, query, hash) {\n        return {\n            scheme,\n            user,\n            host,\n            port,\n            path,\n            query,\n            hash,\n            type: 7 /* Absolute */,\n        };\n    }\n    function parseUrl(input) {\n        if (isSchemeRelativeUrl(input)) {\n            const url = parseAbsoluteUrl('http:' + input);\n            url.scheme = '';\n            url.type = 6 /* SchemeRelative */;\n            return url;\n        }\n        if (isAbsolutePath(input)) {\n            const url = parseAbsoluteUrl('http://foo.com' + input);\n            url.scheme = '';\n            url.host = '';\n            url.type = 5 /* AbsolutePath */;\n            return url;\n        }\n        if (isFileUrl(input))\n            return parseFileUrl(input);\n        if (isAbsoluteUrl(input))\n            return parseAbsoluteUrl(input);\n        const url = parseAbsoluteUrl('http://foo.com/' + input);\n        url.scheme = '';\n        url.host = '';\n        url.type = input\n            ? input.startsWith('?')\n                ? 3 /* Query */\n                : input.startsWith('#')\n                    ? 2 /* Hash */\n                    : 4 /* RelativePath */\n            : 1 /* Empty */;\n        return url;\n    }\n    function stripPathFilename(path) {\n        // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n        // paths. It's not a file, so we can't strip it.\n        if (path.endsWith('/..'))\n            return path;\n        const index = path.lastIndexOf('/');\n        return path.slice(0, index + 1);\n    }\n    function mergePaths(url, base) {\n        normalizePath(base, base.type);\n        // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n        // path).\n        if (url.path === '/') {\n            url.path = base.path;\n        }\n        else {\n            // Resolution happens relative to the base path's directory, not the file.\n            url.path = stripPathFilename(base.path) + url.path;\n        }\n    }\n    /**\n     * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n     * \"foo/.\". We need to normalize to a standard representation.\n     */\n    function normalizePath(url, type) {\n        const rel = type <= 4 /* RelativePath */;\n        const pieces = url.path.split('/');\n        // We need to preserve the first piece always, so that we output a leading slash. The item at\n        // pieces[0] is an empty string.\n        let pointer = 1;\n        // Positive is the number of real directories we've output, used for popping a parent directory.\n        // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n        let positive = 0;\n        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n        // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n        // real directory, we won't need to append, unless the other conditions happen again.\n        let addTrailingSlash = false;\n        for (let i = 1; i < pieces.length; i++) {\n            const piece = pieces[i];\n            // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n            if (!piece) {\n                addTrailingSlash = true;\n                continue;\n            }\n            // If we encounter a real directory, then we don't need to append anymore.\n            addTrailingSlash = false;\n            // A current directory, which we can always drop.\n            if (piece === '.')\n                continue;\n            // A parent directory, we need to see if there are any real directories we can pop. Else, we\n            // have an excess of parents, and we'll need to keep the \"..\".\n            if (piece === '..') {\n                if (positive) {\n                    addTrailingSlash = true;\n                    positive--;\n                    pointer--;\n                }\n                else if (rel) {\n                    // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                    // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                    pieces[pointer++] = piece;\n                }\n                continue;\n            }\n            // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n            // any popped or dropped directories.\n            pieces[pointer++] = piece;\n            positive++;\n        }\n        let path = '';\n        for (let i = 1; i < pointer; i++) {\n            path += '/' + pieces[i];\n        }\n        if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n            path += '/';\n        }\n        url.path = path;\n    }\n    /**\n     * Attempts to resolve `input` URL/path relative to `base`.\n     */\n    function resolve(input, base) {\n        if (!input && !base)\n            return '';\n        const url = parseUrl(input);\n        let inputType = url.type;\n        if (base && inputType !== 7 /* Absolute */) {\n            const baseUrl = parseUrl(base);\n            const baseType = baseUrl.type;\n            switch (inputType) {\n                case 1 /* Empty */:\n                    url.hash = baseUrl.hash;\n                // fall through\n                case 2 /* Hash */:\n                    url.query = baseUrl.query;\n                // fall through\n                case 3 /* Query */:\n                case 4 /* RelativePath */:\n                    mergePaths(url, baseUrl);\n                // fall through\n                case 5 /* AbsolutePath */:\n                    // The host, user, and port are joined, you can't copy one without the others.\n                    url.user = baseUrl.user;\n                    url.host = baseUrl.host;\n                    url.port = baseUrl.port;\n                // fall through\n                case 6 /* SchemeRelative */:\n                    // The input doesn't have a schema at least, so we need to copy at least that over.\n                    url.scheme = baseUrl.scheme;\n            }\n            if (baseType > inputType)\n                inputType = baseType;\n        }\n        normalizePath(url, inputType);\n        const queryHash = url.query + url.hash;\n        switch (inputType) {\n            // This is impossible, because of the empty checks at the start of the function.\n            // case UrlType.Empty:\n            case 2 /* Hash */:\n            case 3 /* Query */:\n                return queryHash;\n            case 4 /* RelativePath */: {\n                // The first char is always a \"/\", and we need it to be relative.\n                const path = url.path.slice(1);\n                if (!path)\n                    return queryHash || '.';\n                if (isRelative(base || input) && !isRelative(path)) {\n                    // If base started with a leading \".\", or there is no base and input started with a \".\",\n                    // then we need to ensure that the relative path starts with a \".\". We don't know if\n                    // relative starts with a \"..\", though, so check before prepending.\n                    return './' + path + queryHash;\n                }\n                return path + queryHash;\n            }\n            case 5 /* AbsolutePath */:\n                return url.path + queryHash;\n            default:\n                return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n        }\n    }\n\n    return resolve;\n\n}));\n//# sourceMappingURL=resolve-uri.umd.js.map\n","//@ts-nocheck\nimport resolve from '@jridgewell/resolve-uri';\nexport async function readJSON(url, readFile, options = {}) {\n    const { defaultContent = {} } = options;\n    try {\n        const str = await readFile(url, { encoding: 'utf8' });\n        const decoder = new TextDecoder('utf8');\n        return JSON.parse(decoder.decode(str));\n    }\n    catch (error) {\n        if (error.code === 'ENOENT' ||\n            error.status === 404 ||\n            error.message.includes('404') ||\n            error.message.includes('ENOENT')) {\n            return defaultContent;\n        }\n        throw error;\n    }\n}\nexport function newURL(arg, base = '.') {\n    return resolve(arg, base);\n}\n//# sourceMappingURL=util.js.map","//@ts-nocheck\nimport AbortablePromiseCache from '@gmod/abortable-promise-cache';\nimport QuickLRU from '@jbrowse/quick-lru';\nimport { newURL, readJSON } from \"./util.js\";\n/**\n * For a JSON array that gets too large to load in one go, this class\n * helps break it up into chunks and provides an\n * async API for using the information in the array.\n */\nexport default class LazyArray {\n    constructor({ urlTemplate, chunkSize, length, cacheSize = 100, readFile }, baseUrl) {\n        this.urlTemplate = urlTemplate;\n        this.chunkSize = chunkSize;\n        this.length = length;\n        this.baseUrl = baseUrl === undefined ? '' : baseUrl;\n        this.readFile = readFile;\n        if (!readFile) {\n            throw new Error('must provide readFile callback');\n        }\n        this.chunkCache = new AbortablePromiseCache({\n            cache: new QuickLRU({ maxSize: cacheSize }),\n            fill: this.getChunk.bind(this),\n        });\n    }\n    /**\n     * call the callback on one element of the array\n     * @param i index\n     * @param callback callback, gets called with (i, value, param)\n     * @param param (optional) callback will get this as its last parameter\n     */\n    index(i, callback, param) {\n        this.range(i, i, callback, undefined, param);\n    }\n    /**\n     * async generator for the elements in the range [start,end]\n     *\n     * @param start index of first element to call the callback on\n     * @param end index of last element to call the callback on\n     */\n    async *range(start, end) {\n        start = Math.max(0, start);\n        end = Math.min(end, this.length - 1);\n        const firstChunk = Math.floor(start / this.chunkSize);\n        const lastChunk = Math.floor(end / this.chunkSize);\n        const chunkreadFiles = [];\n        for (let chunk = firstChunk; chunk <= lastChunk; chunk += 1) {\n            chunkreadFiles.push(this.chunkCache.get(chunk, chunk));\n        }\n        for (const elt of chunkreadFiles) {\n            const [chunkNumber, chunkData] = await elt;\n            yield* this.filterChunkData(start, end, chunkNumber, chunkData);\n        }\n    }\n    async getChunk(chunkNumber) {\n        let url = this.urlTemplate.replaceAll(/\\{Chunk\\}/gi, chunkNumber);\n        if (this.baseUrl) {\n            url = newURL(url, this.baseUrl);\n        }\n        const data = await readJSON(url, this.readFile);\n        return [chunkNumber, data];\n    }\n    *filterChunkData(queryStart, queryEnd, chunkNumber, chunkData) {\n        // index (in the overall lazy array) of the first position in this chunk\n        const firstIndex = chunkNumber * this.chunkSize;\n        const chunkStart = Math.max(0, queryStart - firstIndex);\n        const chunkEnd = Math.min(queryEnd - firstIndex, this.chunkSize - 1);\n        for (let i = chunkStart; i <= chunkEnd; i += 1) {\n            yield [i + firstIndex, chunkData[i]];\n        }\n    }\n}\n//# sourceMappingURL=lazy_array.js.map","//@ts-nocheck\nimport AbortablePromiseCache from '@gmod/abortable-promise-cache';\nimport QuickLRU from '@jbrowse/quick-lru';\nimport { newURL, readJSON } from \"./util.js\";\nexport default class NCList {\n    constructor({ readFile, cacheSize = 100 }) {\n        this.topList = [];\n        this.chunkCache = new AbortablePromiseCache({\n            cache: new QuickLRU({ maxSize: cacheSize }),\n            fill: this.readChunkItems.bind(this),\n        });\n        this.readFile = readFile;\n        if (!this.readFile) {\n            throw new Error(`must provide a \"readFile\" function`);\n        }\n    }\n    importExisting(nclist, attrs, baseURL, lazyUrlTemplate, lazyClass) {\n        this.topList = nclist;\n        this.attrs = attrs;\n        this.start = attrs.makeFastGetter('Start');\n        this.end = attrs.makeFastGetter('End');\n        this.lazyClass = lazyClass;\n        this.baseURL = baseURL;\n        this.lazyUrlTemplate = lazyUrlTemplate;\n    }\n    binarySearch(arr, item, getter) {\n        let low = -1;\n        let high = arr.length;\n        let mid;\n        while (high - low > 1) {\n            mid = (low + high) >>> 1;\n            if (getter(arr[mid]) >= item) {\n                high = mid;\n            }\n            else {\n                low = mid;\n            }\n        }\n        // if we're iterating rightward, return the high index;\n        // if leftward, the low index\n        if (getter === this.end) {\n            return high;\n        }\n        return low;\n    }\n    readChunkItems(chunkNum) {\n        const url = newURL(this.lazyUrlTemplate.replaceAll(/\\{Chunk\\}/gi, chunkNum), this.baseURL);\n        return readJSON(url, this.readFile, { defaultContent: [] });\n    }\n    async *iterateSublist(arr, from, to, inc, searchGet, testGet, path) {\n        const getChunk = this.attrs.makeGetter('Chunk');\n        const getSublist = this.attrs.makeGetter('Sublist');\n        const pendingPromises = [];\n        for (let i = this.binarySearch(arr, from, searchGet); i < arr.length && i >= 0 && inc * testGet(arr[i]) < inc * to; i += inc) {\n            if (arr[i][0] === this.lazyClass) {\n                // this is a lazily-loaded chunk of the nclist\n                const chunkNum = getChunk(arr[i]);\n                const chunkItemsP = this.chunkCache\n                    .get(chunkNum, chunkNum)\n                    .then(item => [item, chunkNum]);\n                pendingPromises.push(chunkItemsP);\n            }\n            else {\n                // this is just a regular feature\n                yield [arr[i], path.concat(i)];\n            }\n            // if this node has a contained sublist, process that too\n            const sublist = getSublist(arr[i]);\n            if (sublist) {\n                yield* this.iterateSublist(sublist, from, to, inc, searchGet, testGet, path.concat(i));\n            }\n        }\n        for (const p of pendingPromises) {\n            const [item, chunkNum] = await p;\n            if (item) {\n                yield* this.iterateSublist(item, from, to, inc, searchGet, testGet, [\n                    ...path,\n                    chunkNum,\n                ]);\n            }\n        }\n    }\n    async *iterate(from, to) {\n        // calls the given function once for each of the\n        // intervals that overlap the given interval\n        // if from <= to, iterates left-to-right, otherwise iterates right-to-left\n        // inc: iterate leftward or rightward\n        const inc = from > to ? -1 : 1;\n        // searchGet: search on start or end\n        const searchGet = from > to ? this.start : this.end;\n        // testGet: test on start or end\n        const testGet = from > to ? this.end : this.start;\n        if (this.topList.length > 0) {\n            yield* this.iterateSublist(this.topList, from, to, inc, searchGet, testGet, [0]);\n        }\n    }\n    async histogram(from, to, numBins) {\n        // calls callback with a histogram of the feature density\n        // in the given interval\n        const result = new Array(numBins);\n        result.fill(0);\n        const binWidth = (to - from) / numBins;\n        for await (const feat of this.iterate(from, to)) {\n            const firstBin = Math.max(0, ((this.start(feat) - from) / binWidth) | 0);\n            const lastBin = Math.min(numBins, ((this.end(feat) - from) / binWidth) | 0);\n            for (let bin = firstBin; bin <= lastBin; bin += 1) {\n                result[bin] += 1;\n            }\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=nclist.js.map","//@ts-nocheck\nimport AbortablePromiseCache from '@gmod/abortable-promise-cache';\nimport QuickLRU from '@jbrowse/quick-lru';\nimport ArrayRepr from \"./array_representation.js\";\nimport LazyArray from \"./lazy_array.js\";\nimport GenericNCList from \"./nclist.js\";\nimport { newURL, readJSON } from \"./util.js\";\nfunction idfunc() {\n    return this._uniqueID;\n}\nfunction parentfunc() {\n    return this._parent;\n}\nfunction childrenfunc() {\n    return this.get('subfeatures');\n}\n/**\n * Sequence feature store using nested containment\n * lists held in JSON files that are lazily read.\n *\n * @param {object} args constructor args\n * @param {string} args.baseUrl base URL for resolving relative URLs\n * @param {string} args.urlTemplate Template string for\n *  the root file of each reference sequence. The reference sequence\n *  name will be interpolated into this string where `{refseq}` appears.\n * @param {function} args.readFile function to use for reading remote from URLs.\n */\nexport default class NCListStore {\n    constructor({ baseUrl, urlTemplate, readFile, cacheSize = 10 }) {\n        this.baseUrl = baseUrl;\n        this.urlTemplates = { root: urlTemplate };\n        this.readFile = readFile;\n        if (!this.readFile) {\n            throw new Error(`must provide a \"readFile\" function argument`);\n        }\n        this.dataRootCache = new AbortablePromiseCache({\n            cache: new QuickLRU({ maxSize: cacheSize }),\n            fill: this.fetchDataRoot.bind(this),\n        });\n    }\n    makeNCList() {\n        return new GenericNCList({ readFile: this.readFile });\n    }\n    loadNCList(refData, trackInfo, listUrl) {\n        refData.nclist.importExisting(trackInfo.intervals.nclist, refData.attrs, listUrl, trackInfo.intervals.urlTemplate, trackInfo.intervals.lazyClass);\n    }\n    getDataRoot(refName) {\n        return this.dataRootCache.get(refName, refName);\n    }\n    fetchDataRoot(refName) {\n        const url = newURL(this.urlTemplates.root.replaceAll(/{\\s*refseq\\s*}/g, refName), this.baseUrl);\n        // fetch the trackdata\n        return readJSON(url, this.readFile).then(trackInfo => \n        // trackInfo = JSON.parse( trackInfo );\n        this.parseTrackInfo(trackInfo, url));\n    }\n    parseTrackInfo(trackInfo, url) {\n        const refData = {\n            nclist: this.makeNCList(),\n            stats: {\n                featureCount: trackInfo.featureCount || 0,\n            },\n        };\n        if (trackInfo.intervals) {\n            refData.attrs = new ArrayRepr(trackInfo.intervals.classes);\n            this.loadNCList(refData, trackInfo, url);\n        }\n        const { histograms } = trackInfo;\n        if (histograms?.meta) {\n            // eslint-disable-next-line @typescript-eslint/prefer-for-of\n            for (let i = 0; i < histograms.meta.length; i += 1) {\n                histograms.meta[i].lazyArray = new LazyArray({ ...histograms.meta[i].arrayParams, readFile: this.readFile }, url);\n            }\n            refData._histograms = histograms;\n        }\n        // parse any strings in the histogram data that look like numbers\n        if (refData._histograms) {\n            Object.keys(refData._histograms).forEach(key => {\n                const entries = refData._histograms[key];\n                entries.forEach(entry => {\n                    Object.keys(entry).forEach(key2 => {\n                        if (typeof entry[key2] === 'string' &&\n                            String(Number(entry[key2])) === entry[key2]) {\n                            entry[key2] = Number(entry[key2]);\n                        }\n                    });\n                });\n            });\n        }\n        return refData;\n    }\n    async getRegionStats(query) {\n        const data = await this.getDataRoot(query.ref);\n        return data.stats;\n    }\n    /**\n     * fetch binned counts of feature coverage in the given region.\n     *\n     * @param {object} query\n     * @param {string} query.refName reference sequence name\n     * @param {number} query.start region start\n     * @param {number} query.end region end\n     * @param {number} query.numBins number of bins desired in the feature counts\n     * @param {number} query.basesPerBin number of bp desired in each feature counting bin\n     * @returns {object} as:\n     *    `{ bins: hist, stats: statEntry }`\n     */\n    async getRegionFeatureDensities({ refName, start, end, numBins, basesPerBin, }) {\n        const data = await this.getDataRoot(refName);\n        if (numBins) {\n            basesPerBin = (end - start) / numBins;\n        }\n        else if (basesPerBin) {\n            numBins = Math.ceil((end - start) / basesPerBin);\n        }\n        else {\n            throw new TypeError('numBins or basesPerBin arg required for getRegionFeatureDensities');\n        }\n        // pick the relevant entry in our pre-calculated stats\n        const stats = data._histograms.stats || [];\n        const statEntry = stats.find(entry => entry.basesPerBin >= basesPerBin);\n        // The histogramMeta array describes multiple levels of histogram detail,\n        // going from the finest (smallest number of bases per bin) to the coarsest\n        // (largest number of bases per bin).\n        //\n        // We want to use coarsest histogramMeta that's at least as fine as the one\n        // we're currently rendering.\n        //\n        // TODO: take into account that the histogramMeta chosen here might not fit\n        // neatly into the current histogram (e.g., if the current histogram is at\n        // 50,000 bases/bin, and we have server histograms at 20,000 and 2,000\n        // bases/bin, then we should choose the 2,000 histogramMeta rather than the\n        // 20,000)\n        let histogramMeta = data._histograms.meta[0];\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < data._histograms.meta.length; i += 1) {\n            if (basesPerBin >= data._histograms.meta[i].basesPerBin) {\n                histogramMeta = data._histograms.meta[i];\n            }\n        }\n        // number of bins in the server-supplied histogram for each current bin\n        let binRatio = basesPerBin / histogramMeta.basesPerBin;\n        // if the server-supplied histogram fits neatly into our requested\n        if (binRatio > 0.9 && Math.abs(binRatio - Math.round(binRatio)) < 0.0001) {\n            // console.log('server-supplied',query);\n            // we can use the server-supplied counts\n            const firstServerBin = Math.floor(start / histogramMeta.basesPerBin);\n            binRatio = Math.round(binRatio);\n            const histogram = [];\n            for (let bin = 0; bin < numBins; bin += 1) {\n                histogram[bin] = 0;\n            }\n            for await (const [i, val] of histogramMeta.lazyArray.range(firstServerBin, firstServerBin + binRatio * numBins - 1)) {\n                // this will count features that span the boundaries of\n                // the original histogram multiple times, so it's not\n                // perfectly quantitative.  Hopefully it's still useful, though.\n                histogram[Math.floor((i - firstServerBin) / binRatio)] += val;\n            }\n            return { bins: histogram, stats: statEntry };\n        }\n        // console.log('make own',query);\n        // make our own counts\n        const hist = await data.nclist.histogram(start, end, numBins);\n        return { bins: hist, stats: statEntry };\n    }\n    /**\n     * Fetch features in a given region. This method is an asynchronous generator\n     * yielding feature objects.\n     *\n     * @param {object} args\n     * @param {string} args.refName reference sequence name\n     * @param {number} args.start start of region. 0-based half-open.\n     * @param {number} args.end end of region. 0-based half-open.\n     * @yields {object}\n     */\n    async *getFeatures({ refName, start, end }) {\n        const data = await this.getDataRoot(refName);\n        const accessors = data.attrs?.accessors();\n        for await (const [feature, path] of data.nclist.iterate(start, end)) {\n            // the unique ID is a stringification of the path in the\n            // NCList where the feature lives; it's unique across the\n            // top-level NCList (the top-level NCList covers a\n            // track/chromosome combination)\n            // only need to decorate a feature once\n            if (!feature.decorated) {\n                const uniqueID = path.join(',');\n                this.decorateFeature(accessors, feature, `${refName},${uniqueID}`);\n            }\n            yield feature;\n        }\n    }\n    // helper method to recursively add .get and .tags methods to a feature and its\n    // subfeatures\n    decorateFeature(accessors, feature, id, parent) {\n        feature.get = accessors.get;\n        feature.tags = accessors.tags;\n        feature._uniqueID = id;\n        feature.id = idfunc;\n        feature._parent = parent;\n        feature.parent = parentfunc;\n        feature.children = childrenfunc;\n        (feature.get('subfeatures') || []).forEach((f, i) => {\n            this.decorateFeature(accessors, f, `${id}-${i}`, feature);\n        });\n        feature.decorated = true;\n    }\n}\n//# sourceMappingURL=feature_store.js.map","const jb2ToJb1 = { refName: 'seq_id' };\nconst jb1ToJb2 = { seq_id: 'refName' };\nexport default class NCListFeature {\n    constructor(ncFeature, parent, id) {\n        this.ncFeature = ncFeature;\n        this.uniqueId = id || ncFeature.id();\n        this.parentHandle = parent;\n    }\n    set() {\n        throw new Error('not implemented');\n    }\n    jb2TagToJb1Tag(tag) {\n        const mapped = jb2ToJb1[tag] || tag;\n        return mapped.toLowerCase();\n    }\n    jb1TagToJb2Tag(tag) {\n        const t = tag.toLowerCase();\n        return jb1ToJb2[t] || t;\n    }\n    get(attrName) {\n        const attr = this.ncFeature.get(this.jb2TagToJb1Tag(attrName));\n        if (attr && attrName === 'subfeatures') {\n            return attr.map((subfeature) => new NCListFeature(subfeature, this));\n        }\n        return attr;\n    }\n    tags() {\n        return this.ncFeature.tags().map((t) => this.jb1TagToJb2Tag(t));\n    }\n    id() {\n        return this.uniqueId;\n    }\n    parent() {\n        return this.parentHandle;\n    }\n    children() {\n        return this.get('subfeatures');\n    }\n    toJSON() {\n        const data = { uniqueId: this.id() };\n        for (const tag of this.ncFeature.tags()) {\n            const mappedTag = this.jb1TagToJb2Tag(tag);\n            const value = this.ncFeature.get(tag);\n            if (mappedTag === 'subfeatures') {\n                data.subfeatures = (value || []).map((f) => {\n                    return new NCListFeature(f, this).toJSON();\n                });\n            }\n            else {\n                data[mappedTag] = value;\n            }\n        }\n        return data;\n    }\n}\n","import NCListStore from '@gmod/nclist';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { checkStopToken } from '@jbrowse/core/util/stopToken';\nimport { RemoteFile } from 'generic-filehandle2';\nimport NCListFeature from './NCListFeature';\nexport default class NCListAdapter extends BaseFeatureDataAdapter {\n    constructor(config, getSubAdapter, pluginManager) {\n        super(config, getSubAdapter, pluginManager);\n        const refNames = this.getConf('refNames');\n        const rootUrlTemplate = this.getConf('rootUrlTemplate');\n        this.configRefNames = refNames;\n        this.nclist = new NCListStore({\n            baseUrl: '',\n            urlTemplate: rootUrlTemplate.uri,\n            readFile: (url) => new RemoteFile(rootUrlTemplate.baseUri\n                ? new URL(url, rootUrlTemplate.baseUri).toString()\n                : url).readFile(),\n        });\n    }\n    getFeatures(region, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { stopToken } = opts;\n            for await (const feature of this.nclist.getFeatures(region, opts)) {\n                checkStopToken(stopToken);\n                observer.next(this.wrapFeature(feature));\n            }\n            observer.complete();\n        });\n    }\n    wrapFeature(ncFeature) {\n        return new NCListFeature(ncFeature, undefined, `${this.id}-${ncFeature.id()}`);\n    }\n    async hasDataForRefName(refName) {\n        var _a;\n        const root = await this.nclist.getDataRoot(refName);\n        return !!((_a = root === null || root === void 0 ? void 0 : root.stats) === null || _a === void 0 ? void 0 : _a.featureCount);\n    }\n    async getRefNames() {\n        return this.configRefNames || [];\n    }\n}\n"],"names":["ArrayRepr","classes","cl","f","attr","x","obj","lcattr","adhocIndex","val","indices","accessors","field","tags","cdef","classnum","attrname","offset","c","attrIndices","global","factory","module","this","schemeRegex","urlRegex","fileRegex","isAbsoluteUrl","input","isSchemeRelativeUrl","isAbsolutePath","isFileUrl","isRelative","parseAbsoluteUrl","match","makeUrl","parseFileUrl","path","scheme","user","host","port","query","hash","parseUrl","url","stripPathFilename","index","mergePaths","base","normalizePath","type","rel","pieces","pointer","positive","addTrailingSlash","i","piece","resolve","inputType","baseUrl","baseType","queryHash","readJSON","readFile","options","defaultContent","str","decoder","error","newURL","arg","LazyArray","urlTemplate","chunkSize","length","cacheSize","AbortablePromiseCache","QuickLRU","callback","param","start","end","firstChunk","lastChunk","chunkreadFiles","chunk","elt","chunkNumber","chunkData","data","queryStart","queryEnd","firstIndex","chunkStart","chunkEnd","NCList","nclist","attrs","baseURL","lazyUrlTemplate","lazyClass","arr","item","getter","low","high","mid","chunkNum","from","to","inc","searchGet","testGet","getChunk","getSublist","pendingPromises","chunkItemsP","sublist","numBins","result","binWidth","feat","firstBin","lastBin","bin","idfunc","parentfunc","childrenfunc","NCListStore","GenericNCList","refData","trackInfo","listUrl","refName","histograms","key","entry","key2","basesPerBin","statEntry","histogramMeta","binRatio","firstServerBin","histogram","_a","feature","uniqueID","id","parent","jb2ToJb1","jb1ToJb2","NCListFeature","ncFeature","tag","t","attrName","subfeature","mappedTag","value","NCListAdapter","BaseFeatureDataAdapter","config","getSubAdapter","pluginManager","refNames","rootUrlTemplate","RemoteFile","region","opts","ObservableCreate","observer","stopToken","checkStopToken","root"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}