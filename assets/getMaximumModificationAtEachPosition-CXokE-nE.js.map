{"version":3,"file":"getMaximumModificationAtEachPosition-CXokE-nE.js","sources":["../node_modules/@jbrowse/plugin-alignments/esm/MismatchParser/getNextRefPos.js","../node_modules/@jbrowse/plugin-alignments/esm/ModificationParser/getModPositions.js","../node_modules/@jbrowse/plugin-alignments/esm/ModificationParser/getModProbabilities.js","../node_modules/@jbrowse/plugin-alignments/esm/ModificationParser/getMethBins.js","../node_modules/@jbrowse/plugin-alignments/esm/shared/getMaximumModificationAtEachPosition.js"],"sourcesContent":["export function getNextRefPos(cigarOps, positions) {\n    let readPos = 0;\n    let refPos = 0;\n    let currPos = 0;\n    const ret = [];\n    for (let i = 0; i < cigarOps.length && currPos < positions.length; i += 2) {\n        const len = +cigarOps[i];\n        const op = cigarOps[i + 1];\n        if (op === 'S' || op === 'I') {\n            for (let i = 0; i < len && currPos < positions.length; i++) {\n                if (positions[currPos] === readPos + i) {\n                    currPos++;\n                }\n            }\n            readPos += len;\n        }\n        else if (op === 'D' || op === 'N') {\n            refPos += len;\n        }\n        else if (op === 'M' || op === 'X' || op === '=') {\n            for (let i = 0; i < len && currPos < positions.length; i++) {\n                if (positions[currPos] === readPos + i) {\n                    ret.push({\n                        ref: refPos + i,\n                        idx: currPos,\n                    });\n                    currPos++;\n                }\n            }\n            readPos += len;\n            refPos += len;\n        }\n    }\n    return ret;\n}\n","import { revcom } from '@jbrowse/core/util';\nimport { modificationRegex } from './consts';\nexport function getModPositions(mm, fseq, fstrand) {\n    const seq = fstrand === -1 ? revcom(fseq) : fseq;\n    const seqLength = seq.length;\n    const mods = mm.split(';');\n    const result = [];\n    for (const mod of mods) {\n        if (mod === '') {\n            continue;\n        }\n        const split = mod.split(',');\n        const basemod = split[0];\n        const matches = modificationRegex.exec(basemod);\n        if (!matches) {\n            throw new Error(`bad format for MM tag: \"${mod}\"`);\n        }\n        const [, base, strand, typestr] = matches;\n        const types = typestr.split(/(\\d+|.)/);\n        for (const type of types) {\n            if (type === '') {\n                continue;\n            }\n            const splitLength = split.length;\n            let currPos = 0;\n            const positions = fstrand === -1 ? new Array(splitLength - 1) : [];\n            let writeIndex = fstrand === -1 ? splitLength - 2 : 0;\n            for (let i = 1; i < splitLength; i++) {\n                let delta = +split[i];\n                do {\n                    if (base === 'N' || base === seq[currPos]) {\n                        delta--;\n                    }\n                    currPos++;\n                } while (delta >= 0 && currPos < seqLength);\n                if (fstrand === -1) {\n                    const pos = seqLength - currPos;\n                    if (pos >= 0) {\n                        positions[writeIndex--] = pos;\n                    }\n                    else {\n                    }\n                }\n                else {\n                    positions[writeIndex++] = currPos - 1;\n                }\n            }\n            const validPositions = fstrand === -1 ? positions.slice(writeIndex + 1) : positions;\n            result.push({\n                type,\n                base: base,\n                strand: strand,\n                positions: validPositions,\n            });\n        }\n    }\n    return result;\n}\n","import { getTagAlt } from '../util';\nexport function getModProbabilities(feature) {\n    const m = getTagAlt(feature, 'ML', 'Ml') || [];\n    if (m) {\n        const result = [];\n        if (typeof m === 'string') {\n            const parts = m.split(',');\n            for (let i = 0, l = parts.length; i < l; i++) {\n                result.push(+parts[i] / 255);\n            }\n        }\n        else {\n            for (let i = 0, l = m.length; i < l; i++) {\n                result.push(m[i] / 255);\n            }\n        }\n        return result;\n    }\n    else {\n        const mp = getTagAlt(feature, 'MP', 'Mp');\n        if (mp) {\n            const result = [];\n            for (let i = 0, l = mp.length; i < l; i++) {\n                const phred = mp.charCodeAt(i) - 33;\n                result.push(Math.min(1, phred / 50));\n            }\n            return result;\n        }\n        return undefined;\n    }\n}\n","import { getNextRefPos } from '../MismatchParser';\nimport { getModPositions } from './getModPositions';\nimport { getModProbabilities } from './getModProbabilities';\nimport { getTagAlt } from '../util';\nexport function getMethBins(feature, cigarOps) {\n    const fstart = feature.get('start');\n    const fend = feature.get('end');\n    const fstrand = feature.get('strand');\n    const flen = fend - fstart;\n    const mm = getTagAlt(feature, 'MM', 'Mm') || '';\n    const methBins = [];\n    const hydroxyMethBins = [];\n    const methProbs = [];\n    const hydroxyMethProbs = [];\n    const seq = feature.get('seq');\n    if (seq) {\n        const probabilities = getModProbabilities(feature);\n        const modifications = getModPositions(mm, seq, fstrand);\n        let probIndex = 0;\n        for (const { type, positions } of modifications) {\n            for (const { ref, idx } of getNextRefPos(cigarOps, positions)) {\n                if (ref < 0 || ref >= flen) {\n                    continue;\n                }\n                const isReverseStrand = fstrand === -1;\n                const idx2 = probIndex + (isReverseStrand ? positions.length - 1 - idx : idx);\n                const prob = (probabilities === null || probabilities === void 0 ? void 0 : probabilities[idx2]) || 0;\n                if (type === 'm') {\n                    methBins[ref] = 1;\n                    methProbs[ref] = prob;\n                }\n                else if (type === 'h') {\n                    hydroxyMethBins[ref] = 1;\n                    hydroxyMethProbs[ref] = prob;\n                }\n            }\n            probIndex += positions.length;\n        }\n    }\n    return {\n        methBins,\n        hydroxyMethBins,\n        methProbs,\n        hydroxyMethProbs,\n    };\n}\n","import { getNextRefPos, parseCigar } from '../MismatchParser';\nimport { getModPositions } from '../ModificationParser/getModPositions';\nimport { getModProbabilities } from '../ModificationParser/getModProbabilities';\nimport { getTagAlt } from '../util';\nexport function getMaxProbModAtEachPosition(feature, cigarOps) {\n    const fstrand = feature.get('strand');\n    const seq = feature.get('seq');\n    const mm = getTagAlt(feature, 'MM', 'Mm') || '';\n    const ops = cigarOps || parseCigar(feature.get('CIGAR'));\n    if (seq) {\n        const modifications = getModPositions(mm, seq, fstrand);\n        const probabilities = getModProbabilities(feature);\n        const maxProbModForPosition = [];\n        let probIndex = 0;\n        for (const { type, positions } of modifications) {\n            for (const { ref, idx } of getNextRefPos(ops, positions)) {\n                const prob = (probabilities === null || probabilities === void 0 ? void 0 : probabilities[probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)]) || 0;\n                if (!maxProbModForPosition[ref]) {\n                    maxProbModForPosition[ref] = {\n                        type,\n                        prob,\n                        allProbs: [prob],\n                    };\n                }\n                else {\n                    const old = maxProbModForPosition[ref];\n                    maxProbModForPosition[ref] = {\n                        allProbs: [...old.allProbs, prob],\n                        prob: Math.max(old.prob, prob),\n                        type: old.prob > prob ? old.type : type,\n                    };\n                }\n            }\n            probIndex += positions.length;\n        }\n        return maxProbModForPosition;\n    }\n    return undefined;\n}\n"],"names":["getNextRefPos","cigarOps","positions","readPos","refPos","currPos","ret","i","len","op","getModPositions","mm","fseq","fstrand","seq","revcom","seqLength","mods","result","mod","split","basemod","matches","modificationRegex","base","strand","typestr","types","type","splitLength","writeIndex","delta","pos","validPositions","getModProbabilities","feature","m","getTagAlt","parts","l","mp","phred","getMethBins","fstart","fend","flen","methBins","hydroxyMethBins","methProbs","hydroxyMethProbs","probabilities","modifications","probIndex","ref","idx","idx2","prob","getMaxProbModAtEachPosition","ops","parseCigar","maxProbModForPosition","old"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}