{"version":3,"file":"BgzipFastaAdapter-Dd9tdMEJ.js","sources":["../../node_modules/@gmod/indexedfasta/node_modules/@gmod/bgzf-filehandle/esm/long.js","../../node_modules/@gmod/indexedfasta/node_modules/@gmod/bgzf-filehandle/esm/gziIndex.js","../../node_modules/@gmod/indexedfasta/node_modules/@gmod/bgzf-filehandle/esm/util.js","../../node_modules/@gmod/indexedfasta/node_modules/@gmod/bgzf-filehandle/esm/unzip.js","../../node_modules/@gmod/indexedfasta/node_modules/@gmod/bgzf-filehandle/esm/bgzFilehandle.js","../../node_modules/@gmod/indexedfasta/esm/bgzipIndexedFasta.js","../../node_modules/@jbrowse/plugin-sequence/esm/BgzipFastaAdapter/BgzipFastaAdapter.js"],"sourcesContent":["export const TWO_PWR_16_DBL = 1 << 16;\nexport const TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nexport function longFromBytesToUnsigned(source, i = 0) {\n    const low = source[i] |\n        (source[i + 1] << 8) |\n        (source[i + 2] << 16) |\n        (source[i + 3] << 24);\n    const high = source[i + 4] |\n        (source[i + 5] << 8) |\n        (source[i + 6] << 16) |\n        (source[i + 7] << 24);\n    return (high >>> 0) * TWO_PWR_32_DBL + (low >>> 0);\n}\n//# sourceMappingURL=long.js.map","import { longFromBytesToUnsigned } from \"./long.js\";\nconst UNCOMPRESSED_POSITION = 1;\n// binary search to find the block that the\n// read starts in and extend forward from that\nfunction compare(position, entry, nextEntry) {\n    const uncompressedPosition = entry[UNCOMPRESSED_POSITION];\n    const nextUncompressedPosition = nextEntry\n        ? nextEntry[UNCOMPRESSED_POSITION]\n        : Infinity;\n    if (uncompressedPosition <= position && nextUncompressedPosition > position) {\n        // block overlaps read start\n        return 0;\n    }\n    else if (uncompressedPosition < position) {\n        // block is before read start\n        return -1;\n    }\n    else {\n        // block is after read start\n        return 1;\n    }\n}\nexport default class GziIndex {\n    filehandle;\n    index;\n    constructor({ filehandle }) {\n        this.filehandle = filehandle;\n    }\n    _getIndex() {\n        if (!this.index) {\n            this.index = this._readIndex().catch((e) => {\n                this.index = undefined;\n                throw e;\n            });\n        }\n        return this.index;\n    }\n    async _readIndex() {\n        const buf = await this.filehandle.read(8, 0);\n        const numEntries = longFromBytesToUnsigned(buf);\n        if (!numEntries) {\n            return [[0, 0]];\n        }\n        const entries = new Array(numEntries + 1);\n        entries[0] = [0, 0];\n        // TODO rewrite this to make an index-index that stays in memory\n        const bufSize = 8 * 2 * numEntries;\n        if (bufSize > Number.MAX_SAFE_INTEGER) {\n            throw new TypeError('integer overflow');\n        }\n        const b2 = await this.filehandle.read(bufSize, 8);\n        for (let entryNumber = 0; entryNumber < numEntries; entryNumber += 1) {\n            const compressedPos = longFromBytesToUnsigned(b2, entryNumber * 16);\n            const uncompressedPos = longFromBytesToUnsigned(b2, entryNumber * 16 + 8);\n            entries[entryNumber + 1] = [compressedPos, uncompressedPos];\n        }\n        return entries;\n    }\n    async getLastBlock() {\n        const entries = await this._getIndex();\n        return entries.at(-1);\n    }\n    async getRelevantBlocksForRead(length, position) {\n        const endPosition = position + length;\n        if (length === 0) {\n            return [];\n        }\n        const entries = await this._getIndex();\n        const relevant = [];\n        let lowerBound = 0;\n        let upperBound = entries.length - 1;\n        let searchPosition = Math.floor(entries.length / 2);\n        let comparison = compare(position, entries[searchPosition], entries[searchPosition + 1]);\n        while (comparison !== 0) {\n            if (comparison > 0) {\n                upperBound = searchPosition - 1;\n            }\n            else if (comparison < 0) {\n                lowerBound = searchPosition + 1;\n            }\n            searchPosition = Math.ceil((upperBound - lowerBound) / 2) + lowerBound;\n            comparison = compare(position, entries[searchPosition], entries[searchPosition + 1]);\n        }\n        // here's where we read forward\n        relevant.push(entries[searchPosition]);\n        let i = searchPosition + 1;\n        for (; i < entries.length; i += 1) {\n            relevant.push(entries[i]);\n            if (entries[i][UNCOMPRESSED_POSITION] >= endPosition) {\n                break;\n            }\n        }\n        if (relevant[relevant.length - 1][UNCOMPRESSED_POSITION] < endPosition) {\n            relevant.push([]);\n        }\n        return relevant;\n    }\n}\n//# sourceMappingURL=gziIndex.js.map","function sum(array) {\n    let sum = 0;\n    for (const entry of array) {\n        sum += entry.length;\n    }\n    return sum;\n}\nexport function concatUint8Array(args, totalLength) {\n    const mergedArray = new Uint8Array(totalLength ?? sum(args));\n    let offset = 0;\n    for (const entry of args) {\n        mergedArray.set(entry, offset);\n        offset += entry.length;\n    }\n    return mergedArray;\n}\n//# sourceMappingURL=util.js.map","import { Inflate, Z_SYNC_FLUSH } from 'pako-esm2';\nimport { concatUint8Array } from \"./util.js\";\n// browserify-zlib, which is the zlib shim used by default in webpacked code,\n// does not properly uncompress bgzf chunks that contain more than one bgzf\n// block, so export an unzip function that uses @progress/pako-esm2 directly if we are running\n// in a browser.\nexport async function unzip(inputData) {\n    try {\n        let strm;\n        let pos = 0;\n        let inflator;\n        const blocks = [];\n        let totalLength = 0;\n        do {\n            const remainingInput = inputData.subarray(pos);\n            inflator = new Inflate(undefined);\n            ({ strm } = inflator);\n            inflator.push(remainingInput, Z_SYNC_FLUSH);\n            if (inflator.err) {\n                throw new Error(inflator.msg);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n            pos += strm.next_in;\n            const result = inflator.result;\n            blocks.push(result);\n            totalLength += result.length;\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        } while (strm.avail_in);\n        return concatUint8Array(blocks, totalLength);\n    }\n    catch (e) {\n        // return a slightly more informative error message\n        if (/incorrect header check/.exec(`${e}`)) {\n            throw new Error('problem decompressing block: incorrect gzip header check');\n        }\n        throw e;\n    }\n}\n// keeps track of the position of compressed blocks in terms of file offsets,\n// and a decompressed equivalent\n//\n// also slices (0,minv.dataPosition) and (maxv.dataPosition,end) off\nexport async function unzipChunkSlice(inputData, chunk, blockCache) {\n    try {\n        let strm;\n        const { minv, maxv } = chunk;\n        let cpos = minv.blockPosition;\n        let dpos = minv.dataPosition;\n        const chunks = [];\n        const cpositions = [];\n        const dpositions = [];\n        let i = 0;\n        let wasFromCache = false;\n        let totalLength = 0;\n        do {\n            const remainingInput = inputData.subarray(cpos - minv.blockPosition);\n            const cacheKey = cpos.toString();\n            let buffer;\n            let nextIn;\n            // Check cache first\n            const cached = blockCache?.get(cacheKey);\n            if (cached) {\n                buffer = cached.buffer;\n                nextIn = cached.nextIn;\n                wasFromCache = true;\n            }\n            else {\n                // Not in cache, decompress and store\n                const inflator = new Inflate(undefined);\n                ({ strm } = inflator);\n                inflator.push(remainingInput, Z_SYNC_FLUSH);\n                if (inflator.err) {\n                    throw new Error(inflator.msg);\n                }\n                buffer = inflator.result;\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n                nextIn = strm.next_in;\n                wasFromCache = false;\n                // Cache the decompressed block\n                blockCache?.set(cacheKey, { buffer, nextIn });\n            }\n            chunks.push(buffer);\n            let len = buffer.length;\n            cpositions.push(cpos);\n            dpositions.push(dpos);\n            if (chunks.length === 1 && minv.dataPosition) {\n                // this is the first chunk, trim it\n                chunks[0] = chunks[0].subarray(minv.dataPosition);\n                len = chunks[0].length;\n            }\n            const origCpos = cpos;\n            cpos += nextIn;\n            dpos += len;\n            if (origCpos >= maxv.blockPosition) {\n                // this is the last chunk, trim it and stop decompressing. note if it is\n                // the same block is minv it subtracts that already trimmed part of the\n                // slice length\n                chunks[i] = chunks[i].subarray(0, maxv.blockPosition === minv.blockPosition\n                    ? maxv.dataPosition - minv.dataPosition + 1\n                    : maxv.dataPosition + 1);\n                totalLength += chunks[i].length;\n                cpositions.push(cpos);\n                dpositions.push(dpos);\n                break;\n            }\n            totalLength += len;\n            i++;\n        } while (wasFromCache\n            ? cpos < inputData.length + minv.blockPosition\n            : // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n                strm.avail_in);\n        return {\n            buffer: concatUint8Array(chunks, totalLength),\n            cpositions,\n            dpositions,\n        };\n    }\n    catch (e) {\n        // return a slightly more informative error message\n        if (/incorrect header check/.exec(`${e}`)) {\n            throw new Error('problem decompressing block: incorrect gzip header check');\n        }\n        throw e;\n    }\n}\n//# sourceMappingURL=unzip.js.map","import GziIndex from \"./gziIndex.js\";\nimport { unzip } from \"./unzip.js\";\nimport { concatUint8Array } from \"./util.js\";\nexport default class BgzFilehandle {\n    filehandle;\n    gzi;\n    constructor({ filehandle, gziFilehandle, }) {\n        this.filehandle = filehandle;\n        this.gzi = new GziIndex({\n            filehandle: gziFilehandle,\n        });\n    }\n    async _readAndUncompressBlock(compressedPosition, nextCompressedPosition) {\n        let next = nextCompressedPosition;\n        if (!next) {\n            next = (await this.filehandle.stat()).size;\n        }\n        // read the compressed data into the block buffer\n        const blockCompressedLength = next - compressedPosition;\n        const blockBuffer = await this.filehandle.read(blockCompressedLength, compressedPosition);\n        // uncompress it\n        return unzip(blockBuffer);\n    }\n    async read(length, position) {\n        const blockPositions = await this.gzi.getRelevantBlocksForRead(length, position);\n        const blocks = [];\n        for (let blockNum = 0; blockNum < blockPositions.length - 1; blockNum += 1) {\n            const uncompressedBuffer = await this._readAndUncompressBlock(blockPositions[blockNum][0], blockPositions[blockNum + 1][0]);\n            const [, uncompressedPosition] = blockPositions[blockNum];\n            const sourceOffset = uncompressedPosition >= position ? 0 : position - uncompressedPosition;\n            const sourceEnd = Math.min(position + length, uncompressedPosition + uncompressedBuffer.length) - uncompressedPosition;\n            if (sourceOffset >= 0 && sourceOffset < uncompressedBuffer.length) {\n                blocks.push(uncompressedBuffer.subarray(sourceOffset, sourceEnd));\n            }\n        }\n        return concatUint8Array(blocks);\n    }\n}\n//# sourceMappingURL=bgzFilehandle.js.map","import { BgzfFilehandle } from '@gmod/bgzf-filehandle';\nimport { LocalFile } from 'generic-filehandle2';\nimport IndexedFasta from \"./indexedFasta.js\";\nexport default class BgzipIndexedFasta extends IndexedFasta {\n    constructor({ fasta, path, fai, faiPath, gzi, gziPath, }) {\n        super({ fasta, path, fai, faiPath });\n        if (fasta && gzi) {\n            // @ts-expect-error\n            this.fasta = new BgzfFilehandle({\n                filehandle: fasta,\n                gziFilehandle: gzi,\n            });\n        }\n        else if (path && gziPath) {\n            // @ts-expect-error\n            this.fasta = new BgzfFilehandle({\n                filehandle: new LocalFile(path),\n                gziFilehandle: new LocalFile(gziPath),\n            });\n        }\n    }\n}\n//# sourceMappingURL=bgzipIndexedFasta.js.map","import { BgzipIndexedFasta } from '@gmod/indexedfasta';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport IndexedFasta from '../IndexedFastaAdapter/IndexedFastaAdapter';\nexport default class BgzipFastaAdapter extends IndexedFasta {\n    async setupPre() {\n        const fastaLocation = this.getConf('fastaLocation');\n        const faiLocation = this.getConf('faiLocation');\n        const gziLocation = this.getConf('gziLocation');\n        const fastaOpts = {\n            fasta: openLocation(fastaLocation, this.pluginManager),\n            fai: openLocation(faiLocation, this.pluginManager),\n            gzi: openLocation(gziLocation, this.pluginManager),\n        };\n        return { fasta: new BgzipIndexedFasta(fastaOpts) };\n    }\n}\n"],"names":["TWO_PWR_16_DBL","TWO_PWR_32_DBL","longFromBytesToUnsigned","source","i","low","UNCOMPRESSED_POSITION","compare","position","entry","nextEntry","uncompressedPosition","nextUncompressedPosition","GziIndex","filehandle","__publicField","buf","numEntries","entries","bufSize","b2","entryNumber","compressedPos","uncompressedPos","length","endPosition","relevant","lowerBound","upperBound","searchPosition","comparison","sum","array","concatUint8Array","args","totalLength","mergedArray","offset","unzip","inputData","strm","pos","inflator","blocks","remainingInput","Inflate","Z_SYNC_FLUSH","result","BgzFilehandle","gziFilehandle","compressedPosition","nextCompressedPosition","next","blockCompressedLength","blockBuffer","blockPositions","blockNum","uncompressedBuffer","sourceOffset","sourceEnd","BgzipIndexedFasta","IndexedFasta","fasta","path","fai","faiPath","gzi","gziPath","BgzfFilehandle","LocalFile","BgzipFastaAdapter","fastaLocation","faiLocation","gziLocation","fastaOpts","openLocation"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}