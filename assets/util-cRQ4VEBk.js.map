{"version":3,"file":"util-cRQ4VEBk.js","sources":["../../node_modules/@gmod/bed/esm/autoSql.js","../../node_modules/@gmod/bed/esm/as/autoSqlSchemas.js","../../node_modules/@gmod/bed/esm/defaultTypes.js","../../node_modules/@gmod/bed/esm/util.js","../../node_modules/@gmod/bed/esm/parser.js","../../node_modules/@jbrowse/plugin-bed/esm/generateBedMethylFeature.js","../../node_modules/@jbrowse/plugin-bed/esm/generateRepeatMaskerFeature.js","../../node_modules/@jbrowse/plugin-bed/esm/generateUcscTranscript.js","../../node_modules/@jbrowse/plugin-bed/esm/util.js"],"sourcesContent":["/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\"use strict\";\nfunction peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n}\nfunction peg$SyntaxError(message, expected, found, location) {\n    this.message = message;\n    this.expected = expected;\n    this.found = found;\n    this.location = location;\n    this.name = \"SyntaxError\";\n    if (typeof Error.captureStackTrace === \"function\") {\n        Error.captureStackTrace(this, peg$SyntaxError);\n    }\n}\npeg$subclass(peg$SyntaxError, Error);\npeg$SyntaxError.buildMessage = function (expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n        literal: function (expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n        \"class\": function (expectation) {\n            var escapedParts = \"\", i;\n            for (i = 0; i < expectation.parts.length; i++) {\n                escapedParts += expectation.parts[i] instanceof Array\n                    ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n                    : classEscape(expectation.parts[i]);\n            }\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n        any: function (expectation) {\n            return \"any character\";\n        },\n        end: function (expectation) {\n            return \"end of input\";\n        },\n        other: function (expectation) {\n            return expectation.description;\n        }\n    };\n    function hex(ch) {\n        return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n    function literalEscape(s) {\n        return s\n            .replace(/\\\\/g, '\\\\\\\\')\n            .replace(/\"/g, '\\\\\"')\n            .replace(/\\0/g, '\\\\0')\n            .replace(/\\t/g, '\\\\t')\n            .replace(/\\n/g, '\\\\n')\n            .replace(/\\r/g, '\\\\r')\n            .replace(/[\\x00-\\x0F]/g, function (ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) { return '\\\\x' + hex(ch); });\n    }\n    function classEscape(s) {\n        return s\n            .replace(/\\\\/g, '\\\\\\\\')\n            .replace(/\\]/g, '\\\\]')\n            .replace(/\\^/g, '\\\\^')\n            .replace(/-/g, '\\\\-')\n            .replace(/\\0/g, '\\\\0')\n            .replace(/\\t/g, '\\\\t')\n            .replace(/\\n/g, '\\\\n')\n            .replace(/\\r/g, '\\\\r')\n            .replace(/[\\x00-\\x0F]/g, function (ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) { return '\\\\x' + hex(ch); });\n    }\n    function describeExpectation(expectation) {\n        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n    function describeExpected(expected) {\n        var descriptions = new Array(expected.length), i, j;\n        for (i = 0; i < expected.length; i++) {\n            descriptions[i] = describeExpectation(expected[i]);\n        }\n        descriptions.sort();\n        if (descriptions.length > 0) {\n            for (i = 1, j = 1; i < descriptions.length; i++) {\n                if (descriptions[i - 1] !== descriptions[i]) {\n                    descriptions[j] = descriptions[i];\n                    j++;\n                }\n            }\n            descriptions.length = j;\n        }\n        switch (descriptions.length) {\n            case 1:\n                return descriptions[0];\n            case 2:\n                return descriptions[0] + \" or \" + descriptions[1];\n            default:\n                return descriptions.slice(0, -1).join(\", \")\n                    + \", or \"\n                    + descriptions[descriptions.length - 1];\n        }\n    }\n    function describeFound(found) {\n        return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\nfunction peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n    var peg$FAILED = {}, peg$startRuleFunctions = { declaration: peg$parsedeclaration }, peg$startRuleFunction = peg$parsedeclaration, peg$c0 = \"(\", peg$c1 = peg$literalExpectation(\"(\", false), peg$c2 = \")\", peg$c3 = peg$literalExpectation(\")\", false), peg$c4 = function (type, name, comment, fields) { return { type, name, comment, fields }; }, peg$c5 = \"simple\", peg$c6 = peg$literalExpectation(\"simple\", false), peg$c7 = \"object\", peg$c8 = peg$literalExpectation(\"object\", false), peg$c9 = \"table\", peg$c10 = peg$literalExpectation(\"table\", false), peg$c11 = \"auto\", peg$c12 = peg$literalExpectation(\"auto\", false), peg$c13 = \"primary\", peg$c14 = peg$literalExpectation(\"primary\", false), peg$c15 = \"index\", peg$c16 = peg$literalExpectation(\"index\", false), peg$c17 = \"unique\", peg$c18 = peg$literalExpectation(\"unique\", false), peg$c19 = function (f1, w) { return w; }, peg$c20 = function (f1, fds) {\n        if (f1.name) {\n            fds.unshift(f1);\n        }\n        return fds;\n    }, peg$c21 = \"#\", peg$c22 = peg$literalExpectation(\"#\", false), peg$c23 = \";\", peg$c24 = peg$literalExpectation(\";\", false), peg$c25 = function (type, name, comment) { return { type, name, comment }; }, peg$c26 = \"[\", peg$c27 = peg$literalExpectation(\"[\", false), peg$c28 = \"]\", peg$c29 = peg$literalExpectation(\"]\", false), peg$c30 = function (type, size, name, comment) { return { type, size, name, comment }; }, peg$c31 = function (type, vals, name, comment) { return { type, vals, name, comment }; }, peg$c32 = \",\", peg$c33 = peg$literalExpectation(\",\", false), peg$c34 = function (f1, fds) {\n        fds.unshift(f1);\n        return fds;\n    }, peg$c35 = \"int\", peg$c36 = peg$literalExpectation(\"int\", false), peg$c37 = \"uint\", peg$c38 = peg$literalExpectation(\"uint\", false), peg$c39 = \"short\", peg$c40 = peg$literalExpectation(\"short\", false), peg$c41 = \"ushort\", peg$c42 = peg$literalExpectation(\"ushort\", false), peg$c43 = \"byte\", peg$c44 = peg$literalExpectation(\"byte\", false), peg$c45 = \"ubyte\", peg$c46 = peg$literalExpectation(\"ubyte\", false), peg$c47 = \"float\", peg$c48 = peg$literalExpectation(\"float\", false), peg$c49 = \"char\", peg$c50 = peg$literalExpectation(\"char\", false), peg$c51 = \"string\", peg$c52 = peg$literalExpectation(\"string\", false), peg$c53 = \"lstring\", peg$c54 = peg$literalExpectation(\"lstring\", false), peg$c55 = \"enum\", peg$c56 = peg$literalExpectation(\"enum\", false), peg$c57 = \"double\", peg$c58 = peg$literalExpectation(\"double\", false), peg$c59 = \"bigint\", peg$c60 = peg$literalExpectation(\"bigint\", false), peg$c61 = \"set\", peg$c62 = peg$literalExpectation(\"set\", false), peg$c63 = function (t, n) { return t + ' ' + n; }, peg$c64 = /^[a-zA-Z_]/, peg$c65 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], \"_\"], false, false), peg$c66 = /^[a-zA-Z0-9_]/, peg$c67 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \"_\"], false, false), peg$c68 = function (t) { return text(); }, peg$c69 = \"\\\"\", peg$c70 = peg$literalExpectation(\"\\\"\", false), peg$c71 = /^[^\"]/, peg$c72 = peg$classExpectation([\"\\\"\"], true, false), peg$c73 = function (t) { return t.join(''); }, peg$c74 = /^[^\\n\\r]/, peg$c75 = peg$classExpectation([\"\\n\", \"\\r\"], true, false), peg$c76 = function (t) { return t.join('').replace(/^\"/, '').replace(/\"$/, ''); }, peg$c77 = peg$otherExpectation(\"integer\"), peg$c78 = /^[0-9]/, peg$c79 = peg$classExpectation([[\"0\", \"9\"]], false, false), peg$c80 = function () { return parseInt(text(), 10); }, peg$c81 = peg$otherExpectation(\"whitespace\"), peg$c82 = /^[ \\t\\n\\r]/, peg$c83 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false), peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1 }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;\n    if (\"startRule\" in options) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n            throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n    }\n    function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location) {\n        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);\n    }\n    function error(message, location) {\n        location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location);\n    }\n    function peg$literalExpectation(text, ignoreCase) {\n        return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n        return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n    }\n    function peg$anyExpectation() {\n        return { type: \"any\" };\n    }\n    function peg$endExpectation() {\n        return { type: \"end\" };\n    }\n    function peg$otherExpectation(description) {\n        return { type: \"other\", description: description };\n    }\n    function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos], p;\n        if (details) {\n            return details;\n        }\n        else {\n            p = pos - 1;\n            while (!peg$posDetailsCache[p]) {\n                p--;\n            }\n            details = peg$posDetailsCache[p];\n            details = {\n                line: details.line,\n                column: details.column\n            };\n            while (p < pos) {\n                if (input.charCodeAt(p) === 10) {\n                    details.line++;\n                    details.column = 1;\n                }\n                else {\n                    details.column++;\n                }\n                p++;\n            }\n            peg$posDetailsCache[pos] = details;\n            return details;\n        }\n    }\n    function peg$computeLocation(startPos, endPos) {\n        var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);\n        return {\n            start: {\n                offset: startPos,\n                line: startPosDetails.line,\n                column: startPosDetails.column\n            },\n            end: {\n                offset: endPos,\n                line: endPosDetails.line,\n                column: endPosDetails.column\n            }\n        };\n    }\n    function peg$fail(expected) {\n        if (peg$currPos < peg$maxFailPos) {\n            return;\n        }\n        if (peg$currPos > peg$maxFailPos) {\n            peg$maxFailPos = peg$currPos;\n            peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected);\n    }\n    function peg$buildSimpleError(message, location) {\n        return new peg$SyntaxError(message, null, null, location);\n    }\n    function peg$buildStructuredError(expected, found, location) {\n        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);\n    }\n    function peg$parsedeclaration() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parsedeclareType();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parse_();\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parsedeclareName();\n                    if (s4 !== peg$FAILED) {\n                        s5 = peg$parse_();\n                        if (s5 !== peg$FAILED) {\n                            s6 = peg$parsecomment();\n                            if (s6 !== peg$FAILED) {\n                                s7 = peg$parse_();\n                                if (s7 !== peg$FAILED) {\n                                    if (input.charCodeAt(peg$currPos) === 40) {\n                                        s8 = peg$c0;\n                                        peg$currPos++;\n                                    }\n                                    else {\n                                        s8 = peg$FAILED;\n                                        if (peg$silentFails === 0) {\n                                            peg$fail(peg$c1);\n                                        }\n                                    }\n                                    if (s8 !== peg$FAILED) {\n                                        s9 = peg$parse_();\n                                        if (s9 !== peg$FAILED) {\n                                            s10 = peg$parsefieldList();\n                                            if (s10 !== peg$FAILED) {\n                                                s11 = peg$parse_();\n                                                if (s11 !== peg$FAILED) {\n                                                    if (input.charCodeAt(peg$currPos) === 41) {\n                                                        s12 = peg$c2;\n                                                        peg$currPos++;\n                                                    }\n                                                    else {\n                                                        s12 = peg$FAILED;\n                                                        if (peg$silentFails === 0) {\n                                                            peg$fail(peg$c3);\n                                                        }\n                                                    }\n                                                    if (s12 !== peg$FAILED) {\n                                                        s13 = peg$parse_();\n                                                        if (s13 !== peg$FAILED) {\n                                                            peg$savedPos = s0;\n                                                            s1 = peg$c4(s2, s4, s6, s10);\n                                                            s0 = s1;\n                                                        }\n                                                        else {\n                                                            peg$currPos = s0;\n                                                            s0 = peg$FAILED;\n                                                        }\n                                                    }\n                                                    else {\n                                                        peg$currPos = s0;\n                                                        s0 = peg$FAILED;\n                                                    }\n                                                }\n                                                else {\n                                                    peg$currPos = s0;\n                                                    s0 = peg$FAILED;\n                                                }\n                                            }\n                                            else {\n                                                peg$currPos = s0;\n                                                s0 = peg$FAILED;\n                                            }\n                                        }\n                                        else {\n                                            peg$currPos = s0;\n                                            s0 = peg$FAILED;\n                                        }\n                                    }\n                                    else {\n                                        peg$currPos = s0;\n                                        s0 = peg$FAILED;\n                                    }\n                                }\n                                else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                }\n                            }\n                            else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        }\n                        else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    }\n                    else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parsedeclareType() {\n        var s0;\n        if (input.substr(peg$currPos, 6) === peg$c5) {\n            s0 = peg$c5;\n            peg$currPos += 6;\n        }\n        else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c6);\n            }\n        }\n        if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 6) === peg$c7) {\n                s0 = peg$c7;\n                peg$currPos += 6;\n            }\n            else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c8);\n                }\n            }\n            if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 5) === peg$c9) {\n                    s0 = peg$c9;\n                    peg$currPos += 5;\n                }\n                else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c10);\n                    }\n                }\n            }\n        }\n        return s0;\n    }\n    function peg$parsedeclareName() {\n        var s0, s1, s2, s3;\n        s0 = peg$parsename();\n        if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsename();\n            if (s1 !== peg$FAILED) {\n                s2 = peg$parseindexType();\n                if (s2 !== peg$FAILED) {\n                    s1 = [s1, s2];\n                    s0 = s1;\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$parsename();\n                if (s1 !== peg$FAILED) {\n                    if (input.substr(peg$currPos, 4) === peg$c11) {\n                        s2 = peg$c11;\n                        peg$currPos += 4;\n                    }\n                    else {\n                        s2 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                            peg$fail(peg$c12);\n                        }\n                    }\n                    if (s2 !== peg$FAILED) {\n                        s1 = [s1, s2];\n                        s0 = s1;\n                    }\n                    else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n                if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n                    s1 = peg$parsename();\n                    if (s1 !== peg$FAILED) {\n                        s2 = peg$parseindexType();\n                        if (s2 !== peg$FAILED) {\n                            if (input.substr(peg$currPos, 4) === peg$c11) {\n                                s3 = peg$c11;\n                                peg$currPos += 4;\n                            }\n                            else {\n                                s3 = peg$FAILED;\n                                if (peg$silentFails === 0) {\n                                    peg$fail(peg$c12);\n                                }\n                            }\n                            if (s3 !== peg$FAILED) {\n                                s1 = [s1, s2, s3];\n                                s0 = s1;\n                            }\n                            else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        }\n                        else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    }\n                    else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                }\n            }\n        }\n        return s0;\n    }\n    function peg$parseindexType() {\n        var s0;\n        if (input.substr(peg$currPos, 7) === peg$c13) {\n            s0 = peg$c13;\n            peg$currPos += 7;\n        }\n        else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c14);\n            }\n        }\n        if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c15) {\n                s0 = peg$c15;\n                peg$currPos += 5;\n            }\n            else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c16);\n                }\n            }\n            if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 6) === peg$c17) {\n                    s0 = peg$c17;\n                    peg$currPos += 6;\n                }\n                else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c18);\n                    }\n                }\n            }\n        }\n        return s0;\n    }\n    function peg$parsecomment() {\n        var s0;\n        s0 = peg$parsenonQuotedString();\n        if (s0 === peg$FAILED) {\n            s0 = peg$parse_();\n        }\n        return s0;\n    }\n    function peg$parsefieldList() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        s0 = peg$currPos;\n        s1 = peg$parsefield();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n                s3 = [];\n                s4 = peg$currPos;\n                s5 = peg$parse_();\n                if (s5 !== peg$FAILED) {\n                    s6 = peg$parsefield();\n                    if (s6 !== peg$FAILED) {\n                        peg$savedPos = s4;\n                        s5 = peg$c19(s1, s6);\n                        s4 = s5;\n                    }\n                    else {\n                        peg$currPos = s4;\n                        s4 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                }\n                while (s4 !== peg$FAILED) {\n                    s3.push(s4);\n                    s4 = peg$currPos;\n                    s5 = peg$parse_();\n                    if (s5 !== peg$FAILED) {\n                        s6 = peg$parsefield();\n                        if (s6 !== peg$FAILED) {\n                            peg$savedPos = s4;\n                            s5 = peg$c19(s1, s6);\n                            s4 = s5;\n                        }\n                        else {\n                            peg$currPos = s4;\n                            s4 = peg$FAILED;\n                        }\n                    }\n                    else {\n                        peg$currPos = s4;\n                        s4 = peg$FAILED;\n                    }\n                }\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parse_();\n                    if (s4 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c20(s1, s3);\n                        s0 = s1;\n                    }\n                    else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parsecommentStart() {\n        var s0;\n        if (input.charCodeAt(peg$currPos) === 35) {\n            s0 = peg$c21;\n            peg$currPos++;\n        }\n        else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c22);\n            }\n        }\n        return s0;\n    }\n    function peg$parseinternalComment() {\n        var s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parsecommentStart();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parsenonQuotedString();\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parse_();\n                    if (s4 !== peg$FAILED) {\n                        s1 = [s1, s2, s3, s4];\n                        s0 = s1;\n                    }\n                    else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parsefield() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n        s0 = peg$currPos;\n        s1 = peg$parsefieldType();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parsename();\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parse_();\n                    if (s4 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 59) {\n                            s5 = peg$c23;\n                            peg$currPos++;\n                        }\n                        else {\n                            s5 = peg$FAILED;\n                            if (peg$silentFails === 0) {\n                                peg$fail(peg$c24);\n                            }\n                        }\n                        if (s5 !== peg$FAILED) {\n                            s6 = peg$parse_();\n                            if (s6 !== peg$FAILED) {\n                                s7 = peg$parsecomment();\n                                if (s7 !== peg$FAILED) {\n                                    peg$savedPos = s0;\n                                    s1 = peg$c25(s1, s3, s7);\n                                    s0 = s1;\n                                }\n                                else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                }\n                            }\n                            else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        }\n                        else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    }\n                    else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsefieldType();\n            if (s1 !== peg$FAILED) {\n                s2 = peg$parse_();\n                if (s2 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 91) {\n                        s3 = peg$c26;\n                        peg$currPos++;\n                    }\n                    else {\n                        s3 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                            peg$fail(peg$c27);\n                        }\n                    }\n                    if (s3 !== peg$FAILED) {\n                        s4 = peg$parse_();\n                        if (s4 !== peg$FAILED) {\n                            s5 = peg$parsefieldSize();\n                            if (s5 !== peg$FAILED) {\n                                s6 = peg$parse_();\n                                if (s6 !== peg$FAILED) {\n                                    if (input.charCodeAt(peg$currPos) === 93) {\n                                        s7 = peg$c28;\n                                        peg$currPos++;\n                                    }\n                                    else {\n                                        s7 = peg$FAILED;\n                                        if (peg$silentFails === 0) {\n                                            peg$fail(peg$c29);\n                                        }\n                                    }\n                                    if (s7 !== peg$FAILED) {\n                                        s8 = peg$parse_();\n                                        if (s8 !== peg$FAILED) {\n                                            s9 = peg$parsename();\n                                            if (s9 !== peg$FAILED) {\n                                                s10 = peg$parse_();\n                                                if (s10 !== peg$FAILED) {\n                                                    if (input.charCodeAt(peg$currPos) === 59) {\n                                                        s11 = peg$c23;\n                                                        peg$currPos++;\n                                                    }\n                                                    else {\n                                                        s11 = peg$FAILED;\n                                                        if (peg$silentFails === 0) {\n                                                            peg$fail(peg$c24);\n                                                        }\n                                                    }\n                                                    if (s11 !== peg$FAILED) {\n                                                        s12 = peg$parse_();\n                                                        if (s12 !== peg$FAILED) {\n                                                            s13 = peg$parsecomment();\n                                                            if (s13 !== peg$FAILED) {\n                                                                peg$savedPos = s0;\n                                                                s1 = peg$c30(s1, s5, s9, s13);\n                                                                s0 = s1;\n                                                            }\n                                                            else {\n                                                                peg$currPos = s0;\n                                                                s0 = peg$FAILED;\n                                                            }\n                                                        }\n                                                        else {\n                                                            peg$currPos = s0;\n                                                            s0 = peg$FAILED;\n                                                        }\n                                                    }\n                                                    else {\n                                                        peg$currPos = s0;\n                                                        s0 = peg$FAILED;\n                                                    }\n                                                }\n                                                else {\n                                                    peg$currPos = s0;\n                                                    s0 = peg$FAILED;\n                                                }\n                                            }\n                                            else {\n                                                peg$currPos = s0;\n                                                s0 = peg$FAILED;\n                                            }\n                                        }\n                                        else {\n                                            peg$currPos = s0;\n                                            s0 = peg$FAILED;\n                                        }\n                                    }\n                                    else {\n                                        peg$currPos = s0;\n                                        s0 = peg$FAILED;\n                                    }\n                                }\n                                else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                }\n                            }\n                            else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        }\n                        else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    }\n                    else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$parsefieldType();\n                if (s1 !== peg$FAILED) {\n                    s2 = peg$parse_();\n                    if (s2 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 40) {\n                            s3 = peg$c0;\n                            peg$currPos++;\n                        }\n                        else {\n                            s3 = peg$FAILED;\n                            if (peg$silentFails === 0) {\n                                peg$fail(peg$c1);\n                            }\n                        }\n                        if (s3 !== peg$FAILED) {\n                            s4 = peg$parse_();\n                            if (s4 !== peg$FAILED) {\n                                s5 = peg$parsefieldValues();\n                                if (s5 !== peg$FAILED) {\n                                    s6 = peg$parse_();\n                                    if (s6 !== peg$FAILED) {\n                                        if (input.charCodeAt(peg$currPos) === 41) {\n                                            s7 = peg$c2;\n                                            peg$currPos++;\n                                        }\n                                        else {\n                                            s7 = peg$FAILED;\n                                            if (peg$silentFails === 0) {\n                                                peg$fail(peg$c3);\n                                            }\n                                        }\n                                        if (s7 !== peg$FAILED) {\n                                            s8 = peg$parse_();\n                                            if (s8 !== peg$FAILED) {\n                                                s9 = peg$parsename();\n                                                if (s9 !== peg$FAILED) {\n                                                    s10 = peg$parse_();\n                                                    if (s10 !== peg$FAILED) {\n                                                        if (input.charCodeAt(peg$currPos) === 59) {\n                                                            s11 = peg$c23;\n                                                            peg$currPos++;\n                                                        }\n                                                        else {\n                                                            s11 = peg$FAILED;\n                                                            if (peg$silentFails === 0) {\n                                                                peg$fail(peg$c24);\n                                                            }\n                                                        }\n                                                        if (s11 !== peg$FAILED) {\n                                                            s12 = peg$parse_();\n                                                            if (s12 !== peg$FAILED) {\n                                                                s13 = peg$parsecomment();\n                                                                if (s13 !== peg$FAILED) {\n                                                                    peg$savedPos = s0;\n                                                                    s1 = peg$c31(s1, s5, s9, s13);\n                                                                    s0 = s1;\n                                                                }\n                                                                else {\n                                                                    peg$currPos = s0;\n                                                                    s0 = peg$FAILED;\n                                                                }\n                                                            }\n                                                            else {\n                                                                peg$currPos = s0;\n                                                                s0 = peg$FAILED;\n                                                            }\n                                                        }\n                                                        else {\n                                                            peg$currPos = s0;\n                                                            s0 = peg$FAILED;\n                                                        }\n                                                    }\n                                                    else {\n                                                        peg$currPos = s0;\n                                                        s0 = peg$FAILED;\n                                                    }\n                                                }\n                                                else {\n                                                    peg$currPos = s0;\n                                                    s0 = peg$FAILED;\n                                                }\n                                            }\n                                            else {\n                                                peg$currPos = s0;\n                                                s0 = peg$FAILED;\n                                            }\n                                        }\n                                        else {\n                                            peg$currPos = s0;\n                                            s0 = peg$FAILED;\n                                        }\n                                    }\n                                    else {\n                                        peg$currPos = s0;\n                                        s0 = peg$FAILED;\n                                    }\n                                }\n                                else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                }\n                            }\n                            else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        }\n                        else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    }\n                    else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n                if (s0 === peg$FAILED) {\n                    s0 = peg$parseinternalComment();\n                }\n            }\n        }\n        return s0;\n    }\n    function peg$parsefieldValues() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        s0 = peg$currPos;\n        s1 = peg$parsename();\n        if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 44) {\n                s4 = peg$c32;\n                peg$currPos++;\n            }\n            else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c33);\n                }\n            }\n            if (s4 !== peg$FAILED) {\n                s5 = peg$parse_();\n                if (s5 !== peg$FAILED) {\n                    s6 = peg$parsename();\n                    if (s6 !== peg$FAILED) {\n                        peg$savedPos = s3;\n                        s4 = peg$c19(s1, s6);\n                        s3 = s4;\n                    }\n                    else {\n                        peg$currPos = s3;\n                        s3 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                }\n            }\n            else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n            }\n            while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 44) {\n                    s4 = peg$c32;\n                    peg$currPos++;\n                }\n                else {\n                    s4 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c33);\n                    }\n                }\n                if (s4 !== peg$FAILED) {\n                    s5 = peg$parse_();\n                    if (s5 !== peg$FAILED) {\n                        s6 = peg$parsename();\n                        if (s6 !== peg$FAILED) {\n                            peg$savedPos = s3;\n                            s4 = peg$c19(s1, s6);\n                            s3 = s4;\n                        }\n                        else {\n                            peg$currPos = s3;\n                            s3 = peg$FAILED;\n                        }\n                    }\n                    else {\n                        peg$currPos = s3;\n                        s3 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                }\n            }\n            if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c34(s1, s2);\n                s0 = s1;\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parsefieldType() {\n        var s0, s1, s2, s3;\n        if (input.substr(peg$currPos, 3) === peg$c35) {\n            s0 = peg$c35;\n            peg$currPos += 3;\n        }\n        else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c36);\n            }\n        }\n        if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 4) === peg$c37) {\n                s0 = peg$c37;\n                peg$currPos += 4;\n            }\n            else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c38);\n                }\n            }\n            if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 5) === peg$c39) {\n                    s0 = peg$c39;\n                    peg$currPos += 5;\n                }\n                else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c40);\n                    }\n                }\n                if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 6) === peg$c41) {\n                        s0 = peg$c41;\n                        peg$currPos += 6;\n                    }\n                    else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                            peg$fail(peg$c42);\n                        }\n                    }\n                    if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 4) === peg$c43) {\n                            s0 = peg$c43;\n                            peg$currPos += 4;\n                        }\n                        else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) {\n                                peg$fail(peg$c44);\n                            }\n                        }\n                        if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 5) === peg$c45) {\n                                s0 = peg$c45;\n                                peg$currPos += 5;\n                            }\n                            else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) {\n                                    peg$fail(peg$c46);\n                                }\n                            }\n                            if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 5) === peg$c47) {\n                                    s0 = peg$c47;\n                                    peg$currPos += 5;\n                                }\n                                else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) {\n                                        peg$fail(peg$c48);\n                                    }\n                                }\n                                if (s0 === peg$FAILED) {\n                                    if (input.substr(peg$currPos, 4) === peg$c49) {\n                                        s0 = peg$c49;\n                                        peg$currPos += 4;\n                                    }\n                                    else {\n                                        s0 = peg$FAILED;\n                                        if (peg$silentFails === 0) {\n                                            peg$fail(peg$c50);\n                                        }\n                                    }\n                                    if (s0 === peg$FAILED) {\n                                        if (input.substr(peg$currPos, 6) === peg$c51) {\n                                            s0 = peg$c51;\n                                            peg$currPos += 6;\n                                        }\n                                        else {\n                                            s0 = peg$FAILED;\n                                            if (peg$silentFails === 0) {\n                                                peg$fail(peg$c52);\n                                            }\n                                        }\n                                        if (s0 === peg$FAILED) {\n                                            if (input.substr(peg$currPos, 7) === peg$c53) {\n                                                s0 = peg$c53;\n                                                peg$currPos += 7;\n                                            }\n                                            else {\n                                                s0 = peg$FAILED;\n                                                if (peg$silentFails === 0) {\n                                                    peg$fail(peg$c54);\n                                                }\n                                            }\n                                            if (s0 === peg$FAILED) {\n                                                if (input.substr(peg$currPos, 4) === peg$c55) {\n                                                    s0 = peg$c55;\n                                                    peg$currPos += 4;\n                                                }\n                                                else {\n                                                    s0 = peg$FAILED;\n                                                    if (peg$silentFails === 0) {\n                                                        peg$fail(peg$c56);\n                                                    }\n                                                }\n                                                if (s0 === peg$FAILED) {\n                                                    if (input.substr(peg$currPos, 6) === peg$c57) {\n                                                        s0 = peg$c57;\n                                                        peg$currPos += 6;\n                                                    }\n                                                    else {\n                                                        s0 = peg$FAILED;\n                                                        if (peg$silentFails === 0) {\n                                                            peg$fail(peg$c58);\n                                                        }\n                                                    }\n                                                    if (s0 === peg$FAILED) {\n                                                        if (input.substr(peg$currPos, 6) === peg$c59) {\n                                                            s0 = peg$c59;\n                                                            peg$currPos += 6;\n                                                        }\n                                                        else {\n                                                            s0 = peg$FAILED;\n                                                            if (peg$silentFails === 0) {\n                                                                peg$fail(peg$c60);\n                                                            }\n                                                        }\n                                                        if (s0 === peg$FAILED) {\n                                                            if (input.substr(peg$currPos, 3) === peg$c61) {\n                                                                s0 = peg$c61;\n                                                                peg$currPos += 3;\n                                                            }\n                                                            else {\n                                                                s0 = peg$FAILED;\n                                                                if (peg$silentFails === 0) {\n                                                                    peg$fail(peg$c62);\n                                                                }\n                                                            }\n                                                            if (s0 === peg$FAILED) {\n                                                                s0 = peg$currPos;\n                                                                s1 = peg$parsedeclareType();\n                                                                if (s1 !== peg$FAILED) {\n                                                                    s2 = peg$parse_();\n                                                                    if (s2 !== peg$FAILED) {\n                                                                        s3 = peg$parsedeclareName();\n                                                                        if (s3 !== peg$FAILED) {\n                                                                            peg$savedPos = s0;\n                                                                            s1 = peg$c63(s1, s3);\n                                                                            s0 = s1;\n                                                                        }\n                                                                        else {\n                                                                            peg$currPos = s0;\n                                                                            s0 = peg$FAILED;\n                                                                        }\n                                                                    }\n                                                                    else {\n                                                                        peg$currPos = s0;\n                                                                        s0 = peg$FAILED;\n                                                                    }\n                                                                }\n                                                                else {\n                                                                    peg$currPos = s0;\n                                                                    s0 = peg$FAILED;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return s0;\n    }\n    function peg$parsefieldSize() {\n        var s0;\n        s0 = peg$parsenumber();\n        if (s0 === peg$FAILED) {\n            s0 = peg$parsename();\n        }\n        return s0;\n    }\n    function peg$parsename() {\n        var s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        if (peg$c64.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n        }\n        else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c65);\n            }\n        }\n        if (s2 !== peg$FAILED) {\n            s3 = [];\n            if (peg$c66.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n            }\n            else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c67);\n                }\n            }\n            while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                if (peg$c66.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                }\n                else {\n                    s4 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c67);\n                    }\n                }\n            }\n            if (s3 !== peg$FAILED) {\n                s2 = [s2, s3];\n                s1 = s2;\n            }\n            else {\n                peg$currPos = s1;\n                s1 = peg$FAILED;\n            }\n        }\n        else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c68(s1);\n        }\n        s0 = s1;\n        return s0;\n    }\n    function peg$parsequotedString() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 34) {\n            s1 = peg$c69;\n            peg$currPos++;\n        }\n        else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c70);\n            }\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = [];\n            if (peg$c71.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n            }\n            else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c72);\n                }\n            }\n            while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                if (peg$c71.test(input.charAt(peg$currPos))) {\n                    s3 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                }\n                else {\n                    s3 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c72);\n                    }\n                }\n            }\n            if (s2 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 34) {\n                    s3 = peg$c69;\n                    peg$currPos++;\n                }\n                else {\n                    s3 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c70);\n                    }\n                }\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c73(s2);\n                    s0 = s1;\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parsenonQuotedString() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        if (peg$c74.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n        }\n        else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c75);\n            }\n        }\n        while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            if (peg$c74.test(input.charAt(peg$currPos))) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n            }\n            else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c75);\n                }\n            }\n        }\n        if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c76(s1);\n        }\n        s0 = s1;\n        return s0;\n    }\n    function peg$parsenumber() {\n        var s0, s1, s2, s3;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n            s2 = [];\n            if (peg$c78.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n            }\n            else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c79);\n                }\n            }\n            if (s3 !== peg$FAILED) {\n                while (s3 !== peg$FAILED) {\n                    s2.push(s3);\n                    if (peg$c78.test(input.charAt(peg$currPos))) {\n                        s3 = input.charAt(peg$currPos);\n                        peg$currPos++;\n                    }\n                    else {\n                        s3 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                            peg$fail(peg$c79);\n                        }\n                    }\n                }\n            }\n            else {\n                s2 = peg$FAILED;\n            }\n            if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c80();\n                s0 = s1;\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c77);\n            }\n        }\n        return s0;\n    }\n    function peg$parse_() {\n        var s0, s1;\n        peg$silentFails++;\n        s0 = [];\n        if (peg$c82.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n        }\n        else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c83);\n            }\n        }\n        while (s1 !== peg$FAILED) {\n            s0.push(s1);\n            if (peg$c82.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n            }\n            else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c83);\n                }\n            }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c81);\n            }\n        }\n        return s0;\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n    }\n    else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n            peg$fail(peg$endExpectation());\n        }\n        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length\n            ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n            : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n}\nexport { peg$SyntaxError as SyntaxError, peg$parse as parse };\nexport default { SyntaxError: peg$SyntaxError, parse: peg$parse };\n//# sourceMappingURL=autoSql.js.map","export const bigChain = `table bigChain\n\"bigChain pairwise alignment\"\n    (\n    string chrom;       \"Reference sequence chromosome or scaffold\"\n    uint   chromStart;  \"Start position in chromosome\"\n    uint   chromEnd;    \"End position in chromosome\"\n    string name;        \"Name or ID of item, ideally both human readable and unique\"\n    uint score;         \"Score (0-1000)\"\n    char[1] strand;     \"+ or - for strand\"\n    uint tSize;         \"size of target sequence\"\n    string qName;       \"name of query sequence\"\n    uint qSize;         \"size of query sequence\"\n    uint qStart;        \"start of alignment on query sequence\"\n    uint qEnd;          \"end of alignment on query sequence\"\n    uint chainScore;    \"score from chain\"\n    )`;\nexport const bigGenePred = `table bigGenePred\n\"bigGenePred gene models\"\n   (\n   string chrom;       \"Reference sequence chromosome or scaffold\"\n   uint   chromStart;  \"Start position in chromosome\"\n   uint   chromEnd;    \"End position in chromosome\"\n   string name;        \"Name or ID of item, ideally both human readable and unique\"\n   uint score;         \"Score (0-1000)\"\n   char[1] strand;     \"+ or - for strand\"\n   uint thickStart;    \"Start of where display should be thick (start codon)\"\n   uint thickEnd;      \"End of where display should be thick (stop codon)\"\n   uint reserved;       \"RGB value (use R,G,B string in input file)\"\n   int blockCount;     \"Number of blocks\"\n   int[blockCount] blockSizes; \"Comma separated list of block sizes\"\n   int[blockCount] chromStarts; \"Start positions relative to chromStart\"\n   string name2;       \"Alternative/human readable name\"\n   string cdsStartStat; \"Status of CDS start annotation (none, unknown, incomplete, or complete)\"\n   string cdsEndStat;   \"Status of CDS end annotation (none, unknown, incomplete, or complete)\"\n   int[blockCount] exonFrames; \"Exon frame {0,1,2}, or -1 if no frame for exon\"\n   string type;        \"Transcript type\"\n   string geneName;    \"Primary identifier for gene\"\n   string geneName2;   \"Alternative/human readable gene name\"\n   string geneType;    \"Gene type\"\n   )`;\nexport const bigInteract = `table interact\n\"interaction between two regions\"\n    (\n    string chrom;        \"Chromosome (or contig, scaffold, etc.). For interchromosomal, use 2 records\"\n    uint chromStart;     \"Start position of lower region. For interchromosomal, set to chromStart of this region\"\n    uint chromEnd;       \"End position of upper region. For interchromosomal, set to chromEnd of this region\"\n    string name;         \"Name of item, for display.  Usually 'sourceName/targetName/exp' or empty\"\n    uint score;          \"Score (0-1000)\"\n    double value;        \"Strength of interaction or other data value. Typically basis for score\"\n    string exp;          \"Experiment name (metadata for filtering). Use . if not applicable\"\n    string color;        \"Item color.  Specified as r,g,b or hexadecimal #RRGGBB or html color name, as in //www.w3.org/TR/css3-color/#html4. Use 0 and spectrum setting to shade by score\"\n    string sourceChrom;  \"Chromosome of source region (directional) or lower region. For non-directional interchromosomal, chrom of this region.\"\n    uint sourceStart;    \"Start position in chromosome of source/lower/this region\"\n    uint sourceEnd;      \"End position in chromosome of source/lower/this region\"\n    string sourceName;   \"Identifier of source/lower/this region\"\n    string sourceStrand; \"Orientation of source/lower/this region: + or -.  Use . if not applicable\"\n    string targetChrom;  \"Chromosome of target region (directional) or upper region. For non-directional interchromosomal, chrom of other region\"\n    uint targetStart;    \"Start position in chromosome of target/upper/this region\"\n    uint targetEnd;      \"End position in chromosome of target/upper/this region\"\n    string targetName;   \"Identifier of target/upper/this region\"\n    string targetStrand; \"Orientation of target/upper/this region: + or -.  Use . if not applicable\"\n\n    )`;\nexport const bigLink = `table bigLink\n\"bigLink pairwise alignment\"\n    (\n    string chrom;       \"Reference sequence chromosome or scaffold\"\n    uint   chromStart;  \"Start position in chromosome\"\n    uint   chromEnd;    \"End position in chromosome\"\n    string name;        \"Name or ID of item, ideally both human readable and unique\"\n    uint qStart;        \"start of alignment on query sequence\"\n    )`;\nexport const bigMaf = `table bedMaf\n\"Bed3 with MAF block\"\n    (\n    string chrom;      \"Reference sequence chromosome or scaffold\"\n    uint   chromStart; \"Start position in chromosome\"\n    uint   chromEnd;   \"End position in chromosome\"\n    lstring mafBlock;   \"MAF block\"\n    )`;\nexport const bigNarrowPeak = `table bigNarrowPeak\n\"BED6+4 Peaks of signal enrichment based on pooled, normalized (interpreted) data.\"\n(\n    string chrom;        \"Reference sequence chromosome or scaffold\"\n    uint   chromStart;   \"Start position in chromosome\"\n    uint   chromEnd;     \"End position in chromosome\"\n    string name;\t \"Name given to a region (preferably unique). Use . if no name is assigned\"\n    uint   score;        \"Indicates how dark the peak will be displayed in the browser (0-1000) \"\n    char[1]  strand;     \"+ or - or . for unknown\"\n    float  signalValue;  \"Measurement of average enrichment for the region\"\n    float  pValue;       \"Statistical significance of signal value (-log10). Set to -1 if not used.\"\n    float  qValue;       \"Statistical significance with multiple-test correction applied (FDR -log10). Set to -1 if not used.\"\n    int   peak;         \"Point-source called for this peak; 0-based offset from chromStart. Set to -1 if no point-source called.\"\n)`;\nexport const bigPsl = `table bigPsl\n\"bigPsl pairwise alignment\"\n    (\n    string chrom;       \"Reference sequence chromosome or scaffold\"\n    uint   chromStart;  \"Start position in chromosome\"\n    uint   chromEnd;    \"End position in chromosome\"\n    string name;        \"Name or ID of item, ideally both human readable and unique\"\n    uint score;         \"Score (0-1000)\"\n    char[1] strand;     \"+ or - indicates whether the query aligns to the + or - strand on the reference\"\n    uint thickStart;    \"Start of where display should be thick (start codon)\"\n    uint thickEnd;      \"End of where display should be thick (stop codon)\"\n    uint reserved;       \"RGB value (use R,G,B string in input file)\"\n    int blockCount;     \"Number of blocks\"\n    int[blockCount] blockSizes; \"Comma separated list of block sizes\"\n    int[blockCount] chromStarts; \"Start positions relative to chromStart\"\n\n    uint    oChromStart;\"Start position in other chromosome\"\n    uint    oChromEnd;  \"End position in other chromosome\"\n    char[1] oStrand;    \"+ or -, - means that psl was reversed into BED-compatible coordinates\"\n    uint    oChromSize; \"Size of other chromosome.\"\n    int[blockCount] oChromStarts; \"Start positions relative to oChromStart or from oChromStart+oChromSize depending on strand\"\n\n    lstring  oSequence;  \"Sequence on other chrom (or empty)\"\n    string   oCDS;       \"CDS in NCBI format\"\n\n    uint    chromSize;\"Size of target chromosome\"\n\n    uint match;        \"Number of bases matched.\"\n    uint misMatch; \" Number of bases that don't match \"\n    uint repMatch; \" Number of bases that match but are part of repeats \"\n    uint nCount;   \" Number of 'N' bases \"\n    uint seqType;    \"0=empty, 1=nucleotide, 2=amino_acid\"\n    )`;\nexport const defaultBedSchema = `table defaultBedSchema\n\"BED12\"\n    (\n    string chrom;      \"The name of the chromosome (e.g. chr3, chrY, chr2_random) or scaffold (e.g. scaffold10671).\"\n    uint   chromStart; \"The starting position of the feature in the chromosome or scaffold. The first base in a chromosome is numbered 0.\"\n    uint   chromEnd;   \"The ending position of the feature in the chromosome or scaffold. The chromEnd base is not included in the display of the feature. For example, the first 100 bases of a chromosome are defined as chromStart=0, chromEnd=100, and span the bases numbered 0-99.\"\n    string   name;   \"Defines the name of the BED line.\"\n    float   score;   \"Feature score, doesn't care about the 0-1000 limit as in bed\"\n    char   strand;   \"Defines the strand. Either '.' (=no strand) or '+' or '-'\"\n    uint thickStart; \"The starting position at which the feature is drawn thickly (for example, the start codon in gene displays). When there is no thick part, thickStart and thickEnd are usually set to the chromStart position.\"\n    uint thickEnd; \"The ending position at which the feature is drawn thickly (for example the stop codon in gene displays).\"\n    string itemRgb; \"An RGB value of the form R,G,B (e.g. 255,0,0). \"\n    uint blockCount; \" The number of blocks (exons) in the BED line.\"\n    uint[blockCount] blockSizes; \" A comma-separated list of the block sizes. The number of items in this list should correspond to blockCount.\"\n    uint[blockCount] blockStarts; \"A comma-separated list of block starts. All of the blockStart positions should be calculated relative to chromStart. The number of items in this list should correspond to blockCount.\"\n    )`;\nexport const mafFrames = `table mafFrames\n\"codon frame assignment for MAF components\"\n    (\n    string chrom;      \"Reference sequence chromosome or scaffold\"\n    uint   chromStart; \"Start range in chromosome\"\n    uint   chromEnd;   \"End range in chromosome\"\n    string src;        \"Name of sequence source in MAF\"\n    ubyte frame;       \"frame (0,1,2) for first base(+) or last bast(-)\"\n    char[1] strand;    \"+ or -\"\n    string name;       \"Name of gene used to define frame\"\n    int    prevFramePos;  \"target position of the previous base (in transcription direction) that continues this frame, or -1 if none, or frame not contiguous\"\n    int    nextFramePos;  \"target position of the next base (in transcription direction) that continues this frame, or -1 if none, or frame not contiguous\"\n    ubyte  isExonStart;  \"does this start the CDS portion of an exon?\"\n    ubyte  isExonEnd;    \"does this end the CDS portion of an exon?\"\n    )`;\nexport const mafSummary = `table mafSummary\n\"Positions and scores for alignment blocks\"\n    (\n    string chrom;      \"Reference sequence chromosome or scaffold\"\n    uint   chromStart; \"Start position in chromosome\"\n    uint   chromEnd;   \"End position in chromosome\"\n    string src;        \"Sequence name or database of alignment\"\n    float  score;      \"Floating point score.\"\n    char[1] leftStatus;  \"Gap/break annotation for preceding block\"\n    char[1] rightStatus; \"Gap/break annotation for following block\"\n    )`;\n//# sourceMappingURL=autoSqlSchemas.js.map","import * as types from \"./as/autoSqlSchemas.js\";\nimport parser from './autoSql.js';\nexport default Object.fromEntries(Object.entries(types).map(([key, value]) => [\n    key,\n    parser.parse(value.trim()),\n]));\n//# sourceMappingURL=defaultTypes.js.map","/*\n * adds some type annotations to the autoSql schema for numeric fields ['uint',\n * 'int', 'float', 'long'] \"isNumeric\" is added for array types \"isArray\" is\n * added for numeric array types \"isArray\" and \"arrayIsNumeric\" is set\n *\n * @param autoSql - an autoSql schema from the peg parser\n * @return autoSql with type annotations added\n */\nexport function detectTypes(autoSql) {\n    const numericTypes = new Set(['uint', 'int', 'float', 'long']);\n    return {\n        ...autoSql,\n        fields: autoSql.fields\n            .map(autoField => ({\n            ...autoField,\n            isArray: autoField.size && autoField.type !== 'char',\n            arrayIsNumeric: autoField.size && numericTypes.has(autoField.type),\n            isNumeric: !autoField.size && numericTypes.has(autoField.type),\n        }))\n            // this is needed because the autoSql doesn't properly parse comments in the autoSql\n            .filter(f => !!f.name),\n    };\n}\n//# sourceMappingURL=util.js.map","import parser from './autoSql.js';\nimport types from \"./defaultTypes.js\";\nimport { detectTypes } from \"./util.js\";\nconst strandMap = { '.': 0, '-': -1, '+': 1 };\n// heuristic that a BED file is BED12 like...the number in col 10 is\n// blockCount-like\nfunction isBed12Like(fields) {\n    return (fields.length >= 12 &&\n        !Number.isNaN(Number.parseInt(fields[9], 10)) &&\n        fields[10]?.split(',').filter(f => !!f).length ===\n            Number.parseInt(fields[9], 10));\n}\nexport default class BED {\n    autoSql;\n    attemptDefaultBed;\n    constructor(arguments_ = {}) {\n        if (arguments_.autoSql) {\n            this.autoSql = detectTypes(parser.parse(arguments_.autoSql));\n        }\n        else if (arguments_.type) {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (!types[arguments_.type]) {\n                throw new Error('Type not found');\n            }\n            this.autoSql = detectTypes(types[arguments_.type]);\n        }\n        else {\n            this.autoSql = detectTypes(types.defaultBedSchema);\n            this.attemptDefaultBed = true;\n        }\n    }\n    /*\n     * parses a line of text as a BED line with the loaded autoSql schema\n     *\n     * @param line - a BED line as tab delimited text or array\n     * @param opts - supply opts.uniqueId\n     * @return a object representing a feature\n     */\n    parseLine(line, options = {}) {\n        const { autoSql } = this;\n        const { uniqueId } = options;\n        const fields = Array.isArray(line) ? line : line.split('\\t');\n        let feature = {};\n        if (!this.attemptDefaultBed ||\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            (this.attemptDefaultBed && isBed12Like(fields))) {\n            for (let index = 0; index < autoSql.fields.length; index++) {\n                const autoField = autoSql.fields[index];\n                let columnValue = fields[index];\n                const { isNumeric, isArray, arrayIsNumeric, name } = autoField;\n                if (columnValue === null || columnValue === undefined) {\n                    break;\n                }\n                if (columnValue !== '.') {\n                    if (isNumeric) {\n                        const number_ = Number(columnValue);\n                        columnValue = Number.isNaN(number_) ? columnValue : number_;\n                    }\n                    else if (isArray) {\n                        columnValue = columnValue.split(',');\n                        if (columnValue.at(-1) === '') {\n                            columnValue.pop();\n                        }\n                        if (arrayIsNumeric) {\n                            columnValue = columnValue.map(Number);\n                        }\n                    }\n                    feature[name] = columnValue;\n                }\n            }\n        }\n        else {\n            const fieldNames = ['chrom', 'chromStart', 'chromEnd', 'name'];\n            feature = Object.fromEntries(fields.map((f, index) => [fieldNames[index] || 'field' + index, f]));\n            feature.chromStart = +feature.chromStart;\n            feature.chromEnd = +feature.chromEnd;\n            if (!Number.isNaN(Number.parseFloat(feature.field4))) {\n                feature.score = +feature.field4;\n                delete feature.field4;\n            }\n            if (feature.field5 === '+' || feature.field5 === '-') {\n                feature.strand = feature.field5;\n                delete feature.field5;\n            }\n        }\n        if (uniqueId) {\n            feature.uniqueId = uniqueId;\n        }\n        feature.strand = strandMap[feature.strand] || 0;\n        feature.chrom = decodeURIComponent(feature.chrom);\n        return feature;\n    }\n}\n//# sourceMappingURL=parser.js.map","export function isBedMethylFeature({ splitLine, start, end, }) {\n    return (+(splitLine[6] || 0) === start &&\n        +(splitLine[7] || 0) === end &&\n        [9, 10, 11, 12, 13, 14, 15, 16, 17].every(r => splitLine[r] && !Number.isNaN(+splitLine[r])));\n}\nexport function generateBedMethylFeature({ splitLine, uniqueId, refName, start, end, }) {\n    const [, , , code, , strand, , , color, n_valid_cov, fraction_modified, n_mod, n_canonical, n_other_mod, n_delete, n_fail, n_diff, n_nocall,] = splitLine;\n    return {\n        uniqueId,\n        refName,\n        start,\n        end,\n        code,\n        score: +fraction_modified || 0,\n        strand,\n        color,\n        source: code,\n        n_valid_cov,\n        fraction_modified,\n        n_mod,\n        n_canonical,\n        n_other_mod,\n        n_delete,\n        n_fail,\n        n_diff,\n        n_nocall,\n    };\n}\n","export function isRepeatMaskerDescriptionField(desc) {\n    const ret = desc === null || desc === void 0 ? void 0 : desc.trim().split(' ');\n    return [0, 1, 2, 3, 5, 6].every(s => (ret === null || ret === void 0 ? void 0 : ret[s]) !== undefined ? !Number.isNaN(+ret[s]) : false);\n}\nfunction makeRepeatTrackDescription(description) {\n    if (isRepeatMaskerDescriptionField(description)) {\n        const [bitsw_score, percent_div, percent_del, percent_ins, query_chr, query_begin, query_end, query_remaining, orientation, matching_repeat_name, matching_repeat_class, matching_repeat_begin, matching_repeat_end, matching_repeat_remaining, repeat_id,] = description.trim().split(' ');\n        return {\n            bitsw_score,\n            percent_div,\n            percent_del,\n            percent_ins,\n            query_chr,\n            query_begin,\n            query_end,\n            query_remaining,\n            orientation,\n            matching_repeat_name,\n            matching_repeat_class,\n            matching_repeat_begin,\n            matching_repeat_end,\n            matching_repeat_remaining,\n            repeat_id,\n        };\n    }\n    return { description };\n}\nexport function generateRepeatMaskerFeature({ uniqueId, refName, start, end, description, ...rest }) {\n    const { subfeatures, ...rest2 } = rest;\n    return {\n        ...rest2,\n        ...makeRepeatTrackDescription(description),\n        uniqueId,\n        refName,\n        start,\n        end,\n    };\n}\n","export function isUcscTranscript({ thickStart, blockCount, strand, }) {\n    return thickStart && blockCount && strand !== 0;\n}\nexport function generateUcscTranscript(data) {\n    const { strand = 0, chrom: _1, chromStart: _2, chromEnd: _3, chromStarts, blockStarts, blockSizes, uniqueId, ...rest } = data;\n    const { subfeatures: oldSubfeatures, thickStart, thickEnd, blockCount, refName, ...rest2 } = rest;\n    const subfeatures = [];\n    const feats = oldSubfeatures\n        .filter(child => child.type === 'block')\n        .sort((a, b) => a.start - b.start);\n    const { cdsEndStat, cdsStartStat } = rest2;\n    if (cdsStartStat === 'none' && cdsEndStat === 'none') {\n        return {\n            ...rest2,\n            uniqueId,\n            strand,\n            type: 'transcript',\n            refName,\n            subfeatures: feats.map(e => ({\n                ...e,\n                type: 'exon',\n            })),\n        };\n    }\n    else {\n        for (const block of feats) {\n            const start = block.start;\n            const end = block.end;\n            if (thickStart >= end) {\n                subfeatures.push({\n                    type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n                    start,\n                    end,\n                    refName,\n                });\n            }\n            else if (thickStart > start && thickStart < end && thickEnd >= end) {\n                subfeatures.push({\n                    type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n                    start,\n                    end: thickStart,\n                    refName,\n                }, {\n                    type: 'CDS',\n                    phase: 0,\n                    start: thickStart,\n                    end,\n                    refName,\n                });\n            }\n            else if (thickStart <= start && thickEnd >= end) {\n                subfeatures.push({\n                    type: 'CDS',\n                    phase: 0,\n                    start,\n                    end,\n                    refName,\n                });\n            }\n            else if (thickStart > start && thickStart < end && thickEnd < end) {\n                subfeatures.push({\n                    type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n                    start,\n                    end: thickStart,\n                    refName,\n                }, {\n                    type: 'CDS',\n                    phase: 0,\n                    start: thickStart,\n                    end: thickEnd,\n                    refName,\n                }, {\n                    type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n                    start: thickEnd,\n                    end,\n                    refName,\n                });\n            }\n            else if (thickStart <= start && thickEnd > start && thickEnd < end) {\n                subfeatures.push({\n                    type: 'CDS',\n                    phase: 0,\n                    start,\n                    end: thickEnd,\n                    refName,\n                }, {\n                    type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n                    start: thickEnd,\n                    end,\n                    refName,\n                });\n            }\n            else if (thickEnd <= start) {\n                subfeatures.push({\n                    type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n                    start,\n                    end,\n                    refName,\n                });\n            }\n        }\n        return {\n            ...rest2,\n            uniqueId,\n            strand,\n            type: 'mRNA',\n            refName,\n            subfeatures,\n        };\n    }\n    return {\n        ...rest2,\n        uniqueId,\n        strand,\n        type: 'mRNA',\n        refName,\n        subfeatures,\n    };\n}\n","import { generateBedMethylFeature, isBedMethylFeature, } from './generateBedMethylFeature';\nimport { generateRepeatMaskerFeature, isRepeatMaskerDescriptionField, } from './generateRepeatMaskerFeature';\nimport { generateUcscTranscript, isUcscTranscript, } from './generateUcscTranscript';\nfunction defaultParser(fields, splitLine) {\n    let hasBlockCount = false;\n    const r = [];\n    for (let i = 0; i < splitLine.length; i++) {\n        if (fields[i] === 'blockCount') {\n            hasBlockCount = true;\n        }\n        r.push([fields[i], splitLine[i]]);\n    }\n    const obj = Object.fromEntries(r);\n    if (hasBlockCount) {\n        const { blockStarts, blockCount, chromStarts, thickEnd, thickStart, blockSizes, ...rest } = obj;\n        return {\n            ...rest,\n            blockStarts: arrayify(blockStarts),\n            chromStarts: arrayify(chromStarts),\n            blockSizes: arrayify(blockSizes),\n            thickStart: thickStart ? +thickStart : undefined,\n            thickEnd: thickEnd ? +thickEnd : undefined,\n            blockCount: blockCount ? +blockCount : undefined,\n        };\n    }\n    else {\n        return obj;\n    }\n}\nexport function makeBlocks({ start, uniqueId, refName, chromStarts, blockCount, blockSizes, blockStarts, }) {\n    const subfeatures = [];\n    const starts = chromStarts || blockStarts || [];\n    for (let b = 0; b < blockCount; b++) {\n        const bmin = (starts[b] || 0) + start;\n        const bsize = blockSizes === null || blockSizes === void 0 ? void 0 : blockSizes[b];\n        if (bsize && bsize > 0) {\n            const bmax = bmin + bsize;\n            subfeatures.push({\n                uniqueId: `${uniqueId}-${b}`,\n                start: bmin,\n                end: bmax,\n                refName,\n                type: 'block',\n            });\n        }\n    }\n    return subfeatures;\n}\nexport function featureData({ line, colRef, colStart, colEnd, scoreColumn, parser, uniqueId, names, }) {\n    const splitLine = line.split('\\t');\n    const refName = splitLine[colRef];\n    const start = Number.parseInt(splitLine[colStart], 10);\n    const end = Number.parseInt(splitLine[colEnd], 10) + (colStart === colEnd ? 1 : 0);\n    return featureData2({\n        splitLine,\n        refName,\n        start,\n        end,\n        parser,\n        uniqueId,\n        scoreColumn,\n        names,\n    });\n}\nexport function featureData2({ splitLine, refName, start, end, parser, uniqueId, scoreColumn, names, }) {\n    const data = names\n        ? defaultParser(names, splitLine)\n        : parser.parseLine(splitLine, { uniqueId });\n    const { strand: strand2, score: score2, chrom: _1, chromStart: _2, chromEnd: _3, ...rest } = data;\n    const score = scoreColumn ? +data[scoreColumn] : score2 ? +score2 : undefined;\n    const strand = typeof strand2 === 'string' ? (strand2 === '-' ? -1 : 1) : strand2;\n    const subfeatures = rest.blockCount\n        ? makeBlocks({\n            start,\n            uniqueId,\n            refName,\n            chromStarts: rest.chromStarts,\n            blockCount: rest.blockCount,\n            blockSizes: rest.blockSizes,\n            blockStarts: rest.blockStarts,\n        })\n        : undefined;\n    if (isBedMethylFeature({ splitLine, start, end })) {\n        return generateBedMethylFeature({\n            splitLine,\n            uniqueId,\n            refName,\n            start,\n            end,\n        });\n    }\n    else if (isRepeatMaskerDescriptionField(rest.description)) {\n        const { chromStarts, blockSizes, blockStarts, type, blockCount, thickStart, thickEnd, description, ...rest2 } = rest;\n        return generateRepeatMaskerFeature({\n            ...rest2,\n            uniqueId,\n            description,\n            type,\n            score,\n            start,\n            end,\n            strand,\n            refName,\n            subfeatures,\n        });\n    }\n    else if (subfeatures &&\n        isUcscTranscript({\n            strand,\n            blockCount: rest.blockCount,\n            thickStart: rest.thickStart,\n        })) {\n        const { chromStarts, blockSizes, type, blockCount, thickStart, thickEnd, description, } = rest;\n        return generateUcscTranscript({\n            ...rest,\n            description,\n            chromStarts,\n            thickStart,\n            thickEnd,\n            blockSizes,\n            blockCount,\n            type,\n            score,\n            start,\n            end,\n            strand,\n            refName,\n            uniqueId,\n            subfeatures,\n        });\n    }\n    else {\n        return {\n            ...rest,\n            uniqueId,\n            score,\n            start,\n            end,\n            strand,\n            refName,\n            subfeatures,\n        };\n    }\n}\nexport function arrayify(f) {\n    return f !== undefined\n        ? typeof f === 'string'\n            ? f.split(',').map(f => +f)\n            : f\n        : undefined;\n}\n"],"names":["peg$subclass","child","parent","ctor","peg$SyntaxError","message","expected","found","location","DESCRIBE_EXPECTATION_FNS","expectation","literalEscape","escapedParts","i","classEscape","hex","ch","s","describeExpectation","describeExpected","descriptions","j","describeFound","peg$parse","input","options","peg$FAILED","peg$startRuleFunctions","peg$parsedeclaration","peg$startRuleFunction","peg$c0","peg$c1","peg$literalExpectation","peg$c2","peg$c3","peg$c4","type","name","comment","fields","peg$c5","peg$c6","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$c12","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","peg$c19","f1","w","peg$c20","fds","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","size","peg$c31","vals","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","peg$c63","t","n","peg$c64","peg$c65","peg$classExpectation","peg$c66","peg$c67","peg$c68","text","peg$c74","peg$c75","peg$c76","peg$c77","peg$otherExpectation","peg$c78","peg$c79","peg$c80","peg$c81","peg$c82","peg$c83","peg$currPos","peg$savedPos","peg$posDetailsCache","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","peg$result","ignoreCase","parts","inverted","peg$endExpectation","description","peg$computePosDetails","pos","details","p","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","peg$fail","peg$buildStructuredError","s0","s1","s2","s3","s4","s5","s6","s7","s8","s9","s10","s11","s12","s13","peg$parse_","peg$parsedeclareType","peg$parsedeclareName","peg$parsecomment","peg$parsefieldList","peg$parsename","peg$parseindexType","peg$parsenonQuotedString","peg$parsefield","peg$parsecommentStart","peg$parseinternalComment","peg$parsefieldType","peg$parsefieldSize","peg$parsefieldValues","peg$parsenumber","parser","bigChain","bigGenePred","bigInteract","bigLink","bigMaf","bigNarrowPeak","bigPsl","defaultBedSchema","mafFrames","mafSummary","types","key","value","detectTypes","autoSql","numericTypes","autoField","f","strandMap","isBed12Like","_a","BED","arguments_","__publicField","line","uniqueId","feature","index","columnValue","isNumeric","isArray","arrayIsNumeric","number_","fieldNames","isBedMethylFeature","splitLine","start","end","r","generateBedMethylFeature","refName","code","strand","color","n_valid_cov","fraction_modified","n_mod","n_canonical","n_other_mod","n_delete","n_fail","n_diff","n_nocall","isRepeatMaskerDescriptionField","desc","ret","makeRepeatTrackDescription","bitsw_score","percent_div","percent_del","percent_ins","query_chr","query_begin","query_end","query_remaining","orientation","matching_repeat_name","matching_repeat_class","matching_repeat_begin","matching_repeat_end","matching_repeat_remaining","repeat_id","generateRepeatMaskerFeature","rest","subfeatures","rest2","isUcscTranscript","thickStart","blockCount","generateUcscTranscript","data","_1","_2","_3","chromStarts","blockStarts","blockSizes","oldSubfeatures","thickEnd","feats","a","b","cdsEndStat","cdsStartStat","e","block","defaultParser","hasBlockCount","obj","arrayify","makeBlocks","starts","bmin","bsize","bmax","featureData","colRef","colStart","colEnd","scoreColumn","names","featureData2","strand2","score2","score"],"mappings":"yKAMA,SAASA,GAAaC,EAAOC,EAAQ,CACjC,SAASC,GAAO,CAAE,KAAK,YAAcF,CAAO,CAC5CE,EAAK,UAAYD,EAAO,UACxBD,EAAM,UAAY,IAAIE,CAC1B,CACA,SAASC,EAAgBC,EAASC,EAAUC,EAAOC,EAAU,CACzD,KAAK,QAAUH,EACf,KAAK,SAAWC,EAChB,KAAK,MAAQC,EACb,KAAK,SAAWC,EAChB,KAAK,KAAO,cACR,OAAO,MAAM,mBAAsB,YACnC,MAAM,kBAAkB,KAAMJ,CAAe,CAErD,CACAJ,GAAaI,EAAiB,KAAK,EACnCA,EAAgB,aAAe,SAAUE,EAAUC,EAAO,CACtD,IAAIE,EAA2B,CAC3B,QAAS,SAAUC,EAAa,CAC5B,MAAO,IAAOC,EAAcD,EAAY,IAAI,EAAI,GACpD,EACA,MAAS,SAAUA,EAAa,CAC5B,IAAIE,EAAe,GAAIC,EACvB,IAAKA,EAAI,EAAGA,EAAIH,EAAY,MAAM,OAAQG,IACtCD,GAAgBF,EAAY,MAAMG,CAAC,YAAa,MAC1CC,EAAYJ,EAAY,MAAMG,CAAC,EAAE,CAAC,CAAC,EAAI,IAAMC,EAAYJ,EAAY,MAAMG,CAAC,EAAE,CAAC,CAAC,EAChFC,EAAYJ,EAAY,MAAMG,CAAC,CAAC,EAE1C,MAAO,KAAOH,EAAY,SAAW,IAAM,IAAME,EAAe,GACpE,EACA,IAAK,SAAUF,EAAa,CACxB,MAAO,eACX,EACA,IAAK,SAAUA,EAAa,CACxB,MAAO,cACX,EACA,MAAO,SAAUA,EAAa,CAC1B,OAAOA,EAAY,WACvB,CACR,EACI,SAASK,EAAIC,EAAI,CACb,OAAOA,EAAG,WAAW,CAAC,EAAE,SAAS,EAAE,EAAE,YAAW,CACpD,CACA,SAASL,EAAcM,EAAG,CACtB,OAAOA,EACF,QAAQ,MAAO,MAAM,EACrB,QAAQ,KAAM,KAAK,EACnB,QAAQ,MAAO,KAAK,EACpB,QAAQ,MAAO,KAAK,EACpB,QAAQ,MAAO,KAAK,EACpB,QAAQ,MAAO,KAAK,EACpB,QAAQ,eAAgB,SAAUD,EAAI,CAAE,MAAO,OAASD,EAAIC,CAAE,CAAG,CAAC,EAClE,QAAQ,wBAAyB,SAAUA,EAAI,CAAE,MAAO,MAAQD,EAAIC,CAAE,CAAG,CAAC,CACnF,CACA,SAASF,EAAYG,EAAG,CACpB,OAAOA,EACF,QAAQ,MAAO,MAAM,EACrB,QAAQ,MAAO,KAAK,EACpB,QAAQ,MAAO,KAAK,EACpB,QAAQ,KAAM,KAAK,EACnB,QAAQ,MAAO,KAAK,EACpB,QAAQ,MAAO,KAAK,EACpB,QAAQ,MAAO,KAAK,EACpB,QAAQ,MAAO,KAAK,EACpB,QAAQ,eAAgB,SAAUD,EAAI,CAAE,MAAO,OAASD,EAAIC,CAAE,CAAG,CAAC,EAClE,QAAQ,wBAAyB,SAAUA,EAAI,CAAE,MAAO,MAAQD,EAAIC,CAAE,CAAG,CAAC,CACnF,CACA,SAASE,EAAoBR,EAAa,CACtC,OAAOD,EAAyBC,EAAY,IAAI,EAAEA,CAAW,CACjE,CACA,SAASS,EAAiBb,EAAU,CAChC,IAAIc,EAAe,IAAI,MAAMd,EAAS,MAAM,EAAGO,EAAGQ,EAClD,IAAKR,EAAI,EAAGA,EAAIP,EAAS,OAAQO,IAC7BO,EAAaP,CAAC,EAAIK,EAAoBZ,EAASO,CAAC,CAAC,EAGrD,GADAO,EAAa,KAAI,EACbA,EAAa,OAAS,EAAG,CACzB,IAAKP,EAAI,EAAGQ,EAAI,EAAGR,EAAIO,EAAa,OAAQP,IACpCO,EAAaP,EAAI,CAAC,IAAMO,EAAaP,CAAC,IACtCO,EAAaC,CAAC,EAAID,EAAaP,CAAC,EAChCQ,KAGRD,EAAa,OAASC,CAC1B,CACA,OAAQD,EAAa,OAAM,CACvB,IAAK,GACD,OAAOA,EAAa,CAAC,EACzB,IAAK,GACD,OAAOA,EAAa,CAAC,EAAI,OAASA,EAAa,CAAC,EACpD,QACI,OAAOA,EAAa,MAAM,EAAG,EAAE,EAAE,KAAK,IAAI,EACpC,QACAA,EAAaA,EAAa,OAAS,CAAC,CAC1D,CACI,CACA,SAASE,EAAcf,EAAO,CAC1B,OAAOA,EAAQ,IAAOI,EAAcJ,CAAK,EAAI,IAAO,cACxD,CACA,MAAO,YAAcY,EAAiBb,CAAQ,EAAI,QAAUgB,EAAcf,CAAK,EAAI,SACvF,EACA,SAASgB,GAAUC,EAAOC,EAAS,CAC/BA,EAAUA,IAAY,OAASA,EAAU,CAAA,EACtC,IAACC,EAAa,CAAA,EAAIC,EAAyB,CAAE,YAAaC,EAAoB,EAAIC,EAAwBD,GAAsBE,EAAS,IAAKC,EAASC,EAAuB,IAAK,EAAK,EAAGC,EAAS,IAAKC,EAASF,EAAuB,IAAK,EAAK,EAAGG,EAAS,SAAUC,EAAMC,EAAMC,EAASC,EAAQ,CAAE,MAAO,CAAE,KAAAH,EAAM,KAAAC,EAAM,QAAAC,EAAS,OAAAC,CAAM,CAAI,EAAGC,EAAS,SAAUC,EAAST,EAAuB,SAAU,EAAK,EAAGU,EAAS,SAAUC,EAASX,EAAuB,SAAU,EAAK,EAAGY,EAAS,QAASC,EAAUb,EAAuB,QAAS,EAAK,EAAGc,EAAU,OAAQC,EAAUf,EAAuB,OAAQ,EAAK,EAAGgB,EAAU,UAAWC,EAAUjB,EAAuB,UAAW,EAAK,EAAGkB,EAAU,QAASC,EAAUnB,EAAuB,QAAS,EAAK,EAAGoB,EAAU,SAAUC,EAAUrB,EAAuB,SAAU,EAAK,EAAGsB,EAAU,SAAUC,EAAIC,EAAG,CAAE,OAAOA,CAAG,EAAGC,EAAU,SAAUF,EAAIG,EAAK,CAC/3B,OAAIH,EAAG,MACHG,EAAI,QAAQH,CAAE,EAEXG,CACX,EAAGC,EAAU,IAAKC,GAAU5B,EAAuB,IAAK,EAAK,EAAG6B,GAAU,IAAKC,GAAU9B,EAAuB,IAAK,EAAK,EAAG+B,GAAU,SAAU3B,EAAMC,EAAMC,EAAS,CAAE,MAAO,CAAE,KAAAF,EAAM,KAAAC,EAAM,QAAAC,CAAO,CAAI,EAAG0B,GAAU,IAAKC,GAAUjC,EAAuB,IAAK,EAAK,EAAGkC,GAAU,IAAKC,GAAUnC,EAAuB,IAAK,EAAK,EAAGoC,GAAU,SAAUhC,EAAMiC,EAAMhC,EAAMC,EAAS,CAAE,MAAO,CAAE,KAAAF,EAAM,KAAAiC,EAAM,KAAAhC,EAAM,QAAAC,EAAW,EAAGgC,GAAU,SAAUlC,EAAMmC,EAAMlC,EAAMC,EAAS,CAAE,MAAO,CAAE,KAAAF,EAAM,KAAAmC,EAAM,KAAAlC,EAAM,QAAAC,CAAO,CAAI,EAAGkC,GAAU,IAAKC,GAAUzC,EAAuB,IAAK,EAAK,EAAG0C,GAAU,SAAUnB,EAAIG,EAAK,CAC/kB,OAAAA,EAAI,QAAQH,CAAE,EACPG,CACX,EAAGiB,GAAU,MAAOC,GAAU5C,EAAuB,MAAO,EAAK,EAAG6C,GAAU,OAAQC,GAAU9C,EAAuB,OAAQ,EAAK,EAAG+C,GAAU,QAASC,GAAUhD,EAAuB,QAAS,EAAK,EAAGiD,GAAU,SAAUC,GAAUlD,EAAuB,SAAU,EAAK,EAAGmD,GAAU,OAAQC,GAAUpD,EAAuB,OAAQ,EAAK,EAAGqD,GAAU,QAASC,GAAUtD,EAAuB,QAAS,EAAK,EAAGuD,GAAU,QAASC,GAAUxD,EAAuB,QAAS,EAAK,EAAGyD,GAAU,OAAQC,GAAU1D,EAAuB,OAAQ,EAAK,EAAG2D,GAAU,SAAUC,GAAU5D,EAAuB,SAAU,EAAK,EAAG6D,GAAU,UAAWC,GAAU9D,EAAuB,UAAW,EAAK,EAAG+D,GAAU,OAAQC,GAAUhE,EAAuB,OAAQ,EAAK,EAAGiE,GAAU,SAAUC,GAAUlE,EAAuB,SAAU,EAAK,EAAGmE,GAAU,SAAUC,GAAUpE,EAAuB,SAAU,EAAK,EAAGqE,GAAU,MAAOC,GAAUtE,EAAuB,MAAO,EAAK,EAAGuE,GAAU,SAAUC,EAAGC,EAAG,CAAE,OAAOD,EAAI,IAAMC,CAAG,EAAGC,GAAU,aAAcC,GAAUC,EAAqB,CAAC,CAAC,IAAK,GAAG,EAAG,CAAC,IAAK,GAAG,EAAG,GAAG,EAAG,GAAO,EAAK,EAAGC,GAAU,gBAAiBC,GAAUF,EAAqB,CAAC,CAAC,IAAK,GAAG,EAAG,CAAC,IAAK,GAAG,EAAG,CAAC,IAAK,GAAG,EAAG,GAAG,EAAG,GAAO,EAAK,EAAGG,GAAU,SAAUP,EAAG,CAAE,OAAOQ,GAAI,CAAI,EAAyLC,GAAU,WAAYC,GAAUN,EAAqB,CAAC;AAAA,EAAM,IAAI,EAAG,GAAM,EAAK,EAAGO,GAAU,SAAUX,EAAG,CAAE,OAAOA,EAAE,KAAK,EAAE,EAAE,QAAQ,KAAM,EAAE,EAAE,QAAQ,KAAM,EAAE,CAAG,EAAGY,GAAUC,GAAqB,SAAS,EAAGC,GAAU,SAAUC,GAAUX,EAAqB,CAAC,CAAC,IAAK,GAAG,CAAC,EAAG,GAAO,EAAK,EAAGY,GAAU,UAAY,CAAE,OAAO,SAASR,GAAI,EAAI,EAAE,CAAG,EAAGS,GAAUJ,GAAqB,YAAY,EAAGK,GAAU,aAAcC,GAAUf,EAAqB,CAAC,IAAK,IAAM;AAAA,EAAM,IAAI,EAAG,GAAO,EAAK,EAAGgB,EAAc,EAAGC,EAAe,EAAGC,EAAsB,CAAC,CAAE,KAAM,EAAG,OAAQ,CAAC,CAAE,EAAGC,EAAiB,EAAGC,GAAsB,CAAA,EAAIC,EAAkB,EAAGC,EAC5iE,GAAI,cAAezG,EAAS,CACxB,GAAI,EAAEA,EAAQ,aAAaE,GACvB,MAAM,IAAI,MAAM,kCAAqCF,EAAQ,UAAY,IAAK,EAElFI,EAAwBF,EAAuBF,EAAQ,SAAS,CACpE,CACA,SAASuF,IAAO,CACZ,OAAOxF,EAAM,UAAUqG,EAAcD,CAAW,CACpD,CAYA,SAAS5F,EAAuBgF,EAAMmB,EAAY,CAC9C,MAAO,CAAE,KAAM,UAAW,KAAMnB,EAAM,WAAYmB,CAAU,CAChE,CACA,SAASvB,EAAqBwB,EAAOC,EAAUF,EAAY,CACvD,MAAO,CAAE,KAAM,QAAS,MAAOC,EAAO,SAAUC,EAAU,WAAYF,CAAU,CACpF,CAIA,SAASG,IAAqB,CAC1B,MAAO,CAAE,KAAM,KAAK,CACxB,CACA,SAASjB,GAAqBkB,EAAa,CACvC,MAAO,CAAE,KAAM,QAAS,YAAaA,CAAW,CACpD,CACA,SAASC,GAAsBC,EAAK,CAChC,IAAIC,EAAUZ,EAAoBW,CAAG,EAAGE,EACxC,GAAID,EACA,OAAOA,EAIP,IADAC,EAAIF,EAAM,EACH,CAACX,EAAoBa,CAAC,GACzBA,IAOJ,IALAD,EAAUZ,EAAoBa,CAAC,EAC/BD,EAAU,CACN,KAAMA,EAAQ,KACd,OAAQA,EAAQ,MAChC,EACmBC,EAAIF,GACHjH,EAAM,WAAWmH,CAAC,IAAM,IACxBD,EAAQ,OACRA,EAAQ,OAAS,GAGjBA,EAAQ,SAEZC,IAEJ,OAAAb,EAAoBW,CAAG,EAAIC,EACpBA,CAEf,CACA,SAASE,GAAoBC,EAAUC,EAAQ,CAC3C,IAAIC,EAAkBP,GAAsBK,CAAQ,EAAGG,EAAgBR,GAAsBM,CAAM,EACnG,MAAO,CACH,MAAO,CACH,OAAQD,EACR,KAAME,EAAgB,KACtB,OAAQA,EAAgB,MACxC,EACY,IAAK,CACD,OAAQD,EACR,KAAME,EAAc,KACpB,OAAQA,EAAc,MACtC,CACA,CACI,CACA,SAASC,EAAS3I,EAAU,CACpBsH,EAAcG,IAGdH,EAAcG,IACdA,EAAiBH,EACjBI,GAAsB,CAAA,GAE1BA,GAAoB,KAAK1H,CAAQ,EACrC,CAIA,SAAS4I,GAAyB5I,EAAUC,EAAOC,EAAU,CACzD,OAAO,IAAIJ,EAAgBA,EAAgB,aAAaE,EAAUC,CAAK,EAAGD,EAAUC,EAAOC,CAAQ,CACvG,CACA,SAASoB,IAAuB,CAC5B,IAAIuH,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAKC,EAAKC,EAAKC,EAC3D,OAAAb,EAAKvB,EACLwB,EAAKa,EAAU,EACXb,IAAO1H,GACP2H,EAAKa,GAAoB,EACrBb,IAAO3H,GACP4H,EAAKW,EAAU,EACXX,IAAO5H,GACP6H,EAAKY,GAAoB,EACrBZ,IAAO7H,GACP8H,EAAKS,EAAU,EACXT,IAAO9H,GACP+H,EAAKW,EAAgB,EACjBX,IAAO/H,GACPgI,EAAKO,EAAU,EACXP,IAAOhI,GACHF,EAAM,WAAWoG,CAAW,IAAM,IAClC+B,EAAK7H,EACL8F,MAGA+B,EAAKjI,EACDuG,IAAoB,GACpBgB,EAASlH,CAAM,GAGnB4H,IAAOjI,GACPkI,EAAKK,EAAU,EACXL,IAAOlI,GACPmI,EAAMQ,GAAkB,EACpBR,IAAQnI,GACRoI,EAAMG,EAAU,EACZH,IAAQpI,GACJF,EAAM,WAAWoG,CAAW,IAAM,IAClCmC,EAAM9H,EACN2F,MAGAmC,EAAMrI,EACFuG,IAAoB,GACpBgB,EAAS/G,CAAM,GAGnB6H,IAAQrI,GACRsI,EAAMC,EAAU,EACZD,IAAQtI,GACRmG,EAAesB,EACfC,EAAKjH,EAAOkH,EAAIE,EAAIE,EAAII,CAAG,EAC3BV,EAAKC,IAGLxB,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,GAEFyH,CACX,CACA,SAASe,IAAuB,CAC5B,IAAIf,EACJ,OAAI3H,EAAM,OAAOoG,EAAa,CAAC,IAAMpF,GACjC2G,EAAK3G,EACLoF,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAASxG,CAAM,GAGnB0G,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAMlF,GACjCyG,EAAKzG,EACLkF,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAAStG,CAAM,GAGnBwG,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAMhF,GACjCuG,EAAKvG,EACLgF,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAASpG,CAAO,KAKzBsG,CACX,CACA,SAASgB,IAAuB,CAC5B,IAAIhB,EAAIC,EAAIC,EAAIC,EAChB,OAAAH,EAAKmB,EAAa,EACdnB,IAAOzH,IACPyH,EAAKvB,EACLwB,EAAKkB,EAAa,EACdlB,IAAO1H,GACP2H,EAAKkB,GAAkB,EACnBlB,IAAO3H,GACP0H,EAAK,CAACA,EAAIC,CAAE,EACZF,EAAKC,IAGLxB,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,GAELyH,IAAOzH,IACPyH,EAAKvB,EACLwB,EAAKkB,EAAa,EACdlB,IAAO1H,GACHF,EAAM,OAAOoG,EAAa,CAAC,IAAM9E,GACjCuG,EAAKvG,EACL8E,GAAe,IAGfyB,EAAK3H,EACDuG,IAAoB,GACpBgB,EAASlG,CAAO,GAGpBsG,IAAO3H,GACP0H,EAAK,CAACA,EAAIC,CAAE,EACZF,EAAKC,IAGLxB,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,GAELyH,IAAOzH,IACPyH,EAAKvB,EACLwB,EAAKkB,EAAa,EACdlB,IAAO1H,GACP2H,EAAKkB,GAAkB,EACnBlB,IAAO3H,GACHF,EAAM,OAAOoG,EAAa,CAAC,IAAM9E,GACjCwG,EAAKxG,EACL8E,GAAe,IAGf0B,EAAK5H,EACDuG,IAAoB,GACpBgB,EAASlG,CAAO,GAGpBuG,IAAO5H,GACP0H,EAAK,CAACA,EAAIC,EAAIC,CAAE,EAChBH,EAAKC,IAGLxB,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,MAKdyH,CACX,CACA,SAASoB,IAAqB,CAC1B,IAAIpB,EACJ,OAAI3H,EAAM,OAAOoG,EAAa,CAAC,IAAM5E,GACjCmG,EAAKnG,EACL4E,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAAShG,CAAO,GAGpBkG,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAM1E,GACjCiG,EAAKjG,EACL0E,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAAS9F,CAAO,GAGpBgG,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAMxE,GACjC+F,EAAK/F,EACLwE,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAAS5F,CAAO,KAKzB8F,CACX,CACA,SAASiB,GAAmB,CACxB,IAAIjB,EACJ,OAAAA,EAAKqB,GAAwB,EACzBrB,IAAOzH,IACPyH,EAAKc,EAAU,GAEZd,CACX,CACA,SAASkB,IAAqB,CAC1B,IAAIlB,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAG5B,GAFAN,EAAKvB,EACLwB,EAAKqB,GAAc,EACfrB,IAAO1H,EAEP,GADA2H,EAAKY,EAAU,EACXZ,IAAO3H,EAAY,CAoBnB,IAnBA4H,EAAK,CAAA,EACLC,EAAK3B,EACL4B,EAAKS,EAAU,EACXT,IAAO9H,GACP+H,EAAKgB,GAAc,EACfhB,IAAO/H,GACPmG,EAAe0B,EACfC,EAAKlG,EAAQ8F,EAAIK,CAAE,EACnBF,EAAKC,IAGL5B,EAAc2B,EACdA,EAAK7H,KAITkG,EAAc2B,EACdA,EAAK7H,GAEF6H,IAAO7H,GACV4H,EAAG,KAAKC,CAAE,EACVA,EAAK3B,EACL4B,EAAKS,EAAU,EACXT,IAAO9H,GACP+H,EAAKgB,GAAc,EACfhB,IAAO/H,GACPmG,EAAe0B,EACfC,EAAKlG,EAAQ8F,EAAIK,CAAE,EACnBF,EAAKC,IAGL5B,EAAc2B,EACdA,EAAK7H,KAITkG,EAAc2B,EACdA,EAAK7H,GAGT4H,IAAO5H,GACP6H,EAAKU,EAAU,EACXV,IAAO7H,GACPmG,EAAesB,EACfC,EAAK3F,EAAQ2F,EAAIE,CAAE,EACnBH,EAAKC,IAGLxB,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,EAEb,MAEIkG,EAAcuB,EACdA,EAAKzH,OAITkG,EAAcuB,EACdA,EAAKzH,EAET,OAAOyH,CACX,CACA,SAASuB,IAAwB,CAC7B,IAAIvB,EACJ,OAAI3H,EAAM,WAAWoG,CAAW,IAAM,IAClCuB,EAAKxF,EACLiE,MAGAuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAASrF,EAAO,GAGjBuF,CACX,CACA,SAASwB,IAA2B,CAChC,IAAIxB,EAAIC,EAAIC,EAAIC,EAAIC,EACpB,OAAAJ,EAAKvB,EACLwB,EAAKa,EAAU,EACXb,IAAO1H,GACP2H,EAAKqB,GAAqB,EACtBrB,IAAO3H,GACP4H,EAAKkB,GAAwB,EACzBlB,IAAO5H,GACP6H,EAAKU,EAAU,EACXV,IAAO7H,GACP0H,EAAK,CAACA,EAAIC,EAAIC,EAAIC,CAAE,EACpBJ,EAAKC,IAGLxB,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,GAEFyH,CACX,CACA,SAASsB,IAAiB,CACtB,IAAItB,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAKC,EAAKC,EAAKC,EAC3D,OAAAb,EAAKvB,EACLwB,EAAKwB,GAAkB,EACnBxB,IAAO1H,GACP2H,EAAKY,EAAU,EACXZ,IAAO3H,GACP4H,EAAKgB,EAAa,EACdhB,IAAO5H,GACP6H,EAAKU,EAAU,EACXV,IAAO7H,GACHF,EAAM,WAAWoG,CAAW,IAAM,IAClC4B,EAAK3F,GACL+D,MAGA4B,EAAK9H,EACDuG,IAAoB,GACpBgB,EAASnF,EAAO,GAGpB0F,IAAO9H,GACP+H,EAAKQ,EAAU,EACXR,IAAO/H,GACPgI,EAAKU,EAAgB,EACjBV,IAAOhI,GACPmG,EAAesB,EACfC,EAAKrF,GAAQqF,EAAIE,EAAII,CAAE,EACvBP,EAAKC,IAGLxB,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,GAELyH,IAAOzH,IACPyH,EAAKvB,EACLwB,EAAKwB,GAAkB,EACnBxB,IAAO1H,GACP2H,EAAKY,EAAU,EACXZ,IAAO3H,GACHF,EAAM,WAAWoG,CAAW,IAAM,IAClC0B,EAAKtF,GACL4D,MAGA0B,EAAK5H,EACDuG,IAAoB,GACpBgB,EAAShF,EAAO,GAGpBqF,IAAO5H,GACP6H,EAAKU,EAAU,EACXV,IAAO7H,GACP8H,EAAKqB,GAAkB,EACnBrB,IAAO9H,GACP+H,EAAKQ,EAAU,EACXR,IAAO/H,GACHF,EAAM,WAAWoG,CAAW,IAAM,IAClC8B,EAAKxF,GACL0D,MAGA8B,EAAKhI,EACDuG,IAAoB,GACpBgB,EAAS9E,EAAO,GAGpBuF,IAAOhI,GACPiI,EAAKM,EAAU,EACXN,IAAOjI,GACPkI,EAAKU,EAAa,EACdV,IAAOlI,GACPmI,EAAMI,EAAU,EACZJ,IAAQnI,GACJF,EAAM,WAAWoG,CAAW,IAAM,IAClCkC,EAAMjG,GACN+D,MAGAkC,EAAMpI,EACFuG,IAAoB,GACpBgB,EAASnF,EAAO,GAGpBgG,IAAQpI,GACRqI,EAAME,EAAU,EACZF,IAAQrI,GACRsI,EAAMI,EAAgB,EAClBJ,IAAQtI,GACRmG,EAAesB,EACfC,EAAKhF,GAAQgF,EAAII,EAAII,EAAII,CAAG,EAC5Bb,EAAKC,IAGLxB,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,GAELyH,IAAOzH,IACPyH,EAAKvB,EACLwB,EAAKwB,GAAkB,EACnBxB,IAAO1H,GACP2H,EAAKY,EAAU,EACXZ,IAAO3H,GACHF,EAAM,WAAWoG,CAAW,IAAM,IAClC0B,EAAKxH,EACL8F,MAGA0B,EAAK5H,EACDuG,IAAoB,GACpBgB,EAASlH,CAAM,GAGnBuH,IAAO5H,GACP6H,EAAKU,EAAU,EACXV,IAAO7H,GACP8H,EAAKsB,GAAoB,EACrBtB,IAAO9H,GACP+H,EAAKQ,EAAU,EACXR,IAAO/H,GACHF,EAAM,WAAWoG,CAAW,IAAM,IAClC8B,EAAKzH,EACL2F,MAGA8B,EAAKhI,EACDuG,IAAoB,GACpBgB,EAAS/G,CAAM,GAGnBwH,IAAOhI,GACPiI,EAAKM,EAAU,EACXN,IAAOjI,GACPkI,EAAKU,EAAa,EACdV,IAAOlI,GACPmI,EAAMI,EAAU,EACZJ,IAAQnI,GACJF,EAAM,WAAWoG,CAAW,IAAM,IAClCkC,EAAMjG,GACN+D,MAGAkC,EAAMpI,EACFuG,IAAoB,GACpBgB,EAASnF,EAAO,GAGpBgG,IAAQpI,GACRqI,EAAME,EAAU,EACZF,IAAQrI,GACRsI,EAAMI,EAAgB,EAClBJ,IAAQtI,GACRmG,EAAesB,EACfC,EAAK9E,GAAQ8E,EAAII,EAAII,EAAII,CAAG,EAC5Bb,EAAKC,IAGLxB,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,GAELyH,IAAOzH,IACPyH,EAAKwB,GAAwB,KAIlCxB,CACX,CACA,SAAS2B,IAAuB,CAC5B,IAAI3B,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAG5B,GAFAN,EAAKvB,EACLwB,EAAKkB,EAAa,EACdlB,IAAO1H,EAAY,CAoCnB,IAnCA2H,EAAK,CAAA,EACLC,EAAK1B,EACDpG,EAAM,WAAWoG,CAAW,IAAM,IAClC2B,EAAK/E,GACLoD,MAGA2B,EAAK7H,EACDuG,IAAoB,GACpBgB,EAASxE,EAAO,GAGpB8E,IAAO7H,GACP8H,EAAKS,EAAU,EACXT,IAAO9H,GACP+H,EAAKa,EAAa,EACdb,IAAO/H,GACPmG,EAAeyB,EACfC,EAAKjG,EAAQ8F,EAAIK,CAAE,EACnBH,EAAKC,IAGL3B,EAAc0B,EACdA,EAAK5H,KAITkG,EAAc0B,EACdA,EAAK5H,KAITkG,EAAc0B,EACdA,EAAK5H,GAEF4H,IAAO5H,GACV2H,EAAG,KAAKC,CAAE,EACVA,EAAK1B,EACDpG,EAAM,WAAWoG,CAAW,IAAM,IAClC2B,EAAK/E,GACLoD,MAGA2B,EAAK7H,EACDuG,IAAoB,GACpBgB,EAASxE,EAAO,GAGpB8E,IAAO7H,GACP8H,EAAKS,EAAU,EACXT,IAAO9H,GACP+H,EAAKa,EAAa,EACdb,IAAO/H,GACPmG,EAAeyB,EACfC,EAAKjG,EAAQ8F,EAAIK,CAAE,EACnBH,EAAKC,IAGL3B,EAAc0B,EACdA,EAAK5H,KAITkG,EAAc0B,EACdA,EAAK5H,KAITkG,EAAc0B,EACdA,EAAK5H,GAGT2H,IAAO3H,GACPmG,EAAesB,EACfC,EAAK1E,GAAQ0E,EAAIC,CAAE,EACnBF,EAAKC,IAGLxB,EAAcuB,EACdA,EAAKzH,EAEb,MAEIkG,EAAcuB,EACdA,EAAKzH,EAET,OAAOyH,CACX,CACA,SAASyB,IAAqB,CAC1B,IAAIzB,EAAIC,EAAIC,EAAIC,EAChB,OAAI9H,EAAM,OAAOoG,EAAa,CAAC,IAAMjD,IACjCwE,EAAKxE,GACLiD,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAASrE,EAAO,GAGpBuE,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAM/C,IACjCsE,EAAKtE,GACL+C,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAASnE,EAAO,GAGpBqE,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAM7C,IACjCoE,EAAKpE,GACL6C,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAASjE,EAAO,GAGpBmE,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAM3C,IACjCkE,EAAKlE,GACL2C,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAAS/D,EAAO,GAGpBiE,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAMzC,IACjCgE,EAAKhE,GACLyC,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAAS7D,EAAO,GAGpB+D,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAMvC,IACjC8D,EAAK9D,GACLuC,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAAS3D,EAAO,GAGpB6D,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAMrC,IACjC4D,EAAK5D,GACLqC,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAASzD,EAAO,GAGpB2D,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAMnC,IACjC0D,EAAK1D,GACLmC,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAASvD,EAAO,GAGpByD,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAMjC,IACjCwD,EAAKxD,GACLiC,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAASrD,EAAO,GAGpBuD,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAM/B,IACjCsD,EAAKtD,GACL+B,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAASnD,EAAO,GAGpBqD,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAM7B,IACjCoD,EAAKpD,GACL6B,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAASjD,EAAO,GAGpBmD,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAM3B,IACjCkD,EAAKlD,GACL2B,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAAS/C,EAAO,GAGpBiD,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAMzB,IACjCgD,EAAKhD,GACLyB,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAAS7C,EAAO,GAGpB+C,IAAOzH,IACHF,EAAM,OAAOoG,EAAa,CAAC,IAAMvB,IACjC8C,EAAK9C,GACLuB,GAAe,IAGfuB,EAAKzH,EACDuG,IAAoB,GACpBgB,EAAS3C,EAAO,GAGpB6C,IAAOzH,IACPyH,EAAKvB,EACLwB,EAAKc,GAAoB,EACrBd,IAAO1H,GACP2H,EAAKY,EAAU,EACXZ,IAAO3H,GACP4H,EAAKa,GAAoB,EACrBb,IAAO5H,GACPmG,EAAesB,EACfC,EAAK7C,GAAQ6C,EAAIE,CAAE,EACnBH,EAAKC,IAGLxB,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,KAITkG,EAAcuB,EACdA,EAAKzH,iBAgB1DyH,CACX,CACA,SAAS0B,IAAqB,CAC1B,IAAI1B,EACJ,OAAAA,EAAK4B,GAAe,EAChB5B,IAAOzH,IACPyH,EAAKmB,EAAa,GAEfnB,CACX,CACA,SAASmB,GAAgB,CACrB,IAAInB,EAAIC,EAAIC,EAAIC,EAAIC,EAapB,GAZAJ,EAAKvB,EACLwB,EAAKxB,EACDlB,GAAQ,KAAKlF,EAAM,OAAOoG,CAAW,CAAC,GACtCyB,EAAK7H,EAAM,OAAOoG,CAAW,EAC7BA,MAGAyB,EAAK3H,EACDuG,IAAoB,GACpBgB,EAAStC,EAAO,GAGpB0C,IAAO3H,EAAY,CAYnB,IAXA4H,EAAK,CAAA,EACDzC,GAAQ,KAAKrF,EAAM,OAAOoG,CAAW,CAAC,GACtC2B,EAAK/H,EAAM,OAAOoG,CAAW,EAC7BA,MAGA2B,EAAK7H,EACDuG,IAAoB,GACpBgB,EAASnC,EAAO,GAGjByC,IAAO7H,GACV4H,EAAG,KAAKC,CAAE,EACN1C,GAAQ,KAAKrF,EAAM,OAAOoG,CAAW,CAAC,GACtC2B,EAAK/H,EAAM,OAAOoG,CAAW,EAC7BA,MAGA2B,EAAK7H,EACDuG,IAAoB,GACpBgB,EAASnC,EAAO,GAIxBwC,IAAO5H,GACP2H,EAAK,CAACA,EAAIC,CAAE,EACZF,EAAKC,IAGLzB,EAAcwB,EACdA,EAAK1H,EAEb,MAEIkG,EAAcwB,EACdA,EAAK1H,EAET,OAAI0H,IAAO1H,IACPmG,EAAesB,EACfC,EAAKrC,GAAU,GAEnBoC,EAAKC,EACED,CACX,CAuEA,SAASqB,IAA2B,CAChC,IAAIrB,EAAIC,EAAIC,EAaZ,IAZAF,EAAKvB,EACLwB,EAAK,CAAA,EACDnC,GAAQ,KAAKzF,EAAM,OAAOoG,CAAW,CAAC,GACtCyB,EAAK7H,EAAM,OAAOoG,CAAW,EAC7BA,MAGAyB,EAAK3H,EACDuG,IAAoB,GACpBgB,EAAS/B,EAAO,GAGjBmC,IAAO3H,GACV0H,EAAG,KAAKC,CAAE,EACNpC,GAAQ,KAAKzF,EAAM,OAAOoG,CAAW,CAAC,GACtCyB,EAAK7H,EAAM,OAAOoG,CAAW,EAC7BA,MAGAyB,EAAK3H,EACDuG,IAAoB,GACpBgB,EAAS/B,EAAO,GAI5B,OAAIkC,IAAO1H,IACPmG,EAAesB,EACfC,EAAKjC,GAAQiC,CAAE,GAEnBD,EAAKC,EACED,CACX,CACA,SAAS4B,IAAkB,CACvB,IAAI5B,EAAIC,EAAIC,EAAIC,EAIhB,GAHArB,IACAkB,EAAKvB,EACLwB,EAAKa,EAAU,EACXb,IAAO1H,EAAY,CAYnB,GAXA2H,EAAK,CAAA,EACD/B,GAAQ,KAAK9F,EAAM,OAAOoG,CAAW,CAAC,GACtC0B,EAAK9H,EAAM,OAAOoG,CAAW,EAC7BA,MAGA0B,EAAK5H,EACDuG,IAAoB,GACpBgB,EAAS1B,EAAO,GAGpB+B,IAAO5H,EACP,KAAO4H,IAAO5H,GACV2H,EAAG,KAAKC,CAAE,EACNhC,GAAQ,KAAK9F,EAAM,OAAOoG,CAAW,CAAC,GACtC0B,EAAK9H,EAAM,OAAOoG,CAAW,EAC7BA,MAGA0B,EAAK5H,EACDuG,IAAoB,GACpBgB,EAAS1B,EAAO,QAM5B8B,EAAK3H,EAEL2H,IAAO3H,GACPmG,EAAesB,EACfC,EAAK5B,GAAO,EACZ2B,EAAKC,IAGLxB,EAAcuB,EACdA,EAAKzH,EAEb,MAEIkG,EAAcuB,EACdA,EAAKzH,EAET,OAAAuG,IACIkB,IAAOzH,IACP0H,EAAK1H,EACDuG,IAAoB,GACpBgB,EAAS7B,EAAO,GAGjB+B,CACX,CACA,SAASc,GAAa,CAClB,IAAId,EAAIC,EAaR,IAZAnB,IACAkB,EAAK,CAAA,EACDzB,GAAQ,KAAKlG,EAAM,OAAOoG,CAAW,CAAC,GACtCwB,EAAK5H,EAAM,OAAOoG,CAAW,EAC7BA,MAGAwB,EAAK1H,EACDuG,IAAoB,GACpBgB,EAAStB,EAAO,GAGjByB,IAAO1H,GACVyH,EAAG,KAAKC,CAAE,EACN1B,GAAQ,KAAKlG,EAAM,OAAOoG,CAAW,CAAC,GACtCwB,EAAK5H,EAAM,OAAOoG,CAAW,EAC7BA,MAGAwB,EAAK1H,EACDuG,IAAoB,GACpBgB,EAAStB,EAAO,GAI5B,OAAAM,IACIkB,IAAOzH,IACP0H,EAAK1H,EACDuG,IAAoB,GACpBgB,EAASxB,EAAO,GAGjB0B,CACX,CAEA,GADAjB,EAAarG,EAAqB,EAC9BqG,IAAexG,GAAckG,IAAgBpG,EAAM,OACnD,OAAO0G,EAGP,MAAIA,IAAexG,GAAckG,EAAcpG,EAAM,QACjDyH,EAASX,GAAkB,CAAE,EAE3BY,GAAyBlB,GAAqBD,EAAiBvG,EAAM,OAASA,EAAM,OAAOuG,CAAc,EAAI,KAAMA,EAAiBvG,EAAM,OAC1IoH,GAAoBb,EAAgBA,EAAiB,CAAC,EACtDa,GAAoBb,EAAgBA,CAAc,CAAC,CAEjE,CAEA,MAAAiD,GAAe,CAAE,YAAa5K,EAAiB,MAAOmB,EAAS,ECv+ClD0J,GAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAgBXC,GAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAwBdC,GAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAuBdC,GAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OASVC,GAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAQTC,GAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAchBC,GAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAiCTC,GAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAgBnBC,GAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAeZC,GAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8OC5J1BC,GAAe,OAAO,YAAY,OAAO,QAAQA,EAAK,EAAE,IAAI,CAAC,CAACC,EAAKC,CAAK,IAAM,CAC1ED,EACAZ,GAAO,MAAMa,EAAM,MAAM,CAC7B,CAAC,CAAC,ECGK,SAASC,GAAYC,EAAS,CACjC,MAAMC,EAAe,IAAI,IAAI,CAAC,OAAQ,MAAO,QAAS,MAAM,CAAC,EAC7D,MAAO,CACH,GAAGD,EACH,OAAQA,EAAQ,OACX,IAAIE,IAAc,CACnB,GAAGA,EACH,QAASA,EAAU,MAAQA,EAAU,OAAS,OAC9C,eAAgBA,EAAU,MAAQD,EAAa,IAAIC,EAAU,IAAI,EACjE,UAAW,CAACA,EAAU,MAAQD,EAAa,IAAIC,EAAU,IAAI,CACzE,EAAU,EAEG,OAAOC,GAAK,CAAC,CAACA,EAAE,IAAI,CACjC,CACA,CCnBA,MAAMC,GAAY,CAAE,IAAK,EAAG,IAAK,GAAI,IAAK,CAAC,EAG3C,SAASC,GAAY7J,EAAQ,CJN7B,IAAA8J,EIOI,OAAQ9J,EAAO,QAAU,IACrB,CAAC,OAAO,MAAM,OAAO,SAASA,EAAO,CAAC,EAAG,EAAE,CAAC,KAC5C8J,EAAA9J,EAAO,EAAE,IAAT,YAAA8J,EAAY,MAAM,KAAK,OAAOH,GAAK,CAAC,CAACA,GAAG,UACpC,OAAO,SAAS3J,EAAO,CAAC,EAAG,EAAE,CACzC,CACe,MAAM+J,EAAI,CAGrB,YAAYC,EAAa,GAAI,CAF7BC,GAAA,gBACAA,GAAA,0BAEI,GAAID,EAAW,QACX,KAAK,QAAUT,GAAYd,GAAO,MAAMuB,EAAW,OAAO,CAAC,UAEtDA,EAAW,KAAM,CAEtB,GAAI,CAACZ,GAAMY,EAAW,IAAI,EACtB,MAAM,IAAI,MAAM,gBAAgB,EAEpC,KAAK,QAAUT,GAAYH,GAAMY,EAAW,IAAI,CAAC,CACrD,MAEI,KAAK,QAAUT,GAAYH,GAAM,gBAAgB,EACjD,KAAK,kBAAoB,EAEjC,CAQA,UAAUc,EAAMhL,EAAU,GAAI,CAC1B,KAAM,CAAE,QAAAsK,CAAO,EAAK,KACd,CAAE,SAAAW,CAAQ,EAAKjL,EACfc,EAAS,MAAM,QAAQkK,CAAI,EAAIA,EAAOA,EAAK,MAAM,GAAI,EAC3D,IAAIE,EAAU,CAAA,EACd,GAAI,CAAC,KAAK,mBAEL,KAAK,mBAAqBP,GAAY7J,CAAM,EAC7C,QAASqK,EAAQ,EAAGA,EAAQb,EAAQ,OAAO,OAAQa,IAAS,CACxD,MAAMX,EAAYF,EAAQ,OAAOa,CAAK,EACtC,IAAIC,EAActK,EAAOqK,CAAK,EAC9B,KAAM,CAAE,UAAAE,EAAW,QAAAC,EAAS,eAAAC,EAAgB,KAAA3K,CAAI,EAAK4J,EACrD,GAAIY,GAAgB,KAChB,MAEJ,GAAIA,IAAgB,IAAK,CACrB,GAAIC,EAAW,CACX,MAAMG,EAAU,OAAOJ,CAAW,EAClCA,EAAc,OAAO,MAAMI,CAAO,EAAIJ,EAAcI,CACxD,MACSF,IACLF,EAAcA,EAAY,MAAM,GAAG,EAC/BA,EAAY,GAAG,EAAE,IAAM,IACvBA,EAAY,IAAG,EAEfG,IACAH,EAAcA,EAAY,IAAI,MAAM,IAG5CF,EAAQtK,CAAI,EAAIwK,CACpB,CACJ,KAEC,CACD,MAAMK,EAAa,CAAC,QAAS,aAAc,WAAY,MAAM,EAC7DP,EAAU,OAAO,YAAYpK,EAAO,IAAI,CAAC2J,EAAGU,IAAU,CAACM,EAAWN,CAAK,GAAK,QAAUA,EAAOV,CAAC,CAAC,CAAC,EAChGS,EAAQ,WAAa,CAACA,EAAQ,WAC9BA,EAAQ,SAAW,CAACA,EAAQ,SACvB,OAAO,MAAM,OAAO,WAAWA,EAAQ,MAAM,CAAC,IAC/CA,EAAQ,MAAQ,CAACA,EAAQ,OACzB,OAAOA,EAAQ,SAEfA,EAAQ,SAAW,KAAOA,EAAQ,SAAW,OAC7CA,EAAQ,OAASA,EAAQ,OACzB,OAAOA,EAAQ,OAEvB,CACA,OAAID,IACAC,EAAQ,SAAWD,GAEvBC,EAAQ,OAASR,GAAUQ,EAAQ,MAAM,GAAK,EAC9CA,EAAQ,MAAQ,mBAAmBA,EAAQ,KAAK,EACzCA,CACX,CACJ,CC5FO,SAASQ,GAAmB,CAAE,UAAAC,EAAW,MAAAC,EAAO,IAAAC,CAAG,EAAK,CAC3D,MAAQ,EAAEF,EAAU,CAAC,GAAK,KAAOC,GAC7B,EAAED,EAAU,CAAC,GAAK,KAAOE,GACzB,CAAC,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAE,EAAE,MAAMC,GAAKH,EAAUG,CAAC,GAAK,CAAC,OAAO,MAAM,CAACH,EAAUG,CAAC,CAAC,CAAC,CACnG,CACO,SAASC,GAAyB,CAAE,UAAAJ,EAAW,SAAAV,EAAU,QAAAe,EAAS,MAAAJ,EAAO,IAAAC,GAAQ,CACpF,KAAM,CAAA,CAAA,CAAA,CAAOI,EAAI,CAAIC,EAAM,CAAA,CAAMC,EAAOC,EAAaC,EAAmBC,EAAOC,EAAaC,EAAaC,EAAUC,EAAQC,EAAQC,CAAQ,EAAKjB,EAChJ,MAAO,CACH,SAAAV,EACA,QAAAe,EACA,MAAAJ,EACA,IAAAC,EACA,KAAAI,EACA,MAAO,CAACI,GAAqB,EAC7B,OAAAH,EACA,MAAAC,EACA,OAAQF,EACR,YAAAG,EACA,kBAAAC,EACA,MAAAC,EACA,YAAAC,EACA,YAAAC,EACA,SAAAC,EACA,OAAAC,EACA,OAAAC,EACA,SAAAC,CACR,CACA,CC3BO,SAASC,GAA+BC,EAAM,CACjD,MAAMC,EAAMD,GAAS,KAA0B,OAASA,EAAK,OAAO,MAAM,GAAG,EAC7E,MAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAAE,MAAMtN,IAAMuN,GAAQ,KAAyB,OAASA,EAAIvN,CAAC,KAAO,OAAY,CAAC,OAAO,MAAM,CAACuN,EAAIvN,CAAC,CAAC,EAAI,EAAK,CAC1I,CACA,SAASwN,GAA2BlG,EAAa,CAC7C,GAAI+F,GAA+B/F,CAAW,EAAG,CAC7C,KAAM,CAACmG,EAAaC,EAAaC,EAAaC,EAAaC,EAAWC,EAAaC,EAAWC,EAAiBC,EAAaC,EAAsBC,EAAuBC,EAAuBC,EAAqBC,EAA2BC,GAAcjH,EAAY,KAAI,EAAG,MAAM,GAAG,EAC1R,MAAO,CACH,YAAAmG,EACA,YAAAC,EACA,YAAAC,EACA,YAAAC,EACA,UAAAC,EACA,YAAAC,EACA,UAAAC,EACA,gBAAAC,EACA,YAAAC,EACA,qBAAAC,EACA,sBAAAC,EACA,sBAAAC,EACA,oBAAAC,EACA,0BAAAC,EACA,UAAAC,CACZ,CACI,CACA,MAAO,CAAE,YAAAjH,CAAW,CACxB,CACO,SAASkH,GAA4B,CAAE,SAAA/C,EAAU,QAAAe,EAAS,MAAAJ,EAAO,IAAAC,EAAK,YAAA/E,EAAa,GAAGmH,GAAQ,CACjG,KAAM,CAAE,YAAAC,EAAa,GAAGC,CAAK,EAAKF,EAClC,MAAO,CACH,GAAGE,EACH,GAAGnB,GAA2BlG,CAAW,EACzC,SAAAmE,EACA,QAAAe,EACA,MAAAJ,EACA,IAAAC,CACR,CACA,CCrCO,SAASuC,GAAiB,CAAE,WAAAC,EAAY,WAAAC,EAAY,OAAApC,CAAM,EAAK,CAClE,OAAOmC,GAAcC,GAAcpC,IAAW,CAClD,CACO,SAASqC,GAAuBC,EAAM,CACzC,KAAM,CAAE,OAAAtC,EAAS,EAAG,MAAOuC,EAAI,WAAYC,EAAI,SAAUC,EAAI,YAAAC,EAAa,YAAAC,EAAa,WAAAC,EAAY,SAAA7D,EAAU,GAAGgD,CAAI,EAAKO,EACnH,CAAE,YAAaO,EAAgB,WAAAV,EAAY,SAAAW,EAAU,WAAAV,EAAY,QAAAtC,EAAS,GAAGmC,CAAK,EAAKF,EACvFC,EAAc,CAAA,EACde,EAAQF,EACT,OAAOvQ,GAASA,EAAM,OAAS,OAAO,EACtC,KAAK,CAAC0Q,EAAGC,IAAMD,EAAE,MAAQC,EAAE,KAAK,EAC/B,CAAE,WAAAC,EAAY,aAAAC,CAAY,EAAKlB,EACrC,GAAIkB,IAAiB,QAAUD,IAAe,OAC1C,MAAO,CACH,GAAGjB,EACH,SAAAlD,EACA,OAAAiB,EACA,KAAM,aACN,QAAAF,EACA,YAAaiD,EAAM,IAAIK,IAAM,CACzB,GAAGA,EACH,KAAM,MACtB,EAAc,CACd,EAGQ,UAAWC,KAASN,EAAO,CACvB,MAAMrD,EAAQ2D,EAAM,MACd1D,EAAM0D,EAAM,IACdlB,GAAcxC,EACdqC,EAAY,KAAK,CACb,KAAM,GAAGhC,EAAS,EAAI,OAAS,OAAO,aACtC,MAAAN,EACA,IAAAC,EACA,QAAAG,CACpB,CAAiB,EAEIqC,EAAazC,GAASyC,EAAaxC,GAAOmD,GAAYnD,EAC3DqC,EAAY,KAAK,CACb,KAAM,GAAGhC,EAAS,EAAI,OAAS,OAAO,aACtC,MAAAN,EACA,IAAKyC,EACL,QAAArC,CACpB,EAAmB,CACC,KAAM,MACN,MAAO,EACP,MAAOqC,EACP,IAAAxC,EACA,QAAAG,CACpB,CAAiB,EAEIqC,GAAczC,GAASoD,GAAYnD,EACxCqC,EAAY,KAAK,CACb,KAAM,MACN,MAAO,EACP,MAAAtC,EACA,IAAAC,EACA,QAAAG,CACpB,CAAiB,EAEIqC,EAAazC,GAASyC,EAAaxC,GAAOmD,EAAWnD,EAC1DqC,EAAY,KAAK,CACb,KAAM,GAAGhC,EAAS,EAAI,OAAS,OAAO,aACtC,MAAAN,EACA,IAAKyC,EACL,QAAArC,CACpB,EAAmB,CACC,KAAM,MACN,MAAO,EACP,MAAOqC,EACP,IAAKW,EACL,QAAAhD,CACpB,EAAmB,CACC,KAAM,GAAGE,EAAS,EAAI,QAAU,MAAM,aACtC,MAAO8C,EACP,IAAAnD,EACA,QAAAG,CACpB,CAAiB,EAEIqC,GAAczC,GAASoD,EAAWpD,GAASoD,EAAWnD,EAC3DqC,EAAY,KAAK,CACb,KAAM,MACN,MAAO,EACP,MAAAtC,EACA,IAAKoD,EACL,QAAAhD,CACpB,EAAmB,CACC,KAAM,GAAGE,EAAS,EAAI,QAAU,MAAM,aACtC,MAAO8C,EACP,IAAAnD,EACA,QAAAG,CACpB,CAAiB,EAEIgD,GAAYpD,GACjBsC,EAAY,KAAK,CACb,KAAM,GAAGhC,EAAS,EAAI,QAAU,MAAM,aACtC,MAAAN,EACA,IAAAC,EACA,QAAAG,CACpB,CAAiB,CAET,CACA,MAAO,CACH,GAAGmC,EACH,SAAAlD,EACA,OAAAiB,EACA,KAAM,OACN,QAAAF,EACA,YAAAkC,CACZ,CAUA,CCnHA,SAASsB,GAAc1O,EAAQ6K,EAAW,CACtC,IAAI8D,EAAgB,GACpB,MAAM3D,EAAI,CAAA,EACV,QAAS1M,EAAI,EAAGA,EAAIuM,EAAU,OAAQvM,IAC9B0B,EAAO1B,CAAC,IAAM,eACdqQ,EAAgB,IAEpB3D,EAAE,KAAK,CAAChL,EAAO1B,CAAC,EAAGuM,EAAUvM,CAAC,CAAC,CAAC,EAEpC,MAAMsQ,EAAM,OAAO,YAAY5D,CAAC,EAChC,GAAI2D,EAAe,CACf,KAAM,CAAE,YAAAZ,EAAa,WAAAP,EAAY,YAAAM,EAAa,SAAAI,EAAU,WAAAX,EAAY,WAAAS,EAAY,GAAGb,CAAI,EAAKyB,EAC5F,MAAO,CACH,GAAGzB,EACH,YAAa0B,GAASd,CAAW,EACjC,YAAac,GAASf,CAAW,EACjC,WAAYe,GAASb,CAAU,EAC/B,WAAYT,EAAa,CAACA,EAAa,OACvC,SAAUW,EAAW,CAACA,EAAW,OACjC,WAAYV,EAAa,CAACA,EAAa,MACnD,CACI,KAEI,QAAOoB,CAEf,CACO,SAASE,GAAW,CAAE,MAAAhE,EAAO,SAAAX,EAAU,QAAAe,EAAS,YAAA4C,EAAa,WAAAN,EAAY,WAAAQ,EAAY,YAAAD,GAAgB,CACxG,MAAMX,EAAc,CAAA,EACd2B,EAASjB,GAAeC,GAAe,CAAA,EAC7C,QAASM,EAAI,EAAGA,EAAIb,EAAYa,IAAK,CACjC,MAAMW,GAAQD,EAAOV,CAAC,GAAK,GAAKvD,EAC1BmE,EAAQjB,GAAe,KAAgC,OAASA,EAAWK,CAAC,EAClF,GAAIY,GAASA,EAAQ,EAAG,CACpB,MAAMC,EAAOF,EAAOC,EACpB7B,EAAY,KAAK,CACb,SAAU,GAAGjD,CAAQ,IAAIkE,CAAC,GAC1B,MAAOW,EACP,IAAKE,EACL,QAAAhE,EACA,KAAM,OACtB,CAAa,CACL,CACJ,CACA,OAAOkC,CACX,CACO,SAAS+B,GAAY,CAAE,KAAAjF,EAAM,OAAAkF,EAAQ,SAAAC,EAAU,OAAAC,EAAQ,YAAAC,EAAa,OAAA9G,EAAQ,SAAA0B,EAAU,MAAAqF,GAAU,CACnG,MAAM3E,EAAYX,EAAK,MAAM,GAAI,EAC3BgB,EAAUL,EAAUuE,CAAM,EAC1BtE,EAAQ,OAAO,SAASD,EAAUwE,CAAQ,EAAG,EAAE,EAC/CtE,EAAM,OAAO,SAASF,EAAUyE,CAAM,EAAG,EAAE,GAAKD,IAAaC,EAAS,EAAI,GAChF,OAAOG,GAAa,CAChB,UAAA5E,EACA,QAAAK,EACA,MAAAJ,EACA,IAAAC,EACA,OAAAtC,EACA,SAAA0B,EACA,YAAAoF,EACA,MAAAC,CACR,CAAK,CACL,CACO,SAASC,GAAa,CAAE,UAAA5E,EAAW,QAAAK,EAAS,MAAAJ,EAAO,IAAAC,EAAK,OAAAtC,EAAQ,SAAA0B,EAAU,YAAAoF,EAAa,MAAAC,GAAU,CACpG,MAAM9B,EAAO8B,EACPd,GAAcc,EAAO3E,CAAS,EAC9BpC,EAAO,UAAUoC,EAAW,CAAE,SAAAV,CAAQ,CAAE,EACxC,CAAE,OAAQuF,EAAS,MAAOC,EAAQ,MAAOhC,EAAI,WAAYC,EAAI,SAAUC,EAAI,GAAGV,CAAI,EAAKO,EACvFkC,EAAQL,EAAc,CAAC7B,EAAK6B,CAAW,EAAII,EAAS,CAACA,EAAS,OAC9DvE,EAAS,OAAOsE,GAAY,SAAYA,IAAY,IAAM,GAAK,EAAKA,EACpEtC,EAAcD,EAAK,WACnB2B,GAAW,CACT,MAAAhE,EACA,SAAAX,EACA,QAAAe,EACA,YAAaiC,EAAK,YAClB,WAAYA,EAAK,WACjB,WAAYA,EAAK,WACjB,YAAaA,EAAK,WAC9B,CAAS,EACC,OACN,GAAIvC,GAAmB,CAAE,UAAAC,EAAW,MAAAC,EAAO,IAAAC,CAAG,CAAE,EAC5C,OAAOE,GAAyB,CAC5B,UAAAJ,EACA,SAAAV,EACA,QAAAe,EACA,MAAAJ,EACA,IAAAC,CACZ,CAAS,EAEA,GAAIgB,GAA+BoB,EAAK,WAAW,EAAG,CACvD,KAAM,CAAE,YAAAW,EAAa,WAAAE,EAAY,YAAAD,EAAa,KAAAlO,EAAM,WAAA2N,EAAY,WAAAD,EAAY,SAAAW,EAAU,YAAAlI,EAAa,GAAGqH,CAAK,EAAKF,EAChH,OAAOD,GAA4B,CAC/B,GAAGG,EACH,SAAAlD,EACA,YAAAnE,EACA,KAAAnG,EACA,MAAA+P,EACA,MAAA9E,EACA,IAAAC,EACA,OAAAK,EACA,QAAAF,EACA,YAAAkC,CACZ,CAAS,CACL,SACSA,GACLE,GAAiB,CACb,OAAAlC,EACA,WAAY+B,EAAK,WACjB,WAAYA,EAAK,UAC7B,CAAS,EAAG,CACJ,KAAM,CAAE,YAAAW,EAAa,WAAAE,EAAY,KAAAnO,EAAM,WAAA2N,EAAY,WAAAD,EAAY,SAAAW,EAAU,YAAAlI,CAAW,EAAMmH,EAC1F,OAAOM,GAAuB,CAC1B,GAAGN,EACH,YAAAnH,EACA,YAAA8H,EACA,WAAAP,EACA,SAAAW,EACA,WAAAF,EACA,WAAAR,EACA,KAAA3N,EACA,MAAA+P,EACA,MAAA9E,EACA,IAAAC,EACA,OAAAK,EACA,QAAAF,EACA,SAAAf,EACA,YAAAiD,CACZ,CAAS,CACL,KAEI,OAAO,CACH,GAAGD,EACH,SAAAhD,EACA,MAAAyF,EACA,MAAA9E,EACA,IAAAC,EACA,OAAAK,EACA,QAAAF,EACA,YAAAkC,CACZ,CAEA,CACO,SAASyB,GAASlF,EAAG,CACxB,OAAOA,IAAM,OACP,OAAOA,GAAM,SACTA,EAAE,MAAM,GAAG,EAAE,IAAIA,GAAK,CAACA,CAAC,EACxBA,EACJ,MACV","x_google_ignoreList":[0,1,2,3,4,5,6,7,8]}