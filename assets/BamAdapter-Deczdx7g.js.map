{"version":3,"file":"BamAdapter-Deczdx7g.js","sources":["../../node_modules/@gmod/bam/esm/chunk.js","../../node_modules/@gmod/bam/esm/indexFile.js","../../node_modules/@gmod/bam/esm/long.js","../../node_modules/@gmod/bam/esm/util.js","../../node_modules/@gmod/bam/esm/virtualOffset.js","../../node_modules/@gmod/bam/esm/bai.js","../../node_modules/@gmod/bgzf-filehandle/esm/util.js","../../node_modules/@gmod/bgzf-filehandle/esm/unzip.js","../../node_modules/@gmod/bam/esm/csi.js","../../node_modules/@gmod/bam/esm/nullFilehandle.js","../../node_modules/@gmod/bam/esm/constants.js","../../node_modules/@gmod/bam/esm/record.js","../../node_modules/@gmod/bam/esm/sam.js","../../node_modules/@gmod/bam/esm/bamFile.js","../../node_modules/@jbrowse/plugin-alignments/esm/BamAdapter/BamSlightlyLazyFeature.js","../../node_modules/@jbrowse/plugin-alignments/esm/BamAdapter/BamAdapter.js"],"sourcesContent":["// little class representing a chunk in the index\nexport default class Chunk {\n    constructor(minv, maxv, bin, _fetchedSize) {\n        this.minv = minv;\n        this.maxv = maxv;\n        this.bin = bin;\n        this._fetchedSize = _fetchedSize;\n    }\n    toUniqueString() {\n        return `${this.minv.toString()}..${this.maxv.toString()} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`;\n    }\n    toString() {\n        return this.toUniqueString();\n    }\n    compareTo(b) {\n        return (this.minv.compareTo(b.minv) ||\n            this.maxv.compareTo(b.maxv) ||\n            this.bin - b.bin);\n    }\n    fetchedSize() {\n        if (this._fetchedSize !== undefined) {\n            return this._fetchedSize;\n        }\n        return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition;\n    }\n}\n//# sourceMappingURL=chunk.js.map","export default class IndexFile {\n    constructor({ filehandle, renameRefSeq = (n) => n, }) {\n        this.filehandle = filehandle;\n        this.renameRefSeq = renameRefSeq;\n    }\n}\n//# sourceMappingURL=indexFile.js.map","export const TWO_PWR_16_DBL = 1 << 16;\nexport const TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nexport function longFromBytesToUnsigned(source, i = 0) {\n    const low = source[i] |\n        (source[i + 1] << 8) |\n        (source[i + 2] << 16) |\n        (source[i + 3] << 24);\n    const high = source[i + 4] |\n        (source[i + 5] << 8) |\n        (source[i + 6] << 16) |\n        (source[i + 7] << 24);\n    return (high >>> 0) * TWO_PWR_32_DBL + (low >>> 0);\n}\n//# sourceMappingURL=long.js.map","import { longFromBytesToUnsigned } from \"./long.js\";\nexport function timeout(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n/**\n * Properly check if the given AbortSignal is aborted.\n *\n * Per the standard, if the signal reads as aborted, this function throws\n * either a DOMException AbortError, or a regular error with a `code` attribute\n * set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute\n * @returns nothing\n */\nexport function checkAbortSignal(signal) {\n    if (!signal) {\n        return;\n    }\n    if (signal.aborted) {\n        // console.log('bam aborted!')\n        if (typeof DOMException === 'undefined') {\n            const e = new Error('aborted');\n            // @ts-ignore\n            e.code = 'ERR_ABORTED';\n            throw e;\n        }\n        else {\n            throw new DOMException('aborted', 'AbortError');\n        }\n    }\n}\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nexport async function abortBreakPoint(signal) {\n    await Promise.resolve();\n    checkAbortSignal(signal);\n}\nexport function canMergeBlocks(chunk1, chunk2) {\n    return (chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&\n        chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000);\n}\nexport function makeOpts(obj = {}) {\n    return 'aborted' in obj ? { signal: obj } : obj;\n}\nexport function optimizeChunks(chunks, lowest) {\n    const mergedChunks = [];\n    let lastChunk;\n    if (chunks.length === 0) {\n        return chunks;\n    }\n    chunks.sort((c0, c1) => {\n        const dif = c0.minv.blockPosition - c1.minv.blockPosition;\n        return dif === 0 ? c0.minv.dataPosition - c1.minv.dataPosition : dif;\n    });\n    for (const chunk of chunks) {\n        if (!lowest || chunk.maxv.compareTo(lowest) > 0) {\n            if (lastChunk === undefined) {\n                mergedChunks.push(chunk);\n                lastChunk = chunk;\n            }\n            else {\n                if (canMergeBlocks(lastChunk, chunk)) {\n                    if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {\n                        lastChunk.maxv = chunk.maxv;\n                    }\n                }\n                else {\n                    mergedChunks.push(chunk);\n                    lastChunk = chunk;\n                }\n            }\n        }\n    }\n    return mergedChunks;\n}\nexport function parsePseudoBin(bytes, offset) {\n    return {\n        lineCount: longFromBytesToUnsigned(bytes, offset),\n    };\n}\nexport function findFirstData(firstDataLine, virtualOffset) {\n    return firstDataLine\n        ? firstDataLine.compareTo(virtualOffset) > 0\n            ? virtualOffset\n            : firstDataLine\n        : virtualOffset;\n}\nexport function parseNameBytes(namesBytes, renameRefSeq = s => s) {\n    let currRefId = 0;\n    let currNameStart = 0;\n    const refIdToName = [];\n    const refNameToId = {};\n    for (let i = 0; i < namesBytes.length; i += 1) {\n        if (!namesBytes[i]) {\n            if (currNameStart < i) {\n                let refName = '';\n                for (let j = currNameStart; j < i; j++) {\n                    refName += String.fromCharCode(namesBytes[j]);\n                }\n                refName = renameRefSeq(refName);\n                refIdToName[currRefId] = refName;\n                refNameToId[refName] = currRefId;\n            }\n            currNameStart = i + 1;\n            currRefId += 1;\n        }\n    }\n    return { refNameToId, refIdToName };\n}\nexport function sum(array) {\n    let sum = 0;\n    for (const entry of array) {\n        sum += entry.length;\n    }\n    return sum;\n}\nexport function concatUint8Array(args) {\n    const mergedArray = new Uint8Array(sum(args));\n    let offset = 0;\n    for (const entry of args) {\n        mergedArray.set(entry, offset);\n        offset += entry.length;\n    }\n    return mergedArray;\n}\nexport async function gen2array(gen) {\n    let out = [];\n    for await (const x of gen) {\n        out = out.concat(x);\n    }\n    return out;\n}\n//# sourceMappingURL=util.js.map","export class VirtualOffset {\n    constructor(blockPosition, dataPosition) {\n        this.blockPosition = blockPosition; // < offset of the compressed data block\n        this.dataPosition = dataPosition; // < offset into the uncompressed data\n    }\n    toString() {\n        return `${this.blockPosition}:${this.dataPosition}`;\n    }\n    compareTo(b) {\n        return (this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition);\n    }\n}\nexport function fromBytes(bytes, offset = 0, bigendian = false) {\n    if (bigendian) {\n        throw new Error('big-endian virtual file offsets not implemented');\n    }\n    return new VirtualOffset(bytes[offset + 7] * 0x10000000000 +\n        bytes[offset + 6] * 0x100000000 +\n        bytes[offset + 5] * 0x1000000 +\n        bytes[offset + 4] * 0x10000 +\n        bytes[offset + 3] * 0x100 +\n        bytes[offset + 2], (bytes[offset + 1] << 8) | bytes[offset]);\n}\n//# sourceMappingURL=virtualOffset.js.map","import QuickLRU from 'quick-lru';\nimport Chunk from \"./chunk.js\";\nimport IndexFile from \"./indexFile.js\";\nimport { findFirstData, optimizeChunks, parsePseudoBin, } from \"./util.js\";\nimport { fromBytes } from \"./virtualOffset.js\";\nconst BAI_MAGIC = 21578050; // BAI\\1\nfunction roundDown(n, multiple) {\n    return n - (n % multiple);\n}\nfunction roundUp(n, multiple) {\n    return n - (n % multiple) + multiple;\n}\nfunction reg2bins(beg, end) {\n    end -= 1;\n    return [\n        [0, 0],\n        [1 + (beg >> 26), 1 + (end >> 26)],\n        [9 + (beg >> 23), 9 + (end >> 23)],\n        [73 + (beg >> 20), 73 + (end >> 20)],\n        [585 + (beg >> 17), 585 + (end >> 17)],\n        [4681 + (beg >> 14), 4681 + (end >> 14)],\n    ];\n}\nexport default class BAI extends IndexFile {\n    async lineCount(refId, opts) {\n        const indexData = await this.parse(opts);\n        return indexData.indices(refId)?.stats?.lineCount || 0;\n    }\n    async _parse(_opts) {\n        const bytes = await this.filehandle.readFile();\n        const dataView = new DataView(bytes.buffer);\n        // check BAI magic numbers\n        if (dataView.getUint32(0, true) !== BAI_MAGIC) {\n            throw new Error('Not a BAI file');\n        }\n        const refCount = dataView.getInt32(4, true);\n        const depth = 5;\n        const binLimit = ((1 << ((depth + 1) * 3)) - 1) / 7;\n        // read the indexes for each reference sequence\n        let curr = 8;\n        let firstDataLine;\n        const offsets = [];\n        for (let i = 0; i < refCount; i++) {\n            offsets.push(curr);\n            const binCount = dataView.getInt32(curr, true);\n            curr += 4;\n            for (let j = 0; j < binCount; j += 1) {\n                const bin = dataView.getUint32(curr, true);\n                curr += 4;\n                if (bin === binLimit + 1) {\n                    curr += 4;\n                    curr += 32;\n                }\n                else if (bin > binLimit + 1) {\n                    throw new Error('bai index contains too many bins, please use CSI');\n                }\n                else {\n                    const chunkCount = dataView.getInt32(curr, true);\n                    curr += 4;\n                    for (let k = 0; k < chunkCount; k++) {\n                        curr += 8;\n                        curr += 8;\n                    }\n                }\n            }\n            const linearCount = dataView.getInt32(curr, true);\n            curr += 4;\n            // as we're going through the linear index, figure out the smallest\n            // virtual offset in the indexes, which tells us where the BAM header\n            // ends\n            const linearIndex = new Array(linearCount);\n            for (let j = 0; j < linearCount; j++) {\n                const offset = fromBytes(bytes, curr);\n                curr += 8;\n                firstDataLine = findFirstData(firstDataLine, offset);\n                linearIndex[j] = offset;\n            }\n        }\n        const indicesCache = new QuickLRU({\n            maxSize: 5,\n        });\n        function getIndices(refId) {\n            let curr = offsets[refId];\n            if (curr === undefined) {\n                return undefined;\n            }\n            const binCount = dataView.getInt32(curr, true);\n            let stats;\n            curr += 4;\n            const binIndex = {};\n            for (let j = 0; j < binCount; j += 1) {\n                const bin = dataView.getUint32(curr, true);\n                curr += 4;\n                if (bin === binLimit + 1) {\n                    curr += 4;\n                    stats = parsePseudoBin(bytes, curr + 16);\n                    curr += 32;\n                }\n                else if (bin > binLimit + 1) {\n                    throw new Error('bai index contains too many bins, please use CSI');\n                }\n                else {\n                    const chunkCount = dataView.getInt32(curr, true);\n                    curr += 4;\n                    const chunks = new Array(chunkCount);\n                    for (let k = 0; k < chunkCount; k++) {\n                        const u = fromBytes(bytes, curr);\n                        curr += 8;\n                        const v = fromBytes(bytes, curr);\n                        curr += 8;\n                        firstDataLine = findFirstData(firstDataLine, u);\n                        chunks[k] = new Chunk(u, v, bin);\n                    }\n                    binIndex[bin] = chunks;\n                }\n            }\n            const linearCount = dataView.getInt32(curr, true);\n            curr += 4;\n            // as we're going through the linear index, figure out the smallest\n            // virtual offset in the indexes, which tells us where the BAM header\n            // ends\n            const linearIndex = new Array(linearCount);\n            for (let j = 0; j < linearCount; j++) {\n                const offset = fromBytes(bytes, curr);\n                curr += 8;\n                firstDataLine = findFirstData(firstDataLine, offset);\n                linearIndex[j] = offset;\n            }\n            return {\n                binIndex,\n                linearIndex,\n                stats,\n            };\n        }\n        return {\n            bai: true,\n            firstDataLine,\n            maxBlockSize: 1 << 16,\n            indices: (refId) => {\n                if (!indicesCache.has(refId)) {\n                    const result = getIndices(refId);\n                    if (result) {\n                        indicesCache.set(refId, result);\n                    }\n                    return result;\n                }\n                return indicesCache.get(refId);\n            },\n            refCount,\n        };\n    }\n    async indexCov(seqId, start, end, opts) {\n        const v = 16384;\n        const range = start !== undefined;\n        const indexData = await this.parse(opts);\n        const seqIdx = indexData.indices(seqId);\n        if (!seqIdx) {\n            return [];\n        }\n        const { linearIndex = [], stats } = seqIdx;\n        if (linearIndex.length === 0) {\n            return [];\n        }\n        const e = end === undefined ? (linearIndex.length - 1) * v : roundUp(end, v);\n        const s = start === undefined ? 0 : roundDown(start, v);\n        const depths = range\n            ? new Array((e - s) / v)\n            : new Array(linearIndex.length - 1);\n        const totalSize = linearIndex[linearIndex.length - 1].blockPosition;\n        if (e > (linearIndex.length - 1) * v) {\n            throw new Error('query outside of range of linear index');\n        }\n        let currentPos = linearIndex[s / v].blockPosition;\n        for (let i = s / v, j = 0; i < e / v; i++, j++) {\n            depths[j] = {\n                score: linearIndex[i + 1].blockPosition - currentPos,\n                start: i * v,\n                end: i * v + v,\n            };\n            currentPos = linearIndex[i + 1].blockPosition;\n        }\n        return depths.map(d => ({\n            ...d,\n            score: (d.score * (stats?.lineCount || 0)) / totalSize,\n        }));\n    }\n    async blocksForRange(refId, min, max, opts = {}) {\n        if (min < 0) {\n            min = 0;\n        }\n        const indexData = await this.parse(opts);\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!indexData) {\n            return [];\n        }\n        const ba = indexData.indices(refId);\n        if (!ba) {\n            return [];\n        }\n        // List of bin #s that overlap min, max\n        const overlappingBins = reg2bins(min, max);\n        const chunks = [];\n        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n        for (const [start, end] of overlappingBins) {\n            for (let bin = start; bin <= end; bin++) {\n                if (ba.binIndex[bin]) {\n                    const binChunks = ba.binIndex[bin];\n                    for (const binChunk of binChunks) {\n                        chunks.push(new Chunk(binChunk.minv, binChunk.maxv, bin));\n                    }\n                }\n            }\n        }\n        // Use the linear index to find minimum file position of chunks that could\n        // contain alignments in the region\n        const nintv = ba.linearIndex.length;\n        let lowest;\n        const minLin = Math.min(min >> 14, nintv - 1);\n        const maxLin = Math.min(max >> 14, nintv - 1);\n        for (let i = minLin; i <= maxLin; ++i) {\n            const vp = ba.linearIndex[i];\n            if (vp && (!lowest || vp.compareTo(lowest) < 0)) {\n                lowest = vp;\n            }\n        }\n        return optimizeChunks(chunks, lowest);\n    }\n    async parse(opts = {}) {\n        if (!this.setupP) {\n            this.setupP = this._parse(opts).catch((e) => {\n                this.setupP = undefined;\n                throw e;\n            });\n        }\n        return this.setupP;\n    }\n    async hasRefSeq(seqId, opts = {}) {\n        const header = await this.parse(opts);\n        return !!header.indices(seqId)?.binIndex;\n    }\n}\n//# sourceMappingURL=bai.js.map","function sum(array) {\n    let sum = 0;\n    for (const entry of array) {\n        sum += entry.length;\n    }\n    return sum;\n}\nexport function concatUint8Array(args, totalLength) {\n    const mergedArray = new Uint8Array(totalLength ?? sum(args));\n    let offset = 0;\n    for (const entry of args) {\n        mergedArray.set(entry, offset);\n        offset += entry.length;\n    }\n    return mergedArray;\n}\n//# sourceMappingURL=util.js.map","import { Inflate, Z_SYNC_FLUSH } from 'pako-esm2';\nimport { concatUint8Array } from \"./util.js\";\n// browserify-zlib, which is the zlib shim used by default in webpacked code,\n// does not properly uncompress bgzf chunks that contain more than one bgzf\n// block, so export an unzip function that uses @progress/pako-esm2 directly if we are running\n// in a browser.\nexport async function unzip(inputData) {\n    try {\n        let strm;\n        let pos = 0;\n        let inflator;\n        const blocks = [];\n        let totalLength = 0;\n        do {\n            const remainingInput = inputData.subarray(pos);\n            inflator = new Inflate(undefined);\n            ({ strm } = inflator);\n            inflator.push(remainingInput, Z_SYNC_FLUSH);\n            if (inflator.err) {\n                throw new Error(inflator.msg);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n            pos += strm.next_in;\n            const result = inflator.result;\n            blocks.push(result);\n            totalLength += result.length;\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        } while (strm.avail_in);\n        return concatUint8Array(blocks, totalLength);\n    }\n    catch (e) {\n        // return a slightly more informative error message\n        if (/incorrect header check/.exec(`${e}`)) {\n            throw new Error('problem decompressing block: incorrect gzip header check');\n        }\n        throw e;\n    }\n}\n// keeps track of the position of compressed blocks in terms of file offsets,\n// and a decompressed equivalent\n//\n// also slices (0,minv.dataPosition) and (maxv.dataPosition,end) off\nexport async function unzipChunkSlice(inputData, chunk, blockCache) {\n    try {\n        let strm;\n        const { minv, maxv } = chunk;\n        let cpos = minv.blockPosition;\n        let dpos = minv.dataPosition;\n        const chunks = [];\n        const cpositions = [];\n        const dpositions = [];\n        let i = 0;\n        let wasFromCache = false;\n        let totalLength = 0;\n        do {\n            const remainingInput = inputData.subarray(cpos - minv.blockPosition);\n            const cacheKey = cpos.toString();\n            let buffer;\n            let nextIn;\n            // Check cache first\n            const cached = blockCache?.get(cacheKey);\n            if (cached) {\n                buffer = cached.buffer;\n                nextIn = cached.nextIn;\n                wasFromCache = true;\n            }\n            else {\n                // Not in cache, decompress and store\n                const inflator = new Inflate(undefined);\n                ({ strm } = inflator);\n                inflator.push(remainingInput, Z_SYNC_FLUSH);\n                if (inflator.err) {\n                    throw new Error(inflator.msg);\n                }\n                buffer = inflator.result;\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n                nextIn = strm.next_in;\n                wasFromCache = false;\n                // Cache the decompressed block\n                blockCache?.set(cacheKey, { buffer, nextIn });\n            }\n            chunks.push(buffer);\n            let len = buffer.length;\n            cpositions.push(cpos);\n            dpositions.push(dpos);\n            if (chunks.length === 1 && minv.dataPosition) {\n                // this is the first chunk, trim it\n                chunks[0] = chunks[0].subarray(minv.dataPosition);\n                len = chunks[0].length;\n            }\n            const origCpos = cpos;\n            cpos += nextIn;\n            dpos += len;\n            if (origCpos >= maxv.blockPosition) {\n                // this is the last chunk, trim it and stop decompressing. note if it is\n                // the same block is minv it subtracts that already trimmed part of the\n                // slice length\n                chunks[i] = chunks[i].subarray(0, maxv.blockPosition === minv.blockPosition\n                    ? maxv.dataPosition - minv.dataPosition + 1\n                    : maxv.dataPosition + 1);\n                totalLength += chunks[i].length;\n                cpositions.push(cpos);\n                dpositions.push(dpos);\n                break;\n            }\n            totalLength += len;\n            i++;\n        } while (wasFromCache\n            ? cpos < inputData.length + minv.blockPosition\n            : // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n                strm.avail_in);\n        return {\n            buffer: concatUint8Array(chunks, totalLength),\n            cpositions,\n            dpositions,\n        };\n    }\n    catch (e) {\n        // return a slightly more informative error message\n        if (/incorrect header check/.exec(`${e}`)) {\n            throw new Error('problem decompressing block: incorrect gzip header check');\n        }\n        throw e;\n    }\n}\n//# sourceMappingURL=unzip.js.map","import { unzip } from '@gmod/bgzf-filehandle';\nimport QuickLRU from 'quick-lru';\nimport Chunk from \"./chunk.js\";\nimport IndexFile from \"./indexFile.js\";\nimport { findFirstData, optimizeChunks, parseNameBytes, parsePseudoBin, } from \"./util.js\";\nimport { VirtualOffset, fromBytes } from \"./virtualOffset.js\";\nconst CSI1_MAGIC = 21582659; // CSI\\1\nconst CSI2_MAGIC = 38359875; // CSI\\2\nfunction lshift(num, bits) {\n    return num * 2 ** bits;\n}\nfunction rshift(num, bits) {\n    return Math.floor(num / 2 ** bits);\n}\nexport default class CSI extends IndexFile {\n    constructor() {\n        super(...arguments);\n        this.maxBinNumber = 0;\n        this.depth = 0;\n        this.minShift = 0;\n    }\n    async lineCount(refId, opts) {\n        const indexData = await this.parse(opts);\n        return indexData.indices(refId)?.stats?.lineCount || 0;\n    }\n    async indexCov() {\n        return [];\n    }\n    parseAuxData(bytes, offset) {\n        const dataView = new DataView(bytes.buffer);\n        const formatFlags = dataView.getUint32(offset, true);\n        const coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';\n        const format = { 0: 'generic', 1: 'SAM', 2: 'VCF' }[formatFlags & 0xf];\n        if (!format) {\n            throw new Error(`invalid Tabix preset format flags ${formatFlags}`);\n        }\n        const columnNumbers = {\n            ref: dataView.getInt32(offset + 4, true),\n            start: dataView.getInt32(offset + 8, true),\n            end: dataView.getInt32(offset + 12, true),\n        };\n        const metaValue = dataView.getInt32(offset + 16, true);\n        const metaChar = metaValue ? String.fromCharCode(metaValue) : '';\n        const skipLines = dataView.getInt32(offset + 20, true);\n        const nameSectionLength = dataView.getInt32(offset + 24, true);\n        return {\n            columnNumbers,\n            coordinateType,\n            metaValue,\n            metaChar,\n            skipLines,\n            format,\n            formatFlags,\n            ...parseNameBytes(bytes.subarray(offset + 28, offset + 28 + nameSectionLength), this.renameRefSeq),\n        };\n    }\n    // fetch and parse the index\n    async _parse(opts) {\n        const buffer = await this.filehandle.readFile(opts);\n        const bytes = await unzip(buffer);\n        const dataView = new DataView(bytes.buffer);\n        let csiVersion;\n        const magic = dataView.getUint32(0, true);\n        if (magic === CSI1_MAGIC) {\n            csiVersion = 1;\n        }\n        else if (magic === CSI2_MAGIC) {\n            csiVersion = 2;\n        }\n        else {\n            throw new Error(`Not a CSI file ${magic}`);\n            // TODO: do we need to support big-endian CSI files?\n        }\n        this.minShift = dataView.getInt32(4, true);\n        this.depth = dataView.getInt32(8, true);\n        this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7;\n        const maxBinNumber = this.maxBinNumber;\n        const auxLength = dataView.getInt32(12, true);\n        const aux = auxLength >= 30 ? this.parseAuxData(bytes, 16) : undefined;\n        const refCount = dataView.getInt32(16 + auxLength, true);\n        // read the indexes for each reference sequence\n        let curr = 16 + auxLength + 4;\n        let firstDataLine;\n        const offsets = [];\n        for (let i = 0; i < refCount; i++) {\n            offsets.push(curr);\n            const binCount = dataView.getInt32(curr, true);\n            curr += 4;\n            for (let j = 0; j < binCount; j++) {\n                const bin = dataView.getUint32(curr, true);\n                curr += 4;\n                if (bin > this.maxBinNumber) {\n                    curr += 28 + 16;\n                }\n                else {\n                    curr += 8;\n                    const chunkCount = dataView.getInt32(curr, true);\n                    curr += 4;\n                    for (let k = 0; k < chunkCount; k += 1) {\n                        const u = fromBytes(bytes, curr);\n                        curr += 8;\n                        curr += 8;\n                        firstDataLine = findFirstData(firstDataLine, u);\n                    }\n                }\n            }\n        }\n        const indicesCache = new QuickLRU({\n            maxSize: 5,\n        });\n        function getIndices(refId) {\n            let curr = offsets[refId];\n            if (curr === undefined) {\n                return undefined;\n            }\n            // the binning index\n            const binCount = dataView.getInt32(curr, true);\n            curr += 4;\n            const binIndex = {};\n            let pseudoBinStats;\n            for (let j = 0; j < binCount; j++) {\n                const bin = dataView.getUint32(curr, true);\n                curr += 4;\n                if (bin > maxBinNumber) {\n                    pseudoBinStats = parsePseudoBin(bytes, curr + 28);\n                    curr += 28 + 16;\n                }\n                else {\n                    firstDataLine = findFirstData(firstDataLine, fromBytes(bytes, curr));\n                    curr += 8;\n                    const chunkCount = dataView.getInt32(curr, true);\n                    curr += 4;\n                    const chunks = new Array(chunkCount);\n                    for (let k = 0; k < chunkCount; k += 1) {\n                        const u = fromBytes(bytes, curr);\n                        curr += 8;\n                        const v = fromBytes(bytes, curr);\n                        curr += 8;\n                        chunks[k] = new Chunk(u, v, bin);\n                    }\n                    binIndex[bin] = chunks;\n                }\n            }\n            return {\n                binIndex,\n                stats: pseudoBinStats,\n            };\n        }\n        return {\n            csiVersion,\n            firstDataLine,\n            indices: (refId) => {\n                if (!indicesCache.has(refId)) {\n                    const result = getIndices(refId);\n                    if (result) {\n                        indicesCache.set(refId, result);\n                    }\n                    return result;\n                }\n                return indicesCache.get(refId);\n            },\n            refCount,\n            csi: true,\n            maxBlockSize: 1 << 16,\n            ...aux,\n        };\n    }\n    async blocksForRange(refId, min, max, opts = {}) {\n        if (min < 0) {\n            min = 0;\n        }\n        const indexData = await this.parse(opts);\n        const ba = indexData.indices(refId);\n        if (!ba) {\n            return [];\n        }\n        const overlappingBins = this.reg2bins(min, max);\n        if (overlappingBins.length === 0) {\n            return [];\n        }\n        const chunks = [];\n        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n        for (const [start, end] of overlappingBins) {\n            for (let bin = start; bin <= end; bin++) {\n                if (ba.binIndex[bin]) {\n                    const binChunks = ba.binIndex[bin];\n                    for (const c of binChunks) {\n                        chunks.push(c);\n                    }\n                }\n            }\n        }\n        return optimizeChunks(chunks, new VirtualOffset(0, 0));\n    }\n    /**\n     * calculate the list of bins that may overlap with region [beg,end)\n     * (zero-based half-open)\n     */\n    reg2bins(beg, end) {\n        beg -= 1; // < convert to 1-based closed\n        if (beg < 1) {\n            beg = 1;\n        }\n        if (end > 2 ** 50) {\n            end = 2 ** 34;\n        } // 17 GiB ought to be enough for anybody\n        end -= 1;\n        let l = 0;\n        let t = 0;\n        let s = this.minShift + this.depth * 3;\n        const bins = [];\n        for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {\n            const b = t + rshift(beg, s);\n            const e = t + rshift(end, s);\n            if (e - b + bins.length > this.maxBinNumber) {\n                throw new Error(`query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);\n            }\n            bins.push([b, e]);\n        }\n        return bins;\n    }\n    async parse(opts = {}) {\n        if (!this.setupP) {\n            this.setupP = this._parse(opts).catch((e) => {\n                this.setupP = undefined;\n                throw e;\n            });\n        }\n        return this.setupP;\n    }\n    async hasRefSeq(seqId, opts = {}) {\n        const header = await this.parse(opts);\n        return !!header.indices(seqId)?.binIndex;\n    }\n}\n//# sourceMappingURL=csi.js.map","export default class NullFilehandle {\n    read() {\n        throw new Error('never called');\n    }\n    stat() {\n        throw new Error('never called');\n    }\n    readFile() {\n        throw new Error('never called');\n    }\n    close() {\n        throw new Error('never called');\n    }\n}\n//# sourceMappingURL=nullFilehandle.js.map","export default {\n    //  the read is paired in sequencing, no matter whether it is mapped in a pair\n    BAM_FPAIRED: 1,\n    //  the read is mapped in a proper pair\n    BAM_FPROPER_PAIR: 2,\n    //  the read itself is unmapped; conflictive with BAM_FPROPER_PAIR\n    BAM_FUNMAP: 4,\n    //  the mate is unmapped\n    BAM_FMUNMAP: 8,\n    //  the read is mapped to the reverse strand\n    BAM_FREVERSE: 16,\n    //  the mate is mapped to the reverse strand\n    BAM_FMREVERSE: 32,\n    //  this is read1\n    BAM_FREAD1: 64,\n    //  this is read2\n    BAM_FREAD2: 128,\n    //  not primary alignment\n    BAM_FSECONDARY: 256,\n    //  QC failure\n    BAM_FQCFAIL: 512,\n    //  optical or PCR duplicate\n    BAM_FDUP: 1024,\n    //  supplementary alignment\n    BAM_FSUPPLEMENTARY: 2048,\n};\n//# sourceMappingURL=constants.js.map","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _BamRecord_dataView;\nimport Constants from \"./constants.js\";\nconst SEQRET_DECODER = '=ACMGRSVTWYHKDBN'.split('');\nconst CIGAR_DECODER = 'MIDNSHP=X???????'.split('');\nclass BamRecord {\n    constructor(args) {\n        _BamRecord_dataView.set(this, void 0);\n        this.bytes = args.bytes;\n        this.fileOffset = args.fileOffset;\n        __classPrivateFieldSet(this, _BamRecord_dataView, new DataView(this.bytes.byteArray.buffer), \"f\");\n    }\n    get byteArray() {\n        return this.bytes.byteArray;\n    }\n    get flags() {\n        return ((__classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt32(this.bytes.start + 16, true) & 0xffff0000) >> 16);\n    }\n    get ref_id() {\n        return __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt32(this.bytes.start + 4, true);\n    }\n    get start() {\n        return __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt32(this.bytes.start + 8, true);\n    }\n    get end() {\n        return this.start + this.length_on_ref;\n    }\n    get id() {\n        return this.fileOffset;\n    }\n    get mq() {\n        const mq = (this.bin_mq_nl & 0xff00) >> 8;\n        return mq === 255 ? undefined : mq;\n    }\n    get score() {\n        return this.mq;\n    }\n    get qual() {\n        if (this.isSegmentUnmapped()) {\n            return;\n        }\n        const p = this.b0 +\n            this.read_name_length +\n            this.num_cigar_ops * 4 +\n            this.num_seq_bytes;\n        return this.byteArray.subarray(p, p + this.seq_length);\n    }\n    get strand() {\n        return this.isReverseComplemented() ? -1 : 1;\n    }\n    get b0() {\n        return this.bytes.start + 36;\n    }\n    get name() {\n        let str = '';\n        for (let i = 0; i < this.read_name_length - 1; i++) {\n            str += String.fromCharCode(this.byteArray[this.b0 + i]);\n        }\n        return str;\n    }\n    get tags() {\n        let p = this.b0 +\n            this.read_name_length +\n            this.num_cigar_ops * 4 +\n            this.num_seq_bytes +\n            this.seq_length;\n        const blockEnd = this.bytes.end;\n        const tags = {};\n        while (p < blockEnd) {\n            const tag = String.fromCharCode(this.byteArray[p], this.byteArray[p + 1]);\n            const type = String.fromCharCode(this.byteArray[p + 2]);\n            p += 3;\n            if (type === 'A') {\n                tags[tag] = String.fromCharCode(this.byteArray[p]);\n                p += 1;\n            }\n            else if (type === 'i') {\n                tags[tag] = __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt32(p, true);\n                p += 4;\n            }\n            else if (type === 'I') {\n                tags[tag] = __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getUint32(p, true);\n                p += 4;\n            }\n            else if (type === 'c') {\n                tags[tag] = __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt8(p);\n                p += 1;\n            }\n            else if (type === 'C') {\n                tags[tag] = __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getUint8(p);\n                p += 1;\n            }\n            else if (type === 's') {\n                tags[tag] = __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt16(p, true);\n                p += 2;\n            }\n            else if (type === 'S') {\n                tags[tag] = __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getUint16(p, true);\n                p += 2;\n            }\n            else if (type === 'f') {\n                tags[tag] = __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getFloat32(p, true);\n                p += 4;\n            }\n            else if (type === 'Z' || type === 'H') {\n                const value = [];\n                while (p <= blockEnd) {\n                    const cc = this.byteArray[p++];\n                    if (cc !== 0) {\n                        value.push(String.fromCharCode(cc));\n                    }\n                    else {\n                        break;\n                    }\n                }\n                tags[tag] = value.join('');\n            }\n            else if (type === 'B') {\n                const cc = this.byteArray[p++];\n                const Btype = String.fromCharCode(cc);\n                const limit = __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt32(p, true);\n                p += 4;\n                if (Btype === 'i') {\n                    if (tag === 'CG') {\n                        const value = [];\n                        for (let k = 0; k < limit; k++) {\n                            const cigop = __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt32(p, true);\n                            const lop = cigop >> 4;\n                            const op = CIGAR_DECODER[cigop & 0xf];\n                            value.push(lop + op);\n                            p += 4;\n                        }\n                        tags[tag] = value.join('');\n                    }\n                    else {\n                        const value = [];\n                        for (let k = 0; k < limit; k++) {\n                            value.push(__classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt32(p, true));\n                            p += 4;\n                        }\n                        tags[tag] = value;\n                    }\n                }\n                else if (Btype === 'I') {\n                    if (tag === 'CG') {\n                        const value = [];\n                        for (let k = 0; k < limit; k++) {\n                            const cigop = __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getUint32(p, true);\n                            const lop = cigop >> 4;\n                            const op = CIGAR_DECODER[cigop & 0xf];\n                            value.push(lop + op);\n                            p += 4;\n                        }\n                        tags[tag] = value.join('');\n                    }\n                    else {\n                        const value = [];\n                        for (let k = 0; k < limit; k++) {\n                            value.push(__classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getUint32(p, true));\n                            p += 4;\n                        }\n                        tags[tag] = value;\n                    }\n                }\n                else if (Btype === 's') {\n                    const value = [];\n                    for (let k = 0; k < limit; k++) {\n                        value.push(__classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt16(p, true));\n                        p += 2;\n                    }\n                    tags[tag] = value;\n                }\n                else if (Btype === 'S') {\n                    const value = [];\n                    for (let k = 0; k < limit; k++) {\n                        value.push(__classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getUint16(p, true));\n                        p += 2;\n                    }\n                    tags[tag] = value;\n                }\n                else if (Btype === 'c') {\n                    const value = [];\n                    for (let k = 0; k < limit; k++) {\n                        value.push(__classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt8(p));\n                        p += 1;\n                    }\n                    tags[tag] = value;\n                }\n                else if (Btype === 'C') {\n                    const value = [];\n                    for (let k = 0; k < limit; k++) {\n                        value.push(__classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getUint8(p));\n                        p += 1;\n                    }\n                    tags[tag] = value;\n                }\n                else if (Btype === 'f') {\n                    const value = [];\n                    for (let k = 0; k < limit; k++) {\n                        value.push(__classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getFloat32(p, true));\n                        p += 4;\n                    }\n                    tags[tag] = value;\n                }\n            }\n            else {\n                console.error('Unknown BAM tag type', type);\n                break;\n            }\n        }\n        return tags;\n    }\n    /**\n     * @returns {boolean} true if the read is paired, regardless of whether both\n     * segments are mapped\n     */\n    isPaired() {\n        return !!(this.flags & Constants.BAM_FPAIRED);\n    }\n    /** @returns {boolean} true if the read is paired, and both segments are mapped */\n    isProperlyPaired() {\n        return !!(this.flags & Constants.BAM_FPROPER_PAIR);\n    }\n    /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n    isSegmentUnmapped() {\n        return !!(this.flags & Constants.BAM_FUNMAP);\n    }\n    /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n    isMateUnmapped() {\n        return !!(this.flags & Constants.BAM_FMUNMAP);\n    }\n    /** @returns {boolean} true if the read is mapped to the reverse strand */\n    isReverseComplemented() {\n        return !!(this.flags & Constants.BAM_FREVERSE);\n    }\n    /** @returns {boolean} true if the mate is mapped to the reverse strand */\n    isMateReverseComplemented() {\n        return !!(this.flags & Constants.BAM_FMREVERSE);\n    }\n    /** @returns {boolean} true if this is read number 1 in a pair */\n    isRead1() {\n        return !!(this.flags & Constants.BAM_FREAD1);\n    }\n    /** @returns {boolean} true if this is read number 2 in a pair */\n    isRead2() {\n        return !!(this.flags & Constants.BAM_FREAD2);\n    }\n    /** @returns {boolean} true if this is a secondary alignment */\n    isSecondary() {\n        return !!(this.flags & Constants.BAM_FSECONDARY);\n    }\n    /** @returns {boolean} true if this read has failed QC checks */\n    isFailedQc() {\n        return !!(this.flags & Constants.BAM_FQCFAIL);\n    }\n    /** @returns {boolean} true if the read is an optical or PCR duplicate */\n    isDuplicate() {\n        return !!(this.flags & Constants.BAM_FDUP);\n    }\n    /** @returns {boolean} true if this is a supplementary alignment */\n    isSupplementary() {\n        return !!(this.flags & Constants.BAM_FSUPPLEMENTARY);\n    }\n    get cigarAndLength() {\n        if (this.isSegmentUnmapped()) {\n            return {\n                length_on_ref: 0,\n                CIGAR: '',\n            };\n        }\n        const numCigarOps = this.num_cigar_ops;\n        let p = this.b0 + this.read_name_length;\n        const CIGAR = [];\n        // check for CG tag by inspecting whether the CIGAR field contains a clip\n        // that consumes entire seqLen\n        let cigop = __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt32(p, true);\n        let lop = cigop >> 4;\n        let op = CIGAR_DECODER[cigop & 0xf];\n        if (op === 'S' && lop === this.seq_length) {\n            // if there is a CG the second CIGAR field will be a N tag the represents\n            // the length on ref\n            p += 4;\n            cigop = __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt32(p, true);\n            lop = cigop >> 4;\n            op = CIGAR_DECODER[cigop & 0xf];\n            if (op !== 'N') {\n                console.warn('CG tag with no N tag');\n            }\n            return {\n                CIGAR: this.tags.CG,\n                length_on_ref: lop,\n            };\n        }\n        else {\n            let lref = 0;\n            for (let c = 0; c < numCigarOps; ++c) {\n                cigop = __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt32(p, true);\n                lop = cigop >> 4;\n                op = CIGAR_DECODER[cigop & 0xf];\n                CIGAR.push(lop + op);\n                // soft clip, hard clip, and insertion don't count toward the length on\n                // the reference\n                if (op !== 'H' && op !== 'S' && op !== 'I') {\n                    lref += lop;\n                }\n                p += 4;\n            }\n            return {\n                CIGAR: CIGAR.join(''),\n                length_on_ref: lref,\n            };\n        }\n    }\n    get length_on_ref() {\n        return this.cigarAndLength.length_on_ref;\n    }\n    get CIGAR() {\n        return this.cigarAndLength.CIGAR;\n    }\n    get num_cigar_ops() {\n        return this.flag_nc & 0xffff;\n    }\n    get read_name_length() {\n        return this.bin_mq_nl & 0xff;\n    }\n    get num_seq_bytes() {\n        return (this.seq_length + 1) >> 1;\n    }\n    get seq() {\n        const p = this.b0 + this.read_name_length + this.num_cigar_ops * 4;\n        const seqBytes = this.num_seq_bytes;\n        const len = this.seq_length;\n        const buf = [];\n        let i = 0;\n        for (let j = 0; j < seqBytes; ++j) {\n            const sb = this.byteArray[p + j];\n            buf.push(SEQRET_DECODER[(sb & 0xf0) >> 4]);\n            i++;\n            if (i < len) {\n                buf.push(SEQRET_DECODER[sb & 0x0f]);\n                i++;\n            }\n        }\n        return buf.join('');\n    }\n    // adapted from igv.js\n    get pair_orientation() {\n        if (!this.isSegmentUnmapped() &&\n            !this.isMateUnmapped() &&\n            this.ref_id === this.next_refid) {\n            const s1 = this.isReverseComplemented() ? 'R' : 'F';\n            const s2 = this.isMateReverseComplemented() ? 'R' : 'F';\n            let o1 = ' ';\n            let o2 = ' ';\n            if (this.isRead1()) {\n                o1 = '1';\n                o2 = '2';\n            }\n            else if (this.isRead2()) {\n                o1 = '2';\n                o2 = '1';\n            }\n            const tmp = [];\n            const isize = this.template_length;\n            if (isize > 0) {\n                tmp[0] = s1;\n                tmp[1] = o1;\n                tmp[2] = s2;\n                tmp[3] = o2;\n            }\n            else {\n                tmp[2] = s1;\n                tmp[3] = o1;\n                tmp[0] = s2;\n                tmp[1] = o2;\n            }\n            return tmp.join('');\n        }\n        return undefined;\n    }\n    get bin_mq_nl() {\n        return __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt32(this.bytes.start + 12, true);\n    }\n    get flag_nc() {\n        return __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt32(this.bytes.start + 16, true);\n    }\n    get seq_length() {\n        return __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt32(this.bytes.start + 20, true);\n    }\n    get next_refid() {\n        return __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt32(this.bytes.start + 24, true);\n    }\n    get next_pos() {\n        return __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt32(this.bytes.start + 28, true);\n    }\n    get template_length() {\n        return __classPrivateFieldGet(this, _BamRecord_dataView, \"f\").getInt32(this.bytes.start + 32, true);\n    }\n    seqAt(idx) {\n        if (idx < this.seq_length) {\n            const byteIndex = idx >> 1;\n            const sb = this.byteArray[this.b0 + this.read_name_length + this.num_cigar_ops * 4 + byteIndex];\n            return idx % 2 === 0\n                ? SEQRET_DECODER[(sb & 0xf0) >> 4]\n                : SEQRET_DECODER[sb & 0x0f];\n        }\n        else {\n            return undefined;\n        }\n    }\n    toJSON() {\n        const data = {};\n        for (const k of Object.keys(this)) {\n            if (k.startsWith('_') || k === 'bytes') {\n                continue;\n            }\n            // @ts-ignore\n            data[k] = this[k];\n        }\n        return data;\n    }\n}\n_BamRecord_dataView = new WeakMap();\nexport default BamRecord;\nfunction cacheGetter(ctor, prop) {\n    const desc = Object.getOwnPropertyDescriptor(ctor.prototype, prop);\n    if (!desc) {\n        throw new Error('OH NO, NO PROPERTY DESCRIPTOR');\n    }\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const getter = desc.get;\n    if (!getter) {\n        throw new Error('OH NO, NOT A GETTER');\n    }\n    Object.defineProperty(ctor.prototype, prop, {\n        get() {\n            const ret = getter.call(this);\n            Object.defineProperty(this, prop, { value: ret });\n            return ret;\n        },\n    });\n}\ncacheGetter(BamRecord, 'tags');\ncacheGetter(BamRecord, 'cigarAndLength');\ncacheGetter(BamRecord, 'seq');\ncacheGetter(BamRecord, 'qual');\n//# sourceMappingURL=record.js.map","export function parseHeaderText(text) {\n    const lines = text.split(/\\r?\\n/);\n    const data = [];\n    for (const line of lines) {\n        const [tag, ...fields] = line.split(/\\t/);\n        if (tag) {\n            data.push({\n                tag: tag.slice(1),\n                data: fields.map(f => {\n                    const r = f.indexOf(':');\n                    const fieldTag = f.slice(0, r);\n                    const value = f.slice(r + 1);\n                    return { tag: fieldTag, value };\n                }),\n            });\n        }\n    }\n    return data;\n}\n//# sourceMappingURL=sam.js.map","import { unzip, unzipChunkSlice } from '@gmod/bgzf-filehandle';\nimport crc32 from 'crc/calculators/crc32';\nimport { LocalFile, RemoteFile } from 'generic-filehandle2';\nimport QuickLRU from 'quick-lru';\nimport BAI from \"./bai.js\";\nimport CSI from \"./csi.js\";\nimport NullFilehandle from \"./nullFilehandle.js\";\nimport BAMFeature from \"./record.js\";\nimport { parseHeaderText } from \"./sam.js\";\nimport { checkAbortSignal, gen2array, makeOpts, timeout } from \"./util.js\";\nexport const BAM_MAGIC = 21840194;\nconst blockLen = 1 << 16;\nexport default class BamFile {\n    constructor({ bamFilehandle, bamPath, bamUrl, baiPath, baiFilehandle, baiUrl, csiPath, csiFilehandle, csiUrl, htsget, yieldThreadTime = 100, renameRefSeqs = n => n, }) {\n        this.htsget = false;\n        this.cache = new QuickLRU({\n            maxSize: 1000,\n        });\n        this.renameRefSeq = renameRefSeqs;\n        if (bamFilehandle) {\n            this.bam = bamFilehandle;\n        }\n        else if (bamPath) {\n            this.bam = new LocalFile(bamPath);\n        }\n        else if (bamUrl) {\n            this.bam = new RemoteFile(bamUrl);\n        }\n        else if (htsget) {\n            this.htsget = true;\n            this.bam = new NullFilehandle();\n        }\n        else {\n            throw new Error('unable to initialize bam');\n        }\n        if (csiFilehandle) {\n            this.index = new CSI({ filehandle: csiFilehandle });\n        }\n        else if (csiPath) {\n            this.index = new CSI({ filehandle: new LocalFile(csiPath) });\n        }\n        else if (csiUrl) {\n            this.index = new CSI({ filehandle: new RemoteFile(csiUrl) });\n        }\n        else if (baiFilehandle) {\n            this.index = new BAI({ filehandle: baiFilehandle });\n        }\n        else if (baiPath) {\n            this.index = new BAI({ filehandle: new LocalFile(baiPath) });\n        }\n        else if (baiUrl) {\n            this.index = new BAI({ filehandle: new RemoteFile(baiUrl) });\n        }\n        else if (bamPath) {\n            this.index = new BAI({ filehandle: new LocalFile(`${bamPath}.bai`) });\n        }\n        else if (bamUrl) {\n            this.index = new BAI({ filehandle: new RemoteFile(`${bamUrl}.bai`) });\n        }\n        else if (htsget) {\n            this.htsget = true;\n        }\n        else {\n            throw new Error('unable to infer index format');\n        }\n        this.yieldThreadTime = yieldThreadTime;\n    }\n    async getHeaderPre(origOpts) {\n        const opts = makeOpts(origOpts);\n        if (!this.index) {\n            return;\n        }\n        const indexData = await this.index.parse(opts);\n        const ret = indexData.firstDataLine\n            ? indexData.firstDataLine.blockPosition + 65535\n            : undefined;\n        let buffer;\n        if (ret) {\n            const s = ret + blockLen;\n            buffer = await this.bam.read(s, 0);\n        }\n        else {\n            buffer = await this.bam.readFile(opts);\n        }\n        const uncba = await unzip(buffer);\n        const dataView = new DataView(uncba.buffer);\n        if (dataView.getInt32(0, true) !== BAM_MAGIC) {\n            throw new Error('Not a BAM file');\n        }\n        const headLen = dataView.getInt32(4, true);\n        const decoder = new TextDecoder('utf8');\n        this.header = decoder.decode(uncba.subarray(8, 8 + headLen));\n        const { chrToIndex, indexToChr } = await this._readRefSeqs(headLen + 8, 65535, opts);\n        this.chrToIndex = chrToIndex;\n        this.indexToChr = indexToChr;\n        return parseHeaderText(this.header);\n    }\n    getHeader(opts) {\n        if (!this.headerP) {\n            this.headerP = this.getHeaderPre(opts).catch((e) => {\n                this.headerP = undefined;\n                throw e;\n            });\n        }\n        return this.headerP;\n    }\n    async getHeaderText(opts = {}) {\n        await this.getHeader(opts);\n        return this.header;\n    }\n    // the full length of the refseq block is not given in advance so this grabs\n    // a chunk and doubles it if all refseqs haven't been processed\n    async _readRefSeqs(start, refSeqBytes, opts) {\n        if (start > refSeqBytes) {\n            return this._readRefSeqs(start, refSeqBytes * 2, opts);\n        }\n        // const size = refSeqBytes + blockLen <-- use this?\n        const buffer = await this.bam.read(refSeqBytes, 0, opts);\n        const uncba = await unzip(buffer);\n        const dataView = new DataView(uncba.buffer);\n        const nRef = dataView.getInt32(start, true);\n        let p = start + 4;\n        const chrToIndex = {};\n        const indexToChr = [];\n        const decoder = new TextDecoder('utf8');\n        for (let i = 0; i < nRef; i += 1) {\n            const lName = dataView.getInt32(p, true);\n            const refName = this.renameRefSeq(decoder.decode(uncba.subarray(p + 4, p + 4 + lName - 1)));\n            const lRef = dataView.getInt32(p + lName + 4, true);\n            chrToIndex[refName] = i;\n            indexToChr.push({ refName, length: lRef });\n            p = p + 8 + lName;\n            if (p > uncba.length) {\n                console.warn(`BAM header is very big.  Re-fetching ${refSeqBytes} bytes.`);\n                return this._readRefSeqs(start, refSeqBytes * 2, opts);\n            }\n        }\n        return { chrToIndex, indexToChr };\n    }\n    async getRecordsForRange(chr, min, max, opts) {\n        return gen2array(this.streamRecordsForRange(chr, min, max, opts));\n    }\n    async *streamRecordsForRange(chr, min, max, opts) {\n        await this.getHeader(opts);\n        const chrId = this.chrToIndex?.[chr];\n        if (chrId === undefined || !this.index) {\n            yield [];\n        }\n        else {\n            const chunks = await this.index.blocksForRange(chrId, min - 1, max, opts);\n            yield* this._fetchChunkFeatures(chunks, chrId, min, max, opts);\n        }\n    }\n    async *_fetchChunkFeatures(chunks, chrId, min, max, opts = {}) {\n        const { viewAsPairs } = opts;\n        const feats = [];\n        let done = false;\n        for (const chunk of chunks) {\n            const { data, cpositions, dpositions } = await this._readChunk({\n                chunk,\n                opts,\n            });\n            const records = await this.readBamFeatures(data, cpositions, dpositions, chunk);\n            const recs = [];\n            for (const feature of records) {\n                if (feature.ref_id === chrId) {\n                    if (feature.start >= max) {\n                        // past end of range, can stop iterating\n                        done = true;\n                        break;\n                    }\n                    else if (feature.end >= min) {\n                        // must be in range\n                        recs.push(feature);\n                    }\n                }\n            }\n            feats.push(recs);\n            yield recs;\n            if (done) {\n                break;\n            }\n        }\n        checkAbortSignal(opts.signal);\n        if (viewAsPairs) {\n            yield this.fetchPairs(chrId, feats, opts);\n        }\n    }\n    async fetchPairs(chrId, feats, opts) {\n        const { pairAcrossChr, maxInsertSize = 200000 } = opts;\n        const unmatedPairs = {};\n        const readIds = {};\n        feats.map(ret => {\n            const readNames = {};\n            for (const element of ret) {\n                const name = element.name;\n                const id = element.id;\n                if (!readNames[name]) {\n                    readNames[name] = 0;\n                }\n                readNames[name]++;\n                readIds[id] = 1;\n            }\n            for (const [k, v] of Object.entries(readNames)) {\n                if (v === 1) {\n                    unmatedPairs[k] = true;\n                }\n            }\n        });\n        const matePromises = [];\n        feats.map(ret => {\n            for (const f of ret) {\n                const name = f.name;\n                const start = f.start;\n                const pnext = f.next_pos;\n                const rnext = f.next_refid;\n                if (this.index &&\n                    unmatedPairs[name] &&\n                    (pairAcrossChr ||\n                        (rnext === chrId && Math.abs(start - pnext) < maxInsertSize))) {\n                    matePromises.push(this.index.blocksForRange(rnext, pnext, pnext + 1, opts));\n                }\n            }\n        });\n        // filter out duplicate chunks (the blocks are lists of chunks, blocks are\n        // concatenated, then filter dup chunks)\n        const map = new Map();\n        const res = await Promise.all(matePromises);\n        for (const m of res.flat()) {\n            if (!map.has(m.toString())) {\n                map.set(m.toString(), m);\n            }\n        }\n        const mateFeatPromises = await Promise.all([...map.values()].map(async (c) => {\n            const { data, cpositions, dpositions, chunk } = await this._readChunk({\n                chunk: c,\n                opts,\n            });\n            const mateRecs = [];\n            for (const feature of await this.readBamFeatures(data, cpositions, dpositions, chunk)) {\n                if (unmatedPairs[feature.name] && !readIds[feature.id]) {\n                    mateRecs.push(feature);\n                }\n            }\n            return mateRecs;\n        }));\n        return mateFeatPromises.flat();\n    }\n    async _readChunk({ chunk, opts }) {\n        const buf = await this.bam.read(chunk.fetchedSize(), chunk.minv.blockPosition, opts);\n        const { buffer: data, cpositions, dpositions, } = await unzipChunkSlice(buf, chunk, this.cache);\n        return { data, cpositions, dpositions, chunk };\n    }\n    async readBamFeatures(ba, cpositions, dpositions, chunk) {\n        let blockStart = 0;\n        const sink = [];\n        let pos = 0;\n        let last = Date.now();\n        const dataView = new DataView(ba.buffer);\n        while (blockStart + 4 < ba.length) {\n            const blockSize = dataView.getInt32(blockStart, true);\n            const blockEnd = blockStart + 4 + blockSize - 1;\n            // increment position to the current decompressed status\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (dpositions) {\n                while (blockStart + chunk.minv.dataPosition >= dpositions[pos++]) { }\n                pos--;\n            }\n            // only try to read the feature if we have all the bytes for it\n            if (blockEnd < ba.length) {\n                const feature = new BAMFeature({\n                    bytes: {\n                        byteArray: ba,\n                        start: blockStart,\n                        end: blockEnd,\n                    },\n                    // the below results in an automatically calculated file-offset based\n                    // ID if the info for that is available, otherwise crc32 of the\n                    // features\n                    //\n                    // cpositions[pos] refers to actual file offset of a bgzip block\n                    // boundaries\n                    //\n                    // we multiply by (1 <<8) in order to make sure each block has a\n                    // \"unique\" address space so that data in that block could never\n                    // overlap\n                    //\n                    // then the blockStart-dpositions is an uncompressed file offset from\n                    // that bgzip block boundary, and since the cpositions are multiplied\n                    // by (1 << 8) these uncompressed offsets get a unique space\n                    //\n                    // this has an extra chunk.minv.dataPosition added on because it\n                    // blockStart starts at 0 instead of chunk.minv.dataPosition\n                    //\n                    // the +1 is just to avoid any possible uniqueId 0 but this does not\n                    // realistically happen\n                    fileOffset: cpositions.length > 0\n                        ? cpositions[pos] * (1 << 8) +\n                            (blockStart - dpositions[pos]) +\n                            chunk.minv.dataPosition +\n                            1\n                        : // this shift >>> 0 is equivalent to crc32(b).unsigned but uses the\n                            // internal calculator of crc32 to avoid accidentally importing buffer\n                            // https://github.com/alexgorbatchev/crc/blob/31fc3853e417b5fb5ec83335428805842575f699/src/define_crc.ts#L5\n                            crc32(ba.subarray(blockStart, blockEnd)) >>> 0,\n                });\n                sink.push(feature);\n                if (this.yieldThreadTime && Date.now() - last > this.yieldThreadTime) {\n                    await timeout(1);\n                    last = Date.now();\n                }\n            }\n            blockStart = blockEnd + 1;\n        }\n        return sink;\n    }\n    async hasRefSeq(seqName) {\n        const seqId = this.chrToIndex?.[seqName];\n        return seqId === undefined ? false : this.index?.hasRefSeq(seqId);\n    }\n    async lineCount(seqName) {\n        const seqId = this.chrToIndex?.[seqName];\n        return seqId === undefined || !this.index ? 0 : this.index.lineCount(seqId);\n    }\n    async indexCov(seqName, start, end) {\n        if (!this.index) {\n            return [];\n        }\n        await this.index.parse();\n        const seqId = this.chrToIndex?.[seqName];\n        return seqId === undefined ? [] : this.index.indexCov(seqId, start, end);\n    }\n    async blocksForRange(seqName, start, end, opts) {\n        if (!this.index) {\n            return [];\n        }\n        await this.index.parse();\n        const seqId = this.chrToIndex?.[seqName];\n        return seqId === undefined\n            ? []\n            : this.index.blocksForRange(seqId, start, end, opts);\n    }\n}\n//# sourceMappingURL=bamFile.js.map","import { getMismatches } from '../MismatchParser';\nimport { cacheGetter } from '../shared/util';\nexport default class BamSlightlyLazyFeature {\n    constructor(record, adapter, ref) {\n        this.record = record;\n        this.adapter = adapter;\n        this.ref = ref;\n    }\n    id() {\n        return `${this.adapter.id}-${this.record.id}`;\n    }\n    get mismatches() {\n        return getMismatches(this.record.CIGAR, this.record.tags.MD, this.record.seq, this.ref, this.record.qual);\n    }\n    get qual() {\n        var _a;\n        return (_a = this.record.qual) === null || _a === void 0 ? void 0 : _a.join(' ');\n    }\n    get(field) {\n        return field === 'mismatches'\n            ? this.mismatches\n            : field === 'qual'\n                ? this.qual\n                : this.fields[field];\n    }\n    parent() {\n        return undefined;\n    }\n    children() {\n        return undefined;\n    }\n    get fields() {\n        const r = this.record;\n        const a = this.adapter;\n        const p = r.isPaired();\n        return {\n            start: r.start,\n            name: r.name,\n            end: r.end,\n            score: r.score,\n            strand: r.strand,\n            template_length: r.template_length,\n            flags: r.flags,\n            tags: r.tags,\n            refName: a.refIdToName(r.ref_id),\n            CIGAR: r.CIGAR,\n            seq: r.seq,\n            type: 'match',\n            pair_orientation: r.pair_orientation,\n            next_ref: p ? a.refIdToName(r.next_refid) : undefined,\n            next_pos: p ? r.next_pos : undefined,\n            next_segment_position: p\n                ? `${a.refIdToName(r.next_refid)}:${r.next_pos + 1}`\n                : undefined,\n            uniqueId: this.id(),\n        };\n    }\n    toJSON() {\n        return {\n            ...this.fields,\n            qual: this.qual,\n        };\n    }\n}\ncacheGetter(BamSlightlyLazyFeature, 'fields');\ncacheGetter(BamSlightlyLazyFeature, 'mismatches');\n","import { BamFile } from '@gmod/bam';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { bytesForRegions, updateStatus } from '@jbrowse/core/util';\nimport QuickLRU from '@jbrowse/core/util/QuickLRU';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { checkStopToken } from '@jbrowse/core/util/stopToken';\nimport { firstValueFrom } from 'rxjs';\nimport { toArray } from 'rxjs/operators';\nimport BamSlightlyLazyFeature from './BamSlightlyLazyFeature';\nimport { filterReadFlag, filterTagValue } from '../shared/util';\nexport default class BamAdapter extends BaseFeatureDataAdapter {\n    constructor() {\n        super(...arguments);\n        this.ultraLongFeatureCache = new QuickLRU({\n            maxSize: 500,\n        });\n    }\n    async configurePre() {\n        const bamLocation = this.getConf('bamLocation');\n        const location = this.getConf(['index', 'location']);\n        const indexType = this.getConf(['index', 'indexType']);\n        const pm = this.pluginManager;\n        const csi = indexType === 'CSI';\n        const bam = new BamFile({\n            bamFilehandle: openLocation(bamLocation, pm),\n            csiFilehandle: csi ? openLocation(location, pm) : undefined,\n            baiFilehandle: !csi ? openLocation(location, pm) : undefined,\n            yieldThreadTime: Number.POSITIVE_INFINITY,\n        });\n        const adapterConfig = this.getConf('sequenceAdapter');\n        if (adapterConfig && this.getSubAdapter) {\n            const { dataAdapter } = await this.getSubAdapter(adapterConfig);\n            return {\n                bam,\n                sequenceAdapter: dataAdapter,\n            };\n        }\n        return { bam };\n    }\n    async configure() {\n        if (!this.configureP) {\n            this.configureP = this.configurePre().catch((e) => {\n                this.configureP = undefined;\n                throw e;\n            });\n        }\n        return this.configureP;\n    }\n    async getHeader(_opts) {\n        const { bam } = await this.configure();\n        return bam.getHeaderText();\n    }\n    async setupPre(_opts) {\n        const { bam } = await this.configure();\n        const samHeader = await bam.getHeader();\n        const idToName = [];\n        const nameToId = {};\n        if (samHeader) {\n            for (const [refId, sqLine] of samHeader\n                .filter(l => l.tag === 'SQ')\n                .entries()) {\n                const SN = sqLine.data.find(item => item.tag === 'SN');\n                if (SN) {\n                    const refName = SN.value;\n                    nameToId[refName] = refId;\n                    idToName[refId] = refName;\n                }\n            }\n        }\n        this.samHeader = { idToName, nameToId };\n        return this.samHeader;\n    }\n    async setupPre2(opts) {\n        if (!this.setupP) {\n            this.setupP = this.setupPre(opts).catch((e) => {\n                this.setupP = undefined;\n                throw e;\n            });\n        }\n        return this.setupP;\n    }\n    async setup(opts) {\n        const { statusCallback = () => { } } = opts || {};\n        return updateStatus('Downloading index', statusCallback, () => this.setupPre2(opts));\n    }\n    async getRefNames(opts) {\n        const { idToName } = await this.setup(opts);\n        return idToName;\n    }\n    async seqFetch(refName, start, end) {\n        const { sequenceAdapter } = await this.configure();\n        const refSeqStore = sequenceAdapter;\n        if (!refSeqStore) {\n            return undefined;\n        }\n        if (!refName) {\n            return undefined;\n        }\n        const features = refSeqStore.getFeatures({\n            refName,\n            start,\n            end,\n            assemblyName: '',\n        });\n        const seqChunks = await firstValueFrom(features.pipe(toArray()));\n        let sequence = '';\n        for (const chunk of seqChunks.sort((a, b) => a.get('start') - b.get('start'))) {\n            const chunkStart = chunk.get('start');\n            const chunkEnd = chunk.get('end');\n            const trimStart = Math.max(start - chunkStart, 0);\n            const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart);\n            const trimLength = trimEnd - trimStart;\n            const chunkSeq = chunk.get('seq') || chunk.get('residues');\n            sequence += chunkSeq.slice(trimStart, trimStart + trimLength);\n        }\n        if (sequence.length !== end - start) {\n            throw new Error(`sequence fetch failed: fetching ${refName}:${(start - 1).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(end - start).toLocaleString()}`);\n        }\n        return sequence;\n    }\n    getFeatures(region, opts) {\n        const { refName, start, end, originalRefName } = region;\n        const { stopToken, filterBy, statusCallback = () => { } } = opts || {};\n        return ObservableCreate(async (observer) => {\n            const { bam } = await this.configure();\n            await this.setup(opts);\n            checkStopToken(stopToken);\n            const records = await updateStatus('Downloading alignments', statusCallback, () => bam.getRecordsForRange(refName, start, end));\n            checkStopToken(stopToken);\n            await updateStatus('Processing alignments', statusCallback, async () => {\n                const { flagInclude = 0, flagExclude = 0, tagFilter, readName, } = filterBy || {};\n                for (const record of records) {\n                    let ref;\n                    if (!record.tags.MD) {\n                        ref = await this.seqFetch(originalRefName || refName, record.start, record.end);\n                    }\n                    if (filterReadFlag(record.flags, flagInclude, flagExclude)) {\n                        continue;\n                    }\n                    if (tagFilter &&\n                        filterTagValue(record.tags[tagFilter.tag], tagFilter.value)) {\n                        continue;\n                    }\n                    if (readName && record.name !== readName) {\n                        continue;\n                    }\n                    const ret = this.ultraLongFeatureCache.get(`${record.id}`);\n                    if (!ret) {\n                        const elt = new BamSlightlyLazyFeature(record, this, ref);\n                        this.ultraLongFeatureCache.set(`${record.id}`, elt);\n                        observer.next(elt);\n                    }\n                    else {\n                        observer.next(ret);\n                    }\n                }\n                observer.complete();\n            });\n        });\n    }\n    async getMultiRegionFeatureDensityStats(regions, opts) {\n        const { bam } = await this.configure();\n        if (bam.index) {\n            const bytes = await bytesForRegions(regions, bam);\n            const fetchSizeLimit = this.getConf('fetchSizeLimit');\n            return { bytes, fetchSizeLimit };\n        }\n        return super.getMultiRegionFeatureDensityStats(regions, opts);\n    }\n    refIdToName(refId) {\n        var _a;\n        return (_a = this.samHeader) === null || _a === void 0 ? void 0 : _a.idToName[refId];\n    }\n}\n"],"names":["Chunk","minv","maxv","bin","_fetchedSize","b","IndexFile","filehandle","renameRefSeq","TWO_PWR_16_DBL","TWO_PWR_32_DBL","longFromBytesToUnsigned","source","i","low","timeout","ms","resolve","checkAbortSignal","signal","e","canMergeBlocks","chunk1","chunk2","makeOpts","obj","optimizeChunks","chunks","lowest","mergedChunks","lastChunk","c0","c1","dif","chunk","parsePseudoBin","bytes","offset","findFirstData","firstDataLine","virtualOffset","parseNameBytes","namesBytes","s","currRefId","currNameStart","refIdToName","refNameToId","refName","j","sum","array","entry","concatUint8Array","args","mergedArray","gen2array","gen","out","x","VirtualOffset","blockPosition","dataPosition","fromBytes","bigendian","BAI_MAGIC","roundDown","n","multiple","roundUp","reg2bins","beg","end","BAI","refId","opts","_b","_a","_opts","dataView","refCount","binLimit","curr","offsets","binCount","chunkCount","k","linearCount","linearIndex","indicesCache","QuickLRU","getIndices","stats","binIndex","u","v","result","seqId","start","range","seqIdx","depths","totalSize","currentPos","d","min","max","indexData","ba","overlappingBins","binChunks","binChunk","nintv","minLin","maxLin","vp","totalLength","unzip","inputData","strm","pos","inflator","blocks","remainingInput","Inflate","Z_SYNC_FLUSH","unzipChunkSlice","blockCache","cpos","dpos","cpositions","dpositions","wasFromCache","cacheKey","buffer","nextIn","cached","len","origCpos","CSI1_MAGIC","CSI2_MAGIC","lshift","num","bits","rshift","CSI","formatFlags","coordinateType","format","columnNumbers","metaValue","metaChar","skipLines","nameSectionLength","csiVersion","magic","maxBinNumber","auxLength","aux","pseudoBinStats","c","l","t","bins","NullFilehandle","Constants","__classPrivateFieldSet","receiver","state","value","kind","f","__classPrivateFieldGet","_BamRecord_dataView","SEQRET_DECODER","CIGAR_DECODER","BamRecord","mq","p","str","blockEnd","tags","tag","type","cc","Btype","limit","cigop","lop","op","numCigarOps","CIGAR","lref","seqBytes","buf","sb","s1","s2","o1","o2","tmp","idx","byteIndex","data","cacheGetter","ctor","prop","desc","getter","ret","parseHeaderText","text","lines","line","fields","r","fieldTag","BAM_MAGIC","blockLen","BamFile","bamFilehandle","bamPath","bamUrl","baiPath","baiFilehandle","baiUrl","csiPath","csiFilehandle","csiUrl","htsget","yieldThreadTime","renameRefSeqs","LocalFile","RemoteFile","origOpts","uncba","headLen","decoder","chrToIndex","indexToChr","refSeqBytes","nRef","lName","lRef","chr","chrId","viewAsPairs","feats","done","records","recs","feature","pairAcrossChr","maxInsertSize","unmatedPairs","readIds","readNames","element","name","id","matePromises","pnext","rnext","map","res","m","mateRecs","blockStart","sink","last","blockSize","BAMFeature","crc32","seqName","BamSlightlyLazyFeature","record","adapter","ref","getMismatches","field","a","BamAdapter","BaseFeatureDataAdapter","bamLocation","location","indexType","pm","csi","bam","openLocation","adapterConfig","dataAdapter","samHeader","idToName","nameToId","sqLine","SN","item","statusCallback","updateStatus","sequenceAdapter","refSeqStore","features","seqChunks","firstValueFrom","toArray","sequence","chunkStart","chunkEnd","trimStart","trimLength","chunkSeq","region","originalRefName","stopToken","filterBy","ObservableCreate","observer","checkStopToken","flagInclude","flagExclude","tagFilter","readName","filterReadFlag","filterTagValue","elt","regions","bytesForRegions","fetchSizeLimit"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]}