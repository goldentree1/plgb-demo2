import{A as _}from"./AbortablePromiseCache-Bzbqdtb1.js";import{L as h}from"./browser-DdKr-yeI.js";import{B as F}from"./index-DYe7vadA.js";import{i as l,u as S,s as L}from"./rpcWorker-X0469dqW.js";import{Q as k}from"./QuickLRU-DUYJ4zPh.js";import{r as z}from"./rxjs-DQbUCOsY.js";function q(r,e){return r.offset+r.lineBytes*Math.floor(e/r.lineLength)+e%r.lineLength}async function A(r,e={}){const s=new TextDecoder("utf8");return Object.fromEntries(s.decode(await r.readFile(e)).split(/\r?\n/).map(t=>t.trim()).filter(t=>!!t).map(t=>t.split("	")).map(t=>{var n;if((n=t[0])!=null&&n.startsWith(">"))throw new Error("found > in sequence name, might have supplied FASTA file for the FASTA index");return[t[0],{name:t[0],length:+t[1],start:0,end:+t[1],offset:+t[2],lineLength:+t[3],lineBytes:+t[4]}]}))}class E{constructor({fasta:e,fai:s,path:t,faiPath:n}){if(e)this.fasta=e;else if(t)this.fasta=new h(t);else throw new Error("Need to pass filehandle for fasta or path to localfile");if(s)this.fai=s;else if(n)this.fai=new h(n);else if(t)this.fai=new h(`${t}.fai`);else throw new Error("Need to pass filehandle for  or path to localfile")}async _getIndexes(e){return this.indexes||(this.indexes=A(this.fai,e).catch(s=>{throw this.indexes=void 0,s})),this.indexes}async getSequenceNames(e){return Object.keys(await this._getIndexes(e))}async getSequenceSizes(e){const s={},t=await this._getIndexes(e);for(const n of Object.values(t))s[n.name]=n.length;return s}async getSequenceSize(e,s){var n;return(n=(await this._getIndexes(s))[e])==null?void 0:n.length}async hasReferenceSequence(e,s){return!!(await this._getIndexes(s))[e]}async getResiduesByName(e,s,t,n){const a=(await this._getIndexes(n))[e];return a?this._fetchFromIndexEntry(a,s,t,n):void 0}async getSequence(e,s,t,n){return this.getResiduesByName(e,s,t,n)}async _fetchFromIndexEntry(e,s=0,t,n){let a=t;if(s<0)throw new TypeError("regionStart cannot be less than 0");if((a===void 0||a>e.length)&&(a=e.length),s>=a)return"";const i=q(e,s),o=q(e,a)-i,f=new TextDecoder("utf8").decode(await this.fasta.read(o,i,n)).replace(/\s+/g,"");if(/[^\x20-\x7e]/.test(f.slice(0,1e3)))throw new Error("Non-ASCII characters detected in sequence. The file may be gzip compressed. Use BgzipIndexedFasta for bgzip files, or decompress the file.");return f}}class N extends F.BaseSequenceAdapter{constructor(){super(...arguments),this.seqCache=new _({cache:new k({maxSize:200}),fill:async e=>{const{refName:s,start:t,end:n,fasta:a}=e;return a.getSequence(s,t,n)}})}async getRefNames(e){const{fasta:s}=await this.setup();return s.getSequenceNames()}async getRegions(e){const{fasta:s}=await this.setup(),t=await s.getSequenceSizes();return Object.keys(t).map(n=>({refName:n,start:0,end:t[n]}))}async setupPre(){const e=this.getConf("fastaLocation"),s=this.getConf("faiLocation");return{fasta:new E({fasta:l.openLocation(e,this.pluginManager),fai:l.openLocation(s,this.pluginManager)})}}async getHeader(){const e=this.getConf("metadataLocation");return e.uri===""||e.uri==="/path/to/fa.metadata.yaml"?null:l.openLocation(e,this.pluginManager).readFile("utf8")}async setup(){return this.setupP||(this.setupP=this.setupPre().catch(e=>{throw this.setupP=void 0,e})),this.setupP}getFeatures(e,s){const{statusCallback:t=()=>{},stopToken:n}=s||{},{refName:a,start:i,end:o}=e;return z.ObservableCreate(async d=>{await S.updateStatus2("Downloading sequence",t,n,async()=>{const{fasta:f}=await this.setup(),I=await f.getSequenceSize(a),p=Math.min(I||0,o),g=[],u=128e3,m=i-i%u,b=o+(u-o%u);for(let c=m;c<b;c+=u){const x={refName:a,start:c,end:c+u};L.checkStopToken(n);const y=await this.seqCache.get(JSON.stringify(x),{...x,fasta:f});if(!y)break;g.push(y)}const w=g.filter(c=>!!c).join("").slice(i-m).slice(0,o-i);w&&d.next(new S.SimpleFeature({id:`${a}-${i}-${p}`,data:{refName:a,start:i,end:p,seq:w}}))}),d.complete()})}}var R=Object.freeze({__proto__:null,default:N});export{E as I,N as a,R as b};
//# sourceMappingURL=IndexedFastaAdapter-D-0TG96d.js.map
