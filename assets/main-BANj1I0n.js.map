{"version":3,"file":"main-BANj1I0n.js","sources":["../../node_modules/@flatten-js/interval-tree/dist/main.mjs"],"sourcesContent":["/**\n * Created by Alex Bol on 4/1/2017.\n */\n// Abstract base for intervals. Concrete variants extend this.\nclass IntervalBase {\n    constructor(low, high) {\n        this.low = low;\n        this.high = high;\n    }\n    get max() {\n        return this.clone();\n    }\n    // Default numeric/date comparison (lexicographic by low then high)\n    less_than(other_interval) {\n        return this.low < other_interval.low ||\n            (this.low === other_interval.low && this.high < other_interval.high);\n    }\n    equal_to(other_interval) {\n        return this.low === other_interval.low && this.high === other_interval.high;\n    }\n    intersect(other_interval) {\n        return !this.not_intersect(other_interval);\n    }\n    not_intersect(other_interval) {\n        return (this.high < other_interval.low || other_interval.high < this.low);\n    }\n    merge(other_interval) {\n        // By default choose min low, max high using < and >\n        const low = (this.low === undefined)\n            ? other_interval.low\n            : ((this.low < other_interval.low) ? this.low : other_interval.low);\n        const high = (this.high === undefined)\n            ? other_interval.high\n            : ((this.high > other_interval.high) ? this.high : other_interval.high);\n        // Return instance of the same concrete class\n        const cloned = this.clone();\n        cloned.low = low;\n        cloned.high = high;\n        return cloned;\n    }\n    output() {\n        return [this.low, this.high];\n    }\n    // Instance-level comparator so child classes can customize value comparison semantics\n    comparable_less_than(val1, val2) {\n        return val1 < val2;\n    }\n}\n// 1D numeric/date interval (default)\nclass Interval extends IntervalBase {\n    clone() {\n        return new Interval(this.low, this.high);\n    }\n}\n// 2D interval with lexicographic comparison for points [x, y]\nclass Interval2D extends IntervalBase {\n    constructor(low, high) {\n        super(low, high);\n    }\n    static pointLess(a, b) {\n        return a[0] < b[0] || (a[0] === b[0] && a[1] < b[1]);\n    }\n    static pointEq(a, b) {\n        return a[0] === b[0] && a[1] === b[1];\n    }\n    clone() {\n        return new Interval2D(this.low, this.high);\n    }\n    less_than(other) {\n        const a = this.low;\n        const b = other.low;\n        if (Interval2D.pointLess(a, b))\n            return true;\n        if (Interval2D.pointEq(a, b)) {\n            const ah = this.high;\n            const bh = other.high;\n            return Interval2D.pointLess(ah, bh);\n        }\n        return false;\n    }\n    equal_to(other) {\n        return Interval2D.pointEq(this.low, other.low) &&\n            Interval2D.pointEq(this.high, other.high);\n    }\n    not_intersect(other) {\n        // Non-intersection in lexicographic 2D ordering (simplistic): treat ranges in the ordered space\n        const highLess = Interval2D.pointLess(this.high, other.low);\n        const otherHighLess = Interval2D.pointLess(other.high, this.low);\n        return highLess || otherHighLess;\n    }\n    merge(other) {\n        const lowA = this.low;\n        const lowB = other.low;\n        const highA = this.high;\n        const highB = other.high;\n        const low = Interval2D.pointLess(lowA, lowB) ? lowA : lowB;\n        const high = Interval2D.pointLess(highA, highB) ? highB : highA;\n        return new Interval2D(low, high);\n    }\n    // Override value comparator to handle 2D points lexicographically\n    comparable_less_than(val1, val2) {\n        return Interval2D.pointLess(val1, val2);\n    }\n    output() {\n        return [this.low, this.high];\n    }\n}\n\n/**\n * Created by Alex Bol on 3/28/2017.\n */\n// module.exports = {\n//     RB_TREE_COLOR_RED: 0,\n//     RB_TREE_COLOR_BLACK: 1\n// };\n/**\n * Red-Black Tree color constants\n */\nconst RB_TREE_COLOR_RED = 1;\nconst RB_TREE_COLOR_BLACK = 0;\n\n/**\n * Created by Alex Bol on 4/1/2017.\n */\nclass Node {\n    constructor(key, value, left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\n        this.left = left;\n        this.right = right;\n        this.parent = parent;\n        this.color = color;\n        this.item = { key: undefined, values: [] };\n        if (value !== undefined) {\n            this.item.values.push(value);\n        }\n        // Initialize key if provided\n        if (key !== undefined) {\n            if (Array.isArray(key)) {\n                const [rawLow, rawHigh] = key;\n                if (!Number.isNaN(rawLow) && !Number.isNaN(rawHigh)) {\n                    let low = rawLow;\n                    let high = rawHigh;\n                    if (low > high)\n                        [low, high] = [high, low];\n                    this.item.key = new Interval(low, high);\n                }\n            }\n            else {\n                // Assume a concrete IntervalBase implementation was passed\n                this.item.key = key;\n            }\n        }\n        this.max = this.item.key ? this.item.key.max : undefined;\n    }\n    isNil() {\n        return (this.item.key === undefined &&\n            this.item.values.length === 0 &&\n            this.left === null &&\n            this.right === null &&\n            this.color === RB_TREE_COLOR_BLACK);\n    }\n    requireKey() {\n        if (!this.item.key) {\n            throw new Error('Node key is undefined (nil/sentinel). Operation is not applicable.');\n        }\n        return this.item.key;\n    }\n    less_than(other_node) {\n        // Compare nodes by key only; values are stored in a bucket\n        const a = this.requireKey();\n        const b = other_node.requireKey();\n        return a.less_than(b);\n    }\n    _value_equal(other_node) {\n        // Deprecated in bucket mode; kept for backward compatibility if ever used\n        // Compare first elements if exist\n        const a = this.item.values[0];\n        const b = other_node.item.values[0];\n        return a && b && a.equal_to ? a.equal_to(b) : a === b;\n    }\n    equal_to(other_node) {\n        // Nodes are equal if keys are equal; values are kept in a bucket\n        const a = this.requireKey();\n        const b = other_node.requireKey();\n        return a.equal_to(b);\n    }\n    intersect(other_node) {\n        const a = this.requireKey();\n        const b = other_node.requireKey();\n        return a.intersect(b);\n    }\n    copy_data(other_node) {\n        this.item.key = other_node.item.key;\n        this.item.values = other_node.item.values.slice();\n    }\n    update_max() {\n        // use key (Interval) max property instead of key.high\n        this.max = this.item.key ? this.item.key.max : undefined;\n        if (this.right && this.right.max) {\n            this.max = this.max ? this.max.merge(this.right.max) : this.right.max;\n        }\n        if (this.left && this.left.max) {\n            this.max = this.max ? this.max.merge(this.left.max) : this.left.max;\n        }\n    }\n    // Other_node does not intersect any node of left subtree\n    not_intersect_left_subtree(search_node) {\n        if (!this.left)\n            return true;\n        const high = this.left.max ? this.left.max.high : this.left.item.key.high;\n        const selfKey = this.requireKey();\n        const searchKey = search_node.requireKey();\n        return selfKey.comparable_less_than(high, searchKey.low);\n    }\n    // Other_node does not intersect right subtree\n    not_intersect_right_subtree(search_node) {\n        if (!this.right)\n            return true;\n        const low = this.right.max ? this.right.max.low : this.right.item.key.low;\n        const selfKey = this.requireKey();\n        const searchKey = search_node.requireKey();\n        return selfKey.comparable_less_than(searchKey.high, low);\n    }\n}\n\n/**\n * Created by Alex Bol on 3/31/2017.\n */\n/**\n * Implementation of interval binary search tree\n * Interval tree stores items which are couples of {key:interval, value: value}\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values\n */\nclass IntervalTree {\n    /**\n     * Construct new empty instance of IntervalTree\n     */\n    constructor() {\n        this.root = null;\n        this.nil_node = new Node();\n    }\n    /**\n     * Returns number of items stored in the interval tree\n     * @returns {number}\n     */\n    get size() {\n        let count = 0;\n        this.tree_walk(this.root, (node) => count += node.item.values.length);\n        return count;\n    }\n    /**\n     * Returns array of sorted keys in the ascending order\n     * @returns {Array}\n     */\n    get keys() {\n        const res = [];\n        this.tree_walk(this.root, (node) => res.push(node.item.key.output()));\n        return res;\n    }\n    /**\n     * Return array of values in the ascending keys order\n     * @returns {Array}\n     */\n    get values() {\n        const res = [];\n        this.tree_walk(this.root, (node) => {\n            for (const v of node.item.values)\n                res.push(v);\n        });\n        return res;\n    }\n    /**\n     * Returns array of items (<key,value> pairs) in the ascended keys order\n     * @returns {Array}\n     */\n    get items() {\n        const res = [];\n        this.tree_walk(this.root, (node) => {\n            const keyOut = node.item.key.output();\n            for (const v of node.item.values) {\n                res.push({ key: keyOut, value: v });\n            }\n        });\n        return res;\n    }\n    /**\n     * Returns true if tree is empty\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this.root == null || this.root === this.nil_node;\n    }\n    /**\n     * Clear tree\n     */\n    clear() {\n        this.root = null;\n    }\n    /**\n     * Insert new item into interval tree\n     * @param key - interval object or array of two numbers [low, high]\n     * @param value - value representing any object (optional)\n     * @returns returns reference to inserted node\n     */\n    insert(key, value = key) {\n        if (key === undefined)\n            return;\n        // If node with the same key exists, append value to its bucket\n        const existing = this.tree_search(this.root, new Node(key));\n        if (existing) {\n            existing.item.values.push(value);\n            return existing;\n        }\n        const insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);\n        this.tree_insert(insert_node);\n        this.recalc_max(insert_node);\n        return insert_node;\n    }\n    /**\n     * Returns true if item {key,value} exist in the tree\n     * @param key - interval correspondent to keys stored in the tree\n     * @param value - value object to be checked\n     * @returns true if item {key, value} exist in the tree, false otherwise\n     */\n    exist(key, value = key) {\n        const node = this.tree_search(this.root, new Node(key));\n        if (!node)\n            return false;\n        // If value is omitted (or equals key by default), treat as key existence\n        if (arguments.length < 2 || value === key)\n            return true;\n        // Check if value exists in the bucket\n        return node.item.values.some((v) => (v && v.equal_to ? v.equal_to(value) : v === value));\n    }\n    /**\n     * Remove entry {key, value} from the tree\n     * @param key - interval correspondent to keys stored in the tree\n     * @param value - value object\n     * @returns deleted node or undefined if not found\n     */\n    remove(key, value = key) {\n        const node = this.tree_search(this.root, new Node(key));\n        if (!node)\n            return undefined;\n        // If value omitted, remove entire node\n        if (arguments.length < 2) {\n            this.tree_delete(node);\n            return node;\n        }\n        // Remove one matching value from bucket\n        const idx = node.item.values.findIndex((v) => (v && v.equal_to ? v.equal_to(value) : v === value));\n        if (idx >= 0) {\n            node.item.values.splice(idx, 1);\n            // If bucket is now empty, remove node from tree\n            if (node.item.values.length === 0) {\n                this.tree_delete(node);\n            }\n            return node;\n        }\n        return undefined;\n    }\n    search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\n        const search_node = new Node(interval);\n        const resp_nodes = [];\n        this.tree_search_interval(this.root, search_node, resp_nodes);\n        const res = [];\n        for (const node of resp_nodes) {\n            for (const v of node.item.values) {\n                res.push(outputMapperFn(v, node.item.key));\n            }\n        }\n        return res;\n    }\n    /**\n     * Returns true if intersection between given and any interval stored in the tree found\n     * @param interval - search interval or tuple [low, high]\n     * @returns {boolean}\n     */\n    intersect_any(interval) {\n        const search_node = new Node(interval);\n        return this.tree_find_any_interval(this.root, search_node);\n    }\n    /**\n     * Tree visitor. For each node implement a callback function.\n     * Method calls a callback function with two parameters (key, value)\n     * @param visitor - function to be called for each tree item\n     */\n    forEach(visitor) {\n        this.tree_walk(this.root, (node) => {\n            for (const v of node.item.values)\n                visitor(node.item.key, v);\n        });\n    }\n    /**\n     * Value Mapper. Walk through every node and map node value to another value\n     * @param callback - function to be called for each tree item\n     */\n    map(callback) {\n        const tree = new IntervalTree();\n        this.tree_walk(this.root, (node) => {\n            for (const v of node.item.values) {\n                tree.insert(node.item.key, callback(v, node.item.key));\n            }\n        });\n        return tree;\n    }\n    *iterate(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\n        let node = null;\n        if (interval) {\n            node = this.tree_search_nearest_forward(this.root, new Node(interval));\n        }\n        else if (this.root) {\n            node = this.local_minimum(this.root);\n        }\n        while (node) {\n            for (const v of node.item.values) {\n                yield outputMapperFn(v, node.item.key);\n            }\n            node = this.tree_successor(node);\n        }\n    }\n    /**\n     * Recalculate max property upward from given node to root\n     * @param node - starting node\n     */\n    recalc_max(node) {\n        let node_current = node;\n        while (node_current.parent != null) {\n            node_current.parent.update_max();\n            node_current = node_current.parent;\n        }\n    }\n    /**\n     * Insert node into tree and rebalance\n     * @param insert_node - node to insert\n     */\n    tree_insert(insert_node) {\n        let current_node = this.root;\n        let parent_node = null;\n        if (this.root == null || this.root === this.nil_node) {\n            this.root = insert_node;\n        }\n        else {\n            while (current_node !== this.nil_node) {\n                parent_node = current_node;\n                if (insert_node.less_than(current_node)) {\n                    current_node = current_node.left;\n                }\n                else {\n                    current_node = current_node.right;\n                }\n            }\n            insert_node.parent = parent_node;\n            if (insert_node.less_than(parent_node)) {\n                parent_node.left = insert_node;\n            }\n            else {\n                parent_node.right = insert_node;\n            }\n        }\n        this.insert_fixup(insert_node);\n    }\n    /**\n     * Restore red-black tree properties after insertion\n     * @param insert_node - inserted node\n     */\n    insert_fixup(insert_node) {\n        let current_node;\n        let uncle_node;\n        current_node = insert_node;\n        while (current_node !== this.root && current_node.parent.color === RB_TREE_COLOR_RED) {\n            if (current_node.parent === current_node.parent.parent.left) {\n                uncle_node = current_node.parent.parent.right;\n                if (uncle_node.color === RB_TREE_COLOR_RED) {\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {\n                    if (current_node === current_node.parent.right) {\n                        current_node = current_node.parent;\n                        this.rotate_left(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_right(current_node.parent.parent);\n                }\n            }\n            else {\n                uncle_node = current_node.parent.parent.left;\n                if (uncle_node.color === RB_TREE_COLOR_RED) {\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {\n                    if (current_node === current_node.parent.left) {\n                        current_node = current_node.parent;\n                        this.rotate_right(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_left(current_node.parent.parent);\n                }\n            }\n        }\n        this.root.color = RB_TREE_COLOR_BLACK;\n    }\n    /**\n     * Delete node from tree and rebalance\n     * @param delete_node - node to delete\n     */\n    tree_delete(delete_node) {\n        let cut_node;\n        let fix_node;\n        if (delete_node.left === this.nil_node || delete_node.right === this.nil_node) {\n            cut_node = delete_node;\n        }\n        else {\n            cut_node = this.tree_successor(delete_node);\n        }\n        if (cut_node.left !== this.nil_node) {\n            fix_node = cut_node.left;\n        }\n        else {\n            fix_node = cut_node.right;\n        }\n        fix_node.parent = cut_node.parent;\n        if (cut_node === this.root) {\n            this.root = fix_node;\n        }\n        else {\n            if (cut_node === cut_node.parent.left) {\n                cut_node.parent.left = fix_node;\n            }\n            else {\n                cut_node.parent.right = fix_node;\n            }\n            cut_node.parent.update_max();\n        }\n        this.recalc_max(fix_node);\n        if (cut_node !== delete_node) {\n            delete_node.copy_data(cut_node);\n            delete_node.update_max();\n            this.recalc_max(delete_node);\n        }\n        if (cut_node.color === RB_TREE_COLOR_BLACK) {\n            this.delete_fixup(fix_node);\n        }\n    }\n    /**\n     * Restore red-black tree properties after deletion\n     * @param fix_node - node to fix from\n     */\n    delete_fixup(fix_node) {\n        let current_node = fix_node;\n        let brother_node;\n        while (current_node !== this.root &&\n            current_node.parent != null &&\n            current_node.color === RB_TREE_COLOR_BLACK) {\n            if (current_node === current_node.parent.left) {\n                brother_node = current_node.parent.right;\n                if (brother_node.color === RB_TREE_COLOR_RED) {\n                    brother_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_left(current_node.parent);\n                    brother_node = current_node.parent.right;\n                }\n                if (brother_node.left.color === RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color === RB_TREE_COLOR_BLACK) {\n                    brother_node.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent;\n                }\n                else {\n                    if (brother_node.right.color === RB_TREE_COLOR_BLACK) {\n                        brother_node.color = RB_TREE_COLOR_RED;\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;\n                        this.rotate_right(brother_node);\n                        brother_node = current_node.parent.right;\n                    }\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_left(current_node.parent);\n                    current_node = this.root;\n                }\n            }\n            else {\n                brother_node = current_node.parent.left;\n                if (brother_node.color === RB_TREE_COLOR_RED) {\n                    brother_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_right(current_node.parent);\n                    brother_node = current_node.parent.left;\n                }\n                if (brother_node.left.color === RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color === RB_TREE_COLOR_BLACK) {\n                    brother_node.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent;\n                }\n                else {\n                    if (brother_node.left.color === RB_TREE_COLOR_BLACK) {\n                        brother_node.color = RB_TREE_COLOR_RED;\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;\n                        this.rotate_left(brother_node);\n                        brother_node = current_node.parent.left;\n                    }\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_right(current_node.parent);\n                    current_node = this.root;\n                }\n            }\n        }\n        current_node.color = RB_TREE_COLOR_BLACK;\n    }\n    /**\n     * Search for node with given key and value\n     * @param node - starting node\n     * @param search_node - node to search for\n     * @returns found node or undefined\n     */\n    tree_search(node, search_node) {\n        if (node == null || node === this.nil_node)\n            return undefined;\n        if (search_node.equal_to(node)) {\n            return node;\n        }\n        if (search_node.less_than(node)) {\n            return this.tree_search(node.left, search_node);\n        }\n        else {\n            return this.tree_search(node.right, search_node);\n        }\n    }\n    /**\n     * Find nearest forward node from given interval\n     * @param node - starting node\n     * @param search_node - search interval as node\n     * @returns nearest forward node or null\n     */\n    tree_search_nearest_forward(node, search_node) {\n        let best = null;\n        let curr = node;\n        while (curr && curr !== this.nil_node) {\n            if (curr.less_than(search_node)) {\n                if (curr.intersect(search_node)) {\n                    best = curr;\n                    curr = curr.left;\n                }\n                else {\n                    curr = curr.right;\n                }\n            }\n            else {\n                if (!best || curr.less_than(best))\n                    best = curr;\n                curr = curr.left;\n            }\n        }\n        return best || null;\n    }\n    /**\n     * Search all intervals intersecting given interval\n     * @param node - starting node\n     * @param search_node - search interval as node\n     * @param res - result array to collect found nodes\n     */\n    tree_search_interval(node, search_node, res) {\n        if (node != null && node !== this.nil_node) {\n            if (node.left !== this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                this.tree_search_interval(node.left, search_node, res);\n            }\n            if (node.intersect(search_node)) {\n                res.push(node);\n            }\n            if (node.right !== this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                this.tree_search_interval(node.right, search_node, res);\n            }\n        }\n    }\n    /**\n     * Check if any interval intersects with given interval\n     * @param node - starting node\n     * @param search_node - search interval as node\n     * @returns true if intersection found\n     */\n    tree_find_any_interval(node, search_node) {\n        let found = false;\n        if (node != null && node !== this.nil_node) {\n            if (node.left !== this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.left, search_node);\n            }\n            if (!found) {\n                found = node.intersect(search_node);\n            }\n            if (!found && node.right !== this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.right, search_node);\n            }\n        }\n        return found;\n    }\n    /**\n     * Find node with minimum key in subtree\n     * @param node - root of subtree\n     * @returns node with minimum key\n     */\n    local_minimum(node) {\n        let node_min = node;\n        while (node_min.left != null && node_min.left !== this.nil_node) {\n            node_min = node_min.left;\n        }\n        return node_min;\n    }\n    /**\n     * Find node with maximum key in subtree\n     * @param node - root of subtree\n     * @returns node with maximum key\n     */\n    local_maximum(node) {\n        let node_max = node;\n        while (node_max.right != null && node_max.right !== this.nil_node) {\n            node_max = node_max.right;\n        }\n        return node_max;\n    }\n    /**\n     * Find successor node (next in sorted order)\n     * @param node - current node\n     * @returns successor node or null\n     */\n    tree_successor(node) {\n        let node_successor;\n        let current_node;\n        let parent_node;\n        if (node.right !== this.nil_node) {\n            node_successor = this.local_minimum(node.right);\n        }\n        else {\n            current_node = node;\n            parent_node = node.parent;\n            while (parent_node != null && parent_node.right === current_node) {\n                current_node = parent_node;\n                parent_node = parent_node.parent;\n            }\n            node_successor = parent_node;\n        }\n        return node_successor;\n    }\n    /**\n     * Left rotation around node x\n     * @param x - node to rotate\n     */\n    rotate_left(x) {\n        const y = x.right;\n        x.right = y.left;\n        if (y.left !== this.nil_node) {\n            y.left.parent = x;\n        }\n        y.parent = x.parent;\n        if (x === this.root) {\n            this.root = y;\n        }\n        else {\n            if (x === x.parent.left) {\n                x.parent.left = y;\n            }\n            else {\n                x.parent.right = y;\n            }\n        }\n        y.left = x;\n        x.parent = y;\n        if (x !== null && x !== this.nil_node) {\n            x.update_max();\n        }\n        if (y != null && y !== this.nil_node) {\n            y.update_max();\n        }\n    }\n    /**\n     * Right rotation around node y\n     * @param y - node to rotate\n     */\n    rotate_right(y) {\n        const x = y.left;\n        y.left = x.right;\n        if (x.right !== this.nil_node) {\n            x.right.parent = y;\n        }\n        x.parent = y.parent;\n        if (y === this.root) {\n            this.root = x;\n        }\n        else {\n            if (y === y.parent.left) {\n                y.parent.left = x;\n            }\n            else {\n                y.parent.right = x;\n            }\n        }\n        x.right = y;\n        y.parent = x;\n        if (y !== null && y !== this.nil_node) {\n            y.update_max();\n        }\n        if (x != null && x !== this.nil_node) {\n            x.update_max();\n        }\n    }\n    /**\n     * Performs in-order traversal of the tree\n     * Applies action callback to each node in ascending order of keys\n     * @param node - starting node for traversal (typically root)\n     * @param action - callback function to be executed for each node\n     */\n    tree_walk(node, action) {\n        if (node != null && node !== this.nil_node) {\n            this.tree_walk(node.left, action);\n            action(node);\n            this.tree_walk(node.right, action);\n        }\n    }\n    /**\n     * Test red-black tree property: all red nodes have exactly two black child nodes\n     * @returns true if property holds\n     */\n    testRedBlackProperty() {\n        let res = true;\n        this.tree_walk(this.root, function (node) {\n            if (node.color === RB_TREE_COLOR_RED) {\n                if (!(node.left.color === RB_TREE_COLOR_BLACK &&\n                    node.right.color === RB_TREE_COLOR_BLACK)) {\n                    res = false;\n                }\n            }\n        });\n        return res;\n    }\n    /**\n     * Test red-black tree property: every path from root to leaf has same black height\n     * @param node - starting node\n     * @returns black height\n     * @throws Error if property is violated\n     */\n    testBlackHeightProperty(node) {\n        let height = 0;\n        let heightLeft = 0;\n        let heightRight = 0;\n        if (node.color === RB_TREE_COLOR_BLACK) {\n            height++;\n        }\n        if (node.left !== this.nil_node) {\n            heightLeft = this.testBlackHeightProperty(node.left);\n        }\n        else {\n            heightLeft = 1;\n        }\n        if (node.right !== this.nil_node) {\n            heightRight = this.testBlackHeightProperty(node.right);\n        }\n        else {\n            heightRight = 1;\n        }\n        if (heightLeft !== heightRight) {\n            throw new Error('Red-black height property violated');\n        }\n        height += heightLeft;\n        return height;\n    }\n}\n\nexport { Interval, Interval2D, IntervalBase, IntervalTree, Node, IntervalTree as default };\n//# sourceMappingURL=main.mjs.map\n"],"names":["IntervalBase","low","high","other_interval","cloned","val1","val2","Interval","RB_TREE_COLOR_RED","RB_TREE_COLOR_BLACK","Node","key","value","left","right","parent","color","rawLow","rawHigh","other_node","a","b","search_node","selfKey","searchKey","IntervalTree","count","node","res","v","keyOut","existing","insert_node","idx","interval","outputMapperFn","resp_nodes","visitor","callback","tree","node_current","current_node","parent_node","uncle_node","delete_node","cut_node","fix_node","brother_node","best","curr","found","node_min","node_max","node_successor","x","y","action","height","heightLeft","heightRight"],"mappings":"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","x_google_ignoreList":[0]}