{"version":3,"file":"bbi-B3vGekDV.js","sources":["../../node_modules/@gmod/bbi/esm/bigint-polyfill/pure.js","../../node_modules/@gmod/bbi/esm/bigint-polyfill/polyfill.js","../../node_modules/@gmod/bbi/esm/range.js","../../node_modules/@gmod/bbi/esm/unzip.js","../../node_modules/@gmod/bbi/esm/util.js","../../node_modules/@gmod/bbi/esm/block-view.js","../../node_modules/@gmod/bbi/esm/bbi.js"],"sourcesContent":["// from https://github.com/yume-chan/ya-webadb/blob/main/libraries/dataview-bigint-polyfill\n// license:MIT\n// needed for browsers including safari 14\nconst BigInt32 = BigInt(32);\nexport function getBigInt64(dataView, byteOffset, littleEndian) {\n    const littleEndianMask = Number(!!littleEndian);\n    const bigEndianMask = Number(!littleEndian);\n    return ((BigInt(dataView.getInt32(byteOffset, littleEndian) * bigEndianMask +\n        dataView.getInt32(byteOffset + 4, littleEndian) * littleEndianMask) <<\n        BigInt32) |\n        BigInt(dataView.getUint32(byteOffset, littleEndian) * littleEndianMask +\n            dataView.getUint32(byteOffset + 4, littleEndian) * bigEndianMask));\n}\nexport function getBigUint64(dataView, byteOffset, littleEndian) {\n    const a = dataView.getUint32(byteOffset, littleEndian);\n    const b = dataView.getUint32(byteOffset + 4, littleEndian);\n    const littleEndianMask = Number(!!littleEndian);\n    const bigEndianMask = Number(!littleEndian);\n    // This branch-less optimization is 77x faster than normal ternary operator.\n    // and only 3% slower than native implementation\n    // https://jsbench.me/p8kyhg1eqv/1\n    return ((BigInt(a * bigEndianMask + b * littleEndianMask) << BigInt32) |\n        BigInt(a * littleEndianMask + b * bigEndianMask));\n}\n//# sourceMappingURL=pure.js.map","// from https://github.com/yume-chan/ya-webadb/blob/main/libraries/dataview-bigint-polyfill\n// license:MIT\n// needed for browsers including safari 14\nimport { getBigInt64, getBigUint64 } from \"./pure.js\";\nif (!('getBigInt64' in DataView)) {\n    DataView.prototype.getBigInt64 = function (byteOffset, littleEndian) {\n        return getBigInt64(this, byteOffset, littleEndian);\n    };\n}\nif (!('getBigUint64' in DataView)) {\n    DataView.prototype.getBigUint64 = function (byteOffset, littleEndian) {\n        return getBigUint64(this, byteOffset, littleEndian);\n    };\n}\n//# sourceMappingURL=polyfill.js.map","/**\n * Adapted from a combination of Range and _Compound in the\n * Dalliance Genome Explorer, (c) Thomas Down 2006-2010.\n */\nexport default class Range {\n    ranges;\n    constructor(arg1) {\n        this.ranges = arg1;\n    }\n    get min() {\n        return this.ranges[0].min;\n    }\n    get max() {\n        return this.ranges.at(-1).max;\n    }\n    contains(pos) {\n        for (const r of this.ranges) {\n            if (r.min <= pos && r.max >= pos) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isContiguous() {\n        return this.ranges.length > 1;\n    }\n    getRanges() {\n        return this.ranges.map(r => new Range([{ min: r.min, max: r.max }]));\n    }\n    toString() {\n        return this.ranges.map(r => `[${r.min}-${r.max}]`).join(',');\n    }\n    union(s1) {\n        const ranges = [...this.getRanges(), ...s1.getRanges()].sort((a, b) => {\n            if (a.min < b.min) {\n                return -1;\n            }\n            else if (a.min > b.min) {\n                return 1;\n            }\n            else if (a.max < b.max) {\n                return -1;\n            }\n            else if (b.max > a.max) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        });\n        const oranges = [];\n        let current = ranges[0];\n        for (const nxt of ranges) {\n            if (nxt.min > current.max + 1) {\n                oranges.push(current);\n                current = nxt;\n            }\n            else if (nxt.max > current.max) {\n                current = new Range([{ min: current.min, max: nxt.max }]);\n            }\n        }\n        oranges.push(current);\n        return oranges.length === 1 ? oranges[0] : new Range(oranges);\n    }\n}\n//# sourceMappingURL=range.js.map","import { inflateRaw } from 'pako-esm2';\nexport function unzip(input) {\n    return inflateRaw(input.subarray(2), undefined);\n}\n//# sourceMappingURL=unzip.js.map","export class AbortError extends Error {\n    code;\n    constructor(message) {\n        super(message);\n        this.code = 'ERR_ABORTED';\n    }\n}\n// sort blocks by file offset and\n// group blocks that are within 2KB of eachother\nexport function groupBlocks(blocks) {\n    blocks.sort((b0, b1) => b0.offset - b1.offset);\n    const blockGroups = [];\n    let lastBlock;\n    let lastBlockEnd;\n    for (const block of blocks) {\n        if (lastBlock && lastBlockEnd && block.offset - lastBlockEnd <= 2000) {\n            lastBlock.length =\n                lastBlock.length + block.length - lastBlockEnd + block.offset;\n            lastBlock.blocks.push(block);\n        }\n        else {\n            blockGroups.push((lastBlock = {\n                blocks: [block],\n                length: block.length,\n                offset: block.offset,\n            }));\n        }\n        lastBlockEnd = lastBlock.offset + lastBlock.length;\n    }\n    return blockGroups;\n}\n/**\n * Properly check if the given AbortSignal is aborted. Per the standard, if the\n * signal reads as aborted, this function throws either a DOMException\n * AbortError, or a regular error with a `code` attribute set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute\n * @returns nothing\n */\nexport function checkAbortSignal(signal) {\n    if (!signal) {\n        return;\n    }\n    if (signal.aborted) {\n        if (typeof DOMException === 'undefined') {\n            const e = new AbortError('aborted');\n            e.code = 'ERR_ABORTED';\n            throw e;\n        }\n        else {\n            throw new DOMException('aborted', 'AbortError');\n        }\n    }\n}\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nexport async function abortBreakPoint(signal) {\n    await Promise.resolve();\n    checkAbortSignal(signal);\n}\n//# sourceMappingURL=util.js.map","import AbortablePromiseCache from '@gmod/abortable-promise-cache';\nimport QuickLRU from 'quick-lru';\nimport Range from \"./range.js\";\nimport { unzip } from \"./unzip.js\";\nimport { checkAbortSignal, groupBlocks } from \"./util.js\";\nconst decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\nfunction coordFilter(s1, e1, s2, e2) {\n    return s1 < e2 && e1 >= s2;\n}\n/**\n * View into a subset of the data in a BigWig file.\n *\n * Adapted by Robert Buels and Colin Diesh from bigwig.js in the Dalliance\n * Genome Explorer by Thomas Down.\n */\nexport class BlockView {\n    bbi;\n    refsByName;\n    cirTreeOffset;\n    isCompressed;\n    blockType;\n    cirTreePromise;\n    featureCache = new AbortablePromiseCache({\n        cache: new QuickLRU({ maxSize: 1000 }),\n        fill: async ({ length, offset }, signal) => this.bbi.read(length, offset, { signal }),\n    });\n    constructor(bbi, refsByName, cirTreeOffset, isCompressed, blockType) {\n        this.bbi = bbi;\n        this.refsByName = refsByName;\n        this.cirTreeOffset = cirTreeOffset;\n        this.isCompressed = isCompressed;\n        this.blockType = blockType;\n        if (!(cirTreeOffset >= 0)) {\n            throw new Error('invalid cirTreeOffset!');\n        }\n    }\n    async readWigData(chrName, start, end, observer, opts) {\n        try {\n            const chrId = this.refsByName[chrName];\n            if (chrId === undefined) {\n                observer.complete();\n            }\n            const request = { chrId, start, end };\n            if (!this.cirTreePromise) {\n                this.cirTreePromise = this.bbi.read(48, this.cirTreeOffset, opts);\n            }\n            const buffer = await this.cirTreePromise;\n            const dataView = new DataView(buffer.buffer);\n            const cirBlockSize = dataView.getUint32(4, true);\n            let blocksToFetch = [];\n            let outstanding = 0;\n            const cirFobRecur2 = (cirBlockData, offset2, level) => {\n                try {\n                    const data = cirBlockData.subarray(offset2);\n                    const b = data;\n                    const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n                    let offset = 0;\n                    const isLeaf = dataView.getUint8(offset);\n                    offset += 2; // 1 skip\n                    const cnt = dataView.getUint16(offset, true);\n                    offset += 2;\n                    if (isLeaf === 1) {\n                        const blocksToFetch2 = [];\n                        for (let i = 0; i < cnt; i++) {\n                            const startChrom = dataView.getUint32(offset, true);\n                            offset += 4;\n                            const startBase = dataView.getUint32(offset, true);\n                            offset += 4;\n                            const endChrom = dataView.getUint32(offset, true);\n                            offset += 4;\n                            const endBase = dataView.getUint32(offset, true);\n                            offset += 4;\n                            const blockOffset = Number(dataView.getBigUint64(offset, true));\n                            offset += 8;\n                            const blockSize = Number(dataView.getBigUint64(offset, true));\n                            offset += 8;\n                            blocksToFetch2.push({\n                                startChrom,\n                                startBase,\n                                endBase,\n                                endChrom,\n                                blockOffset,\n                                blockSize,\n                                offset,\n                            });\n                        }\n                        blocksToFetch = blocksToFetch.concat(blocksToFetch2\n                            .filter(f => filterFeats(f))\n                            .map(l => ({\n                            offset: l.blockOffset,\n                            length: l.blockSize,\n                        })));\n                    }\n                    else if (isLeaf === 0) {\n                        const recurOffsets = [];\n                        for (let i = 0; i < cnt; i++) {\n                            const startChrom = dataView.getUint32(offset, true);\n                            offset += 4;\n                            const startBase = dataView.getUint32(offset, true);\n                            offset += 4;\n                            const endChrom = dataView.getUint32(offset, true);\n                            offset += 4;\n                            const endBase = dataView.getUint32(offset, true);\n                            offset += 4;\n                            const blockOffset = Number(dataView.getBigUint64(offset, true));\n                            offset += 8;\n                            recurOffsets.push({\n                                startChrom,\n                                startBase,\n                                endChrom,\n                                endBase,\n                                blockOffset,\n                                offset,\n                            });\n                        }\n                        const recurOffsets2 = recurOffsets\n                            .filter(f => filterFeats(f))\n                            .map(l => l.blockOffset);\n                        if (recurOffsets2.length > 0) {\n                            cirFobRecur(recurOffsets2, level + 1);\n                        }\n                    }\n                }\n                catch (e) {\n                    observer.error(e);\n                }\n            };\n            const filterFeats = (b) => {\n                const { startChrom, startBase, endChrom, endBase } = b;\n                return ((startChrom < chrId || (startChrom === chrId && startBase <= end)) &&\n                    (endChrom > chrId || (endChrom === chrId && endBase >= start)));\n            };\n            const cirFobStartFetch = async (off, fr, level) => {\n                try {\n                    const length = fr.max - fr.min;\n                    const offset = fr.min;\n                    const resultBuffer = await this.featureCache.get(`${length}_${offset}`, { length, offset }, opts?.signal);\n                    for (const element of off) {\n                        if (fr.contains(element)) {\n                            cirFobRecur2(resultBuffer, element - offset, level);\n                            outstanding -= 1;\n                            if (outstanding === 0) {\n                                this.readFeatures(observer, blocksToFetch, {\n                                    ...opts,\n                                    request,\n                                }).catch((e) => {\n                                    observer.error(e);\n                                });\n                            }\n                        }\n                    }\n                }\n                catch (e) {\n                    observer.error(e);\n                }\n            };\n            const cirFobRecur = (offset, level) => {\n                try {\n                    outstanding += offset.length;\n                    // Upper bound on size, based on a completely full leaf node.\n                    const maxCirBlockSpan = 4 + cirBlockSize * 32;\n                    let spans = new Range([\n                        {\n                            min: offset[0],\n                            max: offset[0] + maxCirBlockSpan,\n                        },\n                    ]);\n                    for (let i = 1; i < offset.length; i += 1) {\n                        const blockSpan = new Range([\n                            {\n                                min: offset[i],\n                                max: offset[i] + maxCirBlockSpan,\n                            },\n                        ]);\n                        spans = spans.union(blockSpan);\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                    spans.getRanges().map(fr => cirFobStartFetch(offset, fr, level));\n                }\n                catch (e) {\n                    observer.error(e);\n                }\n            };\n            cirFobRecur([this.cirTreeOffset + 48], 1);\n            return;\n        }\n        catch (e) {\n            observer.error(e);\n        }\n    }\n    parseSummaryBlock(b, startOffset, request) {\n        const features = [];\n        let offset = startOffset;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        while (offset < b.byteLength) {\n            // this was extracted from looking at the runtime code generated by\n            // binary-parser\n            const chromId = dataView.getUint32(offset, true);\n            offset += 4;\n            const start = dataView.getUint32(offset, true);\n            offset += 4;\n            const end = dataView.getUint32(offset, true);\n            offset += 4;\n            const validCnt = dataView.getUint32(offset, true);\n            offset += 4;\n            const minScore = dataView.getFloat32(offset, true);\n            offset += 4;\n            const maxScore = dataView.getFloat32(offset, true);\n            offset += 4;\n            const sumData = dataView.getFloat32(offset, true);\n            offset += 4;\n            // unused\n            // const sumSqData = dataView.getFloat32(offset, true)\n            offset += 4;\n            if (request\n                ? chromId === request.chrId &&\n                    coordFilter(start, end, request.start, request.end)\n                : true) {\n                features.push({\n                    start,\n                    end,\n                    maxScore,\n                    minScore,\n                    summary: true,\n                    score: sumData / (validCnt || 1),\n                });\n            }\n        }\n        return features;\n    }\n    parseBigBedBlock(data, startOffset, offset, request) {\n        const items = [];\n        let currOffset = startOffset;\n        const b = data;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        while (currOffset < data.byteLength) {\n            const c2 = currOffset;\n            const chromId = dataView.getUint32(currOffset, true);\n            currOffset += 4;\n            const start = dataView.getInt32(currOffset, true);\n            currOffset += 4;\n            const end = dataView.getInt32(currOffset, true);\n            currOffset += 4;\n            let i = currOffset;\n            for (; i < data.length; i++) {\n                if (data[i] === 0) {\n                    break;\n                }\n            }\n            const b = data.subarray(currOffset, i);\n            const rest = decoder?.decode(b) ?? b.toString();\n            currOffset = i + 1;\n            items.push({\n                chromId,\n                start,\n                end,\n                rest,\n                uniqueId: `bb-${offset + c2}`,\n            });\n        }\n        return request\n            ? items.filter((f) => coordFilter(f.start, f.end, request.start, request.end))\n            : items;\n    }\n    parseBigWigBlock(buffer, startOffset, req) {\n        const b = buffer.subarray(startOffset);\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        let offset = 0;\n        offset += 4;\n        const blockStart = dataView.getInt32(offset, true);\n        offset += 8;\n        const itemStep = dataView.getUint32(offset, true);\n        offset += 4;\n        const itemSpan = dataView.getUint32(offset, true);\n        offset += 4;\n        const blockType = dataView.getUint8(offset);\n        offset += 2;\n        const itemCount = dataView.getUint16(offset, true);\n        offset += 2;\n        const items = new Array(itemCount);\n        switch (blockType) {\n            case 1: {\n                for (let i = 0; i < itemCount; i++) {\n                    const start = dataView.getInt32(offset, true);\n                    offset += 4;\n                    const end = dataView.getInt32(offset, true);\n                    offset += 4;\n                    const score = dataView.getFloat32(offset, true);\n                    offset += 4;\n                    items[i] = {\n                        start,\n                        end,\n                        score,\n                    };\n                }\n                break;\n            }\n            case 2: {\n                for (let i = 0; i < itemCount; i++) {\n                    const start = dataView.getInt32(offset, true);\n                    offset += 4;\n                    const score = dataView.getFloat32(offset, true);\n                    offset += 4;\n                    items[i] = {\n                        score,\n                        start,\n                        end: start + itemSpan,\n                    };\n                }\n                break;\n            }\n            case 3: {\n                for (let i = 0; i < itemCount; i++) {\n                    const score = dataView.getFloat32(offset, true);\n                    offset += 4;\n                    const start = blockStart + i * itemStep;\n                    items[i] = {\n                        score,\n                        start,\n                        end: start + itemSpan,\n                    };\n                }\n                break;\n            }\n        }\n        return req\n            ? items.filter(f => coordFilter(f.start, f.end, req.start, req.end))\n            : items;\n    }\n    async readFeatures(observer, blocks, opts = {}) {\n        try {\n            const { blockType, isCompressed } = this;\n            const { signal, request } = opts;\n            const blockGroupsToFetch = groupBlocks(blocks);\n            checkAbortSignal(signal);\n            await Promise.all(blockGroupsToFetch.map(async (blockGroup) => {\n                checkAbortSignal(signal);\n                const { length, offset } = blockGroup;\n                const data = await this.featureCache.get(`${length}_${offset}`, blockGroup, signal);\n                for (const block of blockGroup.blocks) {\n                    checkAbortSignal(signal);\n                    let resultData = data.subarray(block.offset - blockGroup.offset);\n                    if (isCompressed) {\n                        resultData = unzip(resultData);\n                    }\n                    checkAbortSignal(signal);\n                    switch (blockType) {\n                        case 'summary': {\n                            observer.next(this.parseSummaryBlock(resultData, 0, request));\n                            break;\n                        }\n                        case 'bigwig': {\n                            observer.next(this.parseBigWigBlock(resultData, 0, request));\n                            break;\n                        }\n                        case 'bigbed': {\n                            observer.next(this.parseBigBedBlock(resultData, 0, block.offset * (1 << 8), request));\n                            break;\n                        }\n                        default: {\n                            console.warn(`Don't know what to do with ${blockType}`);\n                        }\n                    }\n                }\n            }));\n            observer.complete();\n        }\n        catch (e) {\n            observer.error(e);\n        }\n    }\n}\n//# sourceMappingURL=block-view.js.map","import { LocalFile, RemoteFile } from 'generic-filehandle2';\nimport { Observable, firstValueFrom } from 'rxjs';\nimport { toArray } from 'rxjs/operators';\nimport { BlockView } from \"./block-view.js\";\nconst BIG_WIG_MAGIC = -2003829722;\nconst BIG_BED_MAGIC = -2021002517;\nfunction getDataView(buffer) {\n    return new DataView(buffer.buffer, buffer.byteOffset, buffer.length);\n}\nexport class BBI {\n    bbi;\n    headerP;\n    renameRefSeqs;\n    getHeader(opts) {\n        if (!this.headerP) {\n            this.headerP = this._getHeader(opts).catch((e) => {\n                this.headerP = undefined;\n                throw e;\n            });\n        }\n        return this.headerP;\n    }\n    /*\n     * @param filehandle - a filehandle from generic-filehandle2\n     *\n     * @param path - a Local file path as a string\n     *\n     * @param url - a URL string\n     *\n     * @param renameRefSeqs - an optional method to rename the internal reference\n     * sequences using a mapping function\n     */\n    constructor(args) {\n        const { filehandle, renameRefSeqs = s => s, path, url } = args;\n        this.renameRefSeqs = renameRefSeqs;\n        if (filehandle) {\n            this.bbi = filehandle;\n        }\n        else if (url) {\n            this.bbi = new RemoteFile(url);\n        }\n        else if (path) {\n            this.bbi = new LocalFile(path);\n        }\n        else {\n            throw new Error('no file given');\n        }\n    }\n    async _getHeader(opts) {\n        const header = await this._getMainHeader(opts);\n        const chroms = await this._readChromTree(header, opts);\n        return {\n            ...header,\n            ...chroms,\n        };\n    }\n    async _getMainHeader(opts, requestSize = 2000) {\n        const b = await this.bbi.read(requestSize, 0, opts);\n        const dataView = getDataView(b);\n        const r1 = dataView.getInt32(0, true);\n        if (r1 !== BIG_WIG_MAGIC && r1 !== BIG_BED_MAGIC) {\n            throw new Error('not a BigWig/BigBed file');\n        }\n        let offset = 0;\n        const magic = dataView.getInt32(offset, true);\n        offset += 4;\n        const version = dataView.getUint16(offset, true);\n        offset += 2;\n        const numZoomLevels = dataView.getUint16(offset, true);\n        offset += 2;\n        const chromTreeOffset = Number(dataView.getBigUint64(offset, true));\n        offset += 8;\n        const unzoomedDataOffset = Number(dataView.getBigUint64(offset, true));\n        offset += 8;\n        const unzoomedIndexOffset = Number(dataView.getBigUint64(offset, true));\n        offset += 8;\n        const fieldCount = dataView.getUint16(offset, true);\n        offset += 2;\n        const definedFieldCount = dataView.getUint16(offset, true);\n        offset += 2;\n        const asOffset = Number(dataView.getBigUint64(offset, true));\n        offset += 8;\n        const totalSummaryOffset = Number(dataView.getBigUint64(offset, true));\n        offset += 8;\n        const uncompressBufSize = dataView.getUint32(offset, true);\n        offset += 4;\n        const extHeaderOffset = Number(dataView.getBigUint64(offset, true));\n        offset += 8;\n        const zoomLevels = [];\n        for (let i = 0; i < numZoomLevels; i++) {\n            const reductionLevel = dataView.getUint32(offset, true);\n            offset += 4;\n            const reserved = dataView.getUint32(offset, true);\n            offset += 4;\n            const dataOffset = Number(dataView.getBigUint64(offset, true));\n            offset += 8;\n            const indexOffset = Number(dataView.getBigUint64(offset, true));\n            offset += 8;\n            zoomLevels.push({\n                reductionLevel,\n                reserved,\n                dataOffset,\n                indexOffset,\n            });\n        }\n        const fileType = magic === BIG_BED_MAGIC ? 'bigbed' : 'bigwig';\n        // refetch header if it is too large on first pass,\n        // 8*5 is the sizeof the totalSummary struct\n        if (asOffset > requestSize || totalSummaryOffset > requestSize - 8 * 5) {\n            return this._getMainHeader(opts, requestSize * 2);\n        }\n        let totalSummary;\n        if (totalSummaryOffset) {\n            const b2 = b.subarray(totalSummaryOffset);\n            let offset = 0;\n            const dataView = getDataView(b2);\n            const basesCovered = Number(dataView.getBigUint64(offset, true));\n            offset += 8;\n            const scoreMin = dataView.getFloat64(offset, true);\n            offset += 8;\n            const scoreMax = dataView.getFloat64(offset, true);\n            offset += 8;\n            const scoreSum = dataView.getFloat64(offset, true);\n            offset += 8;\n            const scoreSumSquares = dataView.getFloat64(offset, true);\n            offset += 8;\n            totalSummary = {\n                scoreMin,\n                scoreMax,\n                scoreSum,\n                scoreSumSquares,\n                basesCovered,\n            };\n        }\n        else {\n            throw new Error('no stats');\n        }\n        const decoder = new TextDecoder('utf8');\n        return {\n            zoomLevels,\n            magic,\n            extHeaderOffset,\n            numZoomLevels,\n            fieldCount,\n            totalSummary,\n            definedFieldCount,\n            uncompressBufSize,\n            asOffset,\n            chromTreeOffset,\n            totalSummaryOffset,\n            unzoomedDataOffset,\n            unzoomedIndexOffset,\n            fileType,\n            version,\n            autoSql: asOffset\n                ? decoder.decode(b.subarray(asOffset, b.indexOf(0, asOffset)))\n                : '',\n        };\n    }\n    async _readChromTree(header, opts) {\n        const refsByNumber = [];\n        const refsByName = {};\n        const chromTreeOffset = header.chromTreeOffset;\n        const dataView = getDataView(await this.bbi.read(32, chromTreeOffset, opts));\n        let offset = 0;\n        // const magic = dataView.getUint32(offset, true) // unused\n        offset += 4;\n        // const blockSize = dataView.getUint32(offset, true) // unused\n        offset += 4;\n        const keySize = dataView.getUint32(offset, true);\n        offset += 4;\n        const valSize = dataView.getUint32(offset, true);\n        offset += 4;\n        // const itemCount = dataView.getBigUint64(offset, true) // unused\n        offset += 8;\n        const decoder = new TextDecoder('utf8');\n        const bptReadNode = async (currentOffset) => {\n            const b = await this.bbi.read(4, currentOffset);\n            const dataView = getDataView(b);\n            let offset = 0;\n            const isLeafNode = dataView.getUint8(offset);\n            offset += 1;\n            // const reserved = dataView.getUint8(offset) // unused\n            offset += 1;\n            const count = dataView.getUint16(offset, true);\n            offset += 2;\n            if (isLeafNode) {\n                const b = await this.bbi.read(count * (keySize + valSize), currentOffset + offset);\n                const dataView = getDataView(b);\n                offset = 0;\n                for (let n = 0; n < count; n++) {\n                    const key = decoder\n                        .decode(b.subarray(offset, offset + keySize))\n                        .replaceAll('\\0', '');\n                    offset += keySize;\n                    const refId = dataView.getUint32(offset, true);\n                    offset += 4;\n                    const refSize = dataView.getUint32(offset, true);\n                    offset += 4;\n                    refsByName[this.renameRefSeqs(key)] = refId;\n                    refsByNumber[refId] = {\n                        name: key,\n                        id: refId,\n                        length: refSize,\n                    };\n                }\n            }\n            else {\n                const nextNodes = [];\n                const dataView = getDataView(await this.bbi.read(count * (keySize + 8), currentOffset + offset));\n                offset = 0;\n                for (let n = 0; n < count; n++) {\n                    offset += keySize;\n                    const childOffset = Number(dataView.getBigUint64(offset, true));\n                    offset += 8;\n                    nextNodes.push(bptReadNode(childOffset));\n                }\n                await Promise.all(nextNodes);\n            }\n        };\n        await bptReadNode(chromTreeOffset + 32);\n        return {\n            refsByName,\n            refsByNumber,\n        };\n    }\n    /*\n     * fetches the \"unzoomed\" view of the bigwig data. this is the default for bigbed\n     * @param abortSignal - a signal to optionally abort this operation\n     */\n    async getUnzoomedView(opts) {\n        const { unzoomedIndexOffset, refsByName, uncompressBufSize, fileType } = await this.getHeader(opts);\n        return new BlockView(this.bbi, refsByName, unzoomedIndexOffset, uncompressBufSize > 0, fileType);\n    }\n    /**\n     * Gets features from a BigWig file\n     *\n     * @param refName - The chromosome name\n     *\n     * @param start - The start of a region\n     *\n     * @param end - The end of a region\n     *\n     * @param opts - An object containing basesPerSpan (e.g. pixels per basepair)\n     * or scale used to infer the zoomLevel to use\n     */\n    async getFeatureStream(refName, start, end, opts) {\n        await this.getHeader(opts);\n        const chrName = this.renameRefSeqs(refName);\n        let view;\n        const { basesPerSpan, scale } = opts || {};\n        if (basesPerSpan) {\n            view = await this.getView(1 / basesPerSpan, opts);\n        }\n        else if (scale) {\n            view = await this.getView(scale, opts);\n        }\n        else {\n            view = await this.getView(1, opts);\n        }\n        return new Observable(observer => {\n            view\n                .readWigData(chrName, start, end, observer, opts)\n                .catch((e) => {\n                observer.error(e);\n            });\n        });\n    }\n    async getFeatures(refName, start, end, opts) {\n        const ob = await this.getFeatureStream(refName, start, end, opts);\n        const ret = await firstValueFrom(ob.pipe(toArray()));\n        return ret.flat();\n    }\n}\n//# sourceMappingURL=bbi.js.map"],"names":["BigInt32","getBigInt64","dataView","byteOffset","littleEndian","littleEndianMask","bigEndianMask","getBigUint64","a","b","Range","arg1","__publicField","pos","r","s1","ranges","oranges","current","nxt","unzip","input","inflateRaw","AbortError","message","groupBlocks","blocks","b0","b1","blockGroups","lastBlock","lastBlockEnd","block","checkAbortSignal","signal","decoder","coordFilter","e1","s2","e2","BlockView","bbi","refsByName","cirTreeOffset","isCompressed","blockType","AbortablePromiseCache","QuickLRU","length","offset","chrName","start","end","observer","opts","chrId","request","buffer","cirBlockSize","blocksToFetch","outstanding","cirFobRecur2","cirBlockData","offset2","level","isLeaf","cnt","blocksToFetch2","i","startChrom","startBase","endChrom","endBase","blockOffset","blockSize","f","filterFeats","l","recurOffsets","recurOffsets2","cirFobRecur","e","cirFobStartFetch","off","fr","resultBuffer","element","maxCirBlockSpan","spans","blockSpan","startOffset","features","chromId","validCnt","minScore","maxScore","sumData","data","items","currOffset","c2","rest","req","blockStart","itemStep","itemSpan","itemCount","score","blockGroupsToFetch","blockGroup","resultData","BIG_WIG_MAGIC","BIG_BED_MAGIC","getDataView","BBI","args","filehandle","renameRefSeqs","s","path","url","RemoteFile","LocalFile","header","chroms","requestSize","r1","magic","version","numZoomLevels","chromTreeOffset","unzoomedDataOffset","unzoomedIndexOffset","fieldCount","definedFieldCount","asOffset","totalSummaryOffset","uncompressBufSize","extHeaderOffset","zoomLevels","reductionLevel","reserved","dataOffset","indexOffset","fileType","totalSummary","b2","basesCovered","scoreMin","scoreMax","scoreSum","scoreSumSquares","refsByNumber","keySize","valSize","bptReadNode","currentOffset","isLeafNode","count","n","key","refId","refSize","nextNodes","childOffset","refName","view","basesPerSpan","scale","Observable","ob","firstValueFrom","toArray"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}