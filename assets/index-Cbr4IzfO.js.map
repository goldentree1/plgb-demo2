{"version":3,"file":"index-Cbr4IzfO.js","sources":["../node_modules/@gmod/vcf/esm/parseGenotypesOnly.js","../node_modules/@gmod/vcf/esm/parseMetaString.js","../node_modules/@gmod/vcf/esm/vcfReserved.js","../node_modules/@gmod/vcf/esm/parse.js","../node_modules/@jbrowse/plugin-variants/esm/VcfFeature/index.js"],"sourcesContent":["/**\n * Extracts genotype (GT) values from VCF sample data.\n */\nexport function parseGenotypesOnly(format, prerest, samples) {\n    const genotypes = Object.create(null);\n    const samplesLen = samples.length;\n    const prerestLen = prerest.length;\n    const TAB = 9;\n    const COLON = 58;\n    let pos = 0;\n    // Fast path: format is exactly \"GT\"\n    if (format === 'GT') {\n        for (let idx = 0; idx < samplesLen; idx++) {\n            const start = pos;\n            while (pos < prerestLen && prerest.charCodeAt(pos) !== TAB) {\n                pos++;\n            }\n            genotypes[samples[idx]] = prerest.slice(start, pos);\n            pos++;\n        }\n        return genotypes;\n    }\n    // Check if GT field exists\n    const gtIdx = format.indexOf('GT');\n    if (gtIdx === -1) {\n        return genotypes;\n    }\n    // GT is first field but not only field\n    if (gtIdx === 0) {\n        for (let idx = 0; idx < samplesLen; idx++) {\n            const start = pos;\n            while (pos < prerestLen &&\n                prerest.charCodeAt(pos) !== COLON &&\n                prerest.charCodeAt(pos) !== TAB) {\n                pos++;\n            }\n            genotypes[samples[idx]] = prerest.slice(start, pos);\n            while (pos < prerestLen && prerest.charCodeAt(pos) !== TAB) {\n                pos++;\n            }\n            pos++;\n        }\n        return genotypes;\n    }\n    // GT is not first field\n    let colonCount = 0;\n    for (let j = 0; j < gtIdx; j++) {\n        if (format.charCodeAt(j) === COLON) {\n            colonCount++;\n        }\n    }\n    for (let idx = 0; idx < samplesLen; idx++) {\n        const sampleStart = pos;\n        let tabIdx = pos;\n        while (tabIdx < prerestLen && prerest.charCodeAt(tabIdx) !== TAB) {\n            tabIdx++;\n        }\n        let colons = 0;\n        let fieldStart = sampleStart;\n        for (let j = sampleStart; j <= tabIdx; j++) {\n            if (j === tabIdx || prerest.charCodeAt(j) === COLON) {\n                if (colons === colonCount) {\n                    genotypes[samples[idx]] = prerest.slice(fieldStart, j);\n                    break;\n                }\n                colons++;\n                fieldStart = j + 1;\n            }\n        }\n        pos = tabIdx + 1;\n    }\n    return genotypes;\n}\n//# sourceMappingURL=parseGenotypesOnly.js.map","// constructed with the assistance of claude AI\n//\n// I first prompted it with a regex that splits a comma separated string with\n// awareness of quotation from this stackoverflow question\n// https://stackoverflow.com/a/18893443/2129219, and asked it to add support\n// for square brackets\n//\n// it undid the regex into serial logic and the result was this function\nfunction customSplit(str) {\n    const result = [];\n    const chars = [];\n    let inQuotes = false;\n    let inBrackets = false;\n    const strLen = str.length;\n    for (let i = 0; i < strLen; i++) {\n        const char = str[i];\n        if (char === '\"') {\n            inQuotes = !inQuotes;\n            chars.push(char);\n        }\n        else if (char === '[') {\n            inBrackets = true;\n            chars.push(char);\n        }\n        else if (char === ']') {\n            inBrackets = false;\n            chars.push(char);\n        }\n        else if (char === ',' && !inQuotes && !inBrackets) {\n            result.push(chars.join('').trim());\n            chars.length = 0;\n        }\n        else {\n            chars.push(char);\n        }\n    }\n    if (chars.length > 0) {\n        result.push(chars.join('').trim());\n    }\n    return result;\n}\nfunction splitFirst(str, split) {\n    const index = str.indexOf(split);\n    return [str.slice(0, index), str.slice(index + 1)];\n}\nexport function parseMetaString(metaString) {\n    const inside = metaString.slice(1, -1);\n    const parts = customSplit(inside);\n    const entries = [];\n    for (let i = 0; i < parts.length; i++) {\n        const f = parts[i];\n        const [key, val] = splitFirst(f, '=');\n        if (val && val.startsWith('[') && val.endsWith(']')) {\n            const items = val.slice(1, -1).split(',');\n            for (let j = 0; j < items.length; j++) {\n                items[j] = items[j].trim();\n            }\n            entries.push([key, items]);\n        }\n        else if (val && val.startsWith('\"') && val.endsWith('\"')) {\n            entries.push([key, val.slice(1, -1)]);\n        }\n        else {\n            entries.push([key, val]);\n        }\n    }\n    return Object.fromEntries(entries);\n}\n//# sourceMappingURL=parseMetaString.js.map","export default {\n    // INFO fields\n    InfoFields: {\n        // from the VCF4.3 spec, https://samtools.github.io/hts-specs/VCFv4.3.pdf\n        AA: { Number: 1, Type: 'String', Description: 'Ancestral allele' },\n        AC: {\n            Number: 'A',\n            Type: 'Integer',\n            Description: 'Allele count in genotypes, for each ALT allele, in the same order as listed',\n        },\n        AD: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Total read depth for each allele',\n        },\n        ADF: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Read depth for each allele on the forward strand',\n        },\n        ADR: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Read depth for each allele on the reverse strand',\n        },\n        AF: {\n            Number: 'A',\n            Type: 'Float',\n            Description: 'Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)',\n        },\n        AN: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Total number of alleles in called genotypes',\n        },\n        BQ: {\n            Number: 1,\n            Type: 'Float',\n            Description: 'RMS base quality',\n        },\n        CIGAR: {\n            Number: 1,\n            Type: 'Float',\n            Description: 'Cigar string describing how to align an alternate allele to the reference allele',\n        },\n        DB: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'dbSNP membership',\n        },\n        DP: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'combined depth across samples',\n        },\n        END: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'End position (for use with symbolic alleles)',\n        },\n        H2: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'HapMap2 membership',\n        },\n        H3: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'HapMap3 membership',\n        },\n        MQ: {\n            Number: 1,\n            Type: null,\n            Description: 'RMS mapping quality',\n        },\n        MQ0: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Number of MAPQ == 0 reads',\n        },\n        NS: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Number of samples with data',\n        },\n        SB: {\n            Number: 4,\n            Type: 'Integer',\n            Description: 'Strand bias',\n        },\n        SOMATIC: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'Somatic mutation (for cancer genomics)',\n        },\n        VALIDATED: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'Validated by follow-up experiment',\n        },\n        '1000G': {\n            Number: 0,\n            Type: 'Flag',\n            Description: '1000 Genomes membership',\n        },\n        // specifically for structural variants\n        IMPRECISE: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'Imprecise structural variation',\n        },\n        NOVEL: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'Indicates a novel structural variation',\n        },\n        // For precise variants, END is POS + length of REF allele - 1,\n        // and the for imprecise variants the corresponding best estimate.\n        SVTYPE: {\n            Number: 1,\n            Type: 'String',\n            Description: 'Type of structural variant',\n        },\n        // Value should be one of DEL, INS, DUP, INV, CNV, BND. This key can\n        // be derived from the REF/ALT fields but is useful for filtering.\n        SVLEN: {\n            Number: null,\n            Type: 'Integer',\n            Description: 'Difference in length between REF and ALT alleles',\n        },\n        // One value for each ALT allele. Longer ALT alleles (e.g. insertions)\n        // have positive values, shorter ALT alleles (e.g. deletions)\n        // have negative values.\n        CIPOS: {\n            Number: 2,\n            Type: 'Integer',\n            Description: 'Confidence interval around POS for imprecise variants',\n        },\n        CIEND: {\n            Number: 2,\n            Type: 'Integer',\n            Description: 'Confidence interval around END for imprecise variants',\n        },\n        HOMLEN: {\n            Type: 'Integer',\n            Description: 'Length of base pair identical micro-homology at event breakpoints',\n        },\n        HOMSEQ: {\n            Type: 'String',\n            Description: 'Sequence of base pair identical micro-homology at event breakpoints',\n        },\n        BKPTID: {\n            Type: 'String',\n            Description: 'ID of the assembled alternate allele in the assembly file',\n        },\n        // For precise variants, the consensus sequence the alternate allele assembly\n        // is derivable from the REF and ALT fields. However, the alternate allele\n        // assembly file may contain additional information about the characteristics\n        // of the alt allele contigs.\n        MEINFO: {\n            Number: 4,\n            Type: 'String',\n            Description: 'Mobile element info of the form NAME,START,END,POLARITY',\n        },\n        METRANS: {\n            Number: 4,\n            Type: 'String',\n            Description: 'Mobile element transduction info of the form CHR,START,END,POLARITY',\n        },\n        DGVID: {\n            Number: 1,\n            Type: 'String',\n            Description: 'ID of this element in Database of Genomic Variation',\n        },\n        DBVARID: {\n            Number: 1,\n            Type: 'String',\n            Description: 'ID of this element in DBVAR',\n        },\n        DBRIPID: {\n            Number: 1,\n            Type: 'String',\n            Description: 'ID of this element in DBRIP',\n        },\n        MATEID: {\n            Number: null,\n            Type: 'String',\n            Description: 'ID of mate breakends',\n        },\n        PARID: {\n            Number: 1,\n            Type: 'String',\n            Description: 'ID of partner breakend',\n        },\n        EVENT: {\n            Number: 1,\n            Type: 'String',\n            Description: 'ID of event associated to breakend',\n        },\n        CILEN: {\n            Number: 2,\n            Type: 'Integer',\n            Description: 'Confidence interval around the inserted material between breakend',\n        },\n        DPADJ: { Type: 'Integer', Description: 'Read Depth of adjacency' },\n        CN: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Copy number of segment containing breakend',\n        },\n        CNADJ: {\n            Number: null,\n            Type: 'Integer',\n            Description: 'Copy number of adjacency',\n        },\n        CICN: {\n            Number: 2,\n            Type: 'Integer',\n            Description: 'Confidence interval around copy number for the segment',\n        },\n        CICNADJ: {\n            Number: null,\n            Type: 'Integer',\n            Description: 'Confidence interval around copy number for the adjacency',\n        },\n    },\n    // FORMAT fields\n    GenotypeFields: {\n        // from the VCF4.3 spec, https://samtools.github.io/hts-specs/VCFv4.3.pdf\n        AD: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Read depth for each allele',\n        },\n        ADF: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Read depth for each allele on the forward strand',\n        },\n        ADR: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Read depth for each allele on the reverse strand',\n        },\n        DP: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Read depth',\n        },\n        EC: {\n            Number: 'A',\n            Type: 'Integer',\n            Description: 'Expected alternate allele counts',\n        },\n        FT: {\n            Number: 1,\n            Type: 'String',\n            Description: 'Filter indicating if this genotype was \"called\"',\n        },\n        GL: {\n            Number: 'G',\n            Type: 'Float',\n            Description: 'Genotype likelihoods',\n        },\n        GP: {\n            Number: 'G',\n            Type: 'Float',\n            Description: 'Genotype posterior probabilities',\n        },\n        GQ: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Conditional genotype quality',\n        },\n        GT: {\n            Number: 1,\n            Type: 'String',\n            Description: 'Genotype',\n        },\n        HQ: {\n            Number: 2,\n            Type: 'Integer',\n            Description: 'Haplotype quality',\n        },\n        MQ: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'RMS mapping quality',\n        },\n        PL: {\n            Number: 'G',\n            Type: 'Integer',\n            Description: 'Phred-scaled genotype likelihoods rounded to the closest integer',\n        },\n        PQ: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Phasing quality',\n        },\n        PS: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Phase set',\n        },\n    },\n    // ALT fields\n    AltTypes: {\n        DEL: {\n            Description: 'Deletion relative to the reference',\n        },\n        INS: {\n            Description: 'Insertion of novel sequence relative to the reference',\n        },\n        DUP: {\n            Description: 'Region of elevated copy number relative to the reference',\n        },\n        INV: {\n            Description: 'Inversion of reference sequence',\n        },\n        CNV: {\n            Description: 'Copy number variable region (may be both deletion and duplication)',\n        },\n        'DUP:TANDEM': {\n            Description: 'Tandem duplication',\n        },\n        'DEL:ME': {\n            Description: 'Deletion of mobile element relative to the reference',\n        },\n        'INS:ME': {\n            Description: 'Insertion of a mobile element relative to the reference',\n        },\n        NON_REF: {\n            Description: 'Represents any possible alternative allele at this location',\n        },\n        '*': {\n            Description: 'Represents any possible alternative allele at this location',\n        },\n    },\n    // FILTER fields\n    FilterTypes: {\n        PASS: {\n            Description: 'Passed all filters',\n        },\n    },\n};\n//# sourceMappingURL=vcfReserved.js.map","import { parseGenotypesOnly } from \"./parseGenotypesOnly.js\";\nimport { parseMetaString } from \"./parseMetaString.js\";\nimport vcfReserved from \"./vcfReserved.js\";\nfunction decodeURIComponentNoThrow(uri) {\n    try {\n        return decodeURIComponent(uri);\n    }\n    catch (_e) {\n        // avoid throwing exception on a failure to decode URI component\n        return uri;\n    }\n}\n/**\n * Class representing a VCF parser, instantiated with the VCF header.\n *\n * @param {object} args\n *\n * @param {string} args.header - The VCF header. Supports both LF and CRLF\n * newlines.\n *\n * @param {boolean} args.strict - Whether to parse in strict mode or not\n * (default true)\n */\nexport default class VCFParser {\n    constructor({ header, strict = true, }) {\n        if (!header.length) {\n            throw new Error('empty header received');\n        }\n        const headerLines = header.split(/[\\r\\n]+/).filter(Boolean);\n        if (!headerLines.length) {\n            throw new Error('no non-empty header lines specified');\n        }\n        this.strict = strict;\n        this.metadata = {\n            INFO: { ...vcfReserved.InfoFields },\n            FORMAT: { ...vcfReserved.GenotypeFields },\n            ALT: { ...vcfReserved.AltTypes },\n            FILTER: { ...vcfReserved.FilterTypes },\n        };\n        let lastLine;\n        for (let i = 0; i < headerLines.length; i++) {\n            const line = headerLines[i];\n            if (!line.startsWith('#')) {\n                throw new Error(`Bad line in header:\\n${line}`);\n            }\n            else if (line.startsWith('##')) {\n                this.parseMetadata(line);\n            }\n            else {\n                lastLine = line;\n            }\n        }\n        if (!lastLine) {\n            throw new Error('No format line found in header');\n        }\n        const fields = lastLine.trim().split('\\t');\n        const thisHeader = fields.slice(0, 8);\n        const correctHeader = [\n            '#CHROM',\n            'POS',\n            'ID',\n            'REF',\n            'ALT',\n            'QUAL',\n            'FILTER',\n            'INFO',\n        ];\n        if (fields.length < 8) {\n            throw new Error(`VCF header missing columns:\\n${lastLine}`);\n        }\n        else if (thisHeader.length !== correctHeader.length ||\n            !thisHeader.every((value, index) => value === correctHeader[index])) {\n            throw new Error(`VCF column headers not correct:\\n${lastLine}`);\n        }\n        this.samples = fields.slice(9);\n    }\n    parseInfo(infoStr) {\n        const result = {};\n        const hasDecode = infoStr.includes('%');\n        const infoPairs = infoStr.split(';');\n        const infoMeta = this.metadata.INFO;\n        const pairsLen = infoPairs.length;\n        for (let i = 0; i < pairsLen; i++) {\n            const pair = infoPairs[i];\n            const eqIdx = pair.indexOf('=');\n            const key = eqIdx === -1 ? pair : pair.slice(0, eqIdx);\n            const val = eqIdx === -1 ? undefined : pair.slice(eqIdx + 1);\n            const itemType = infoMeta[key]?.Type;\n            if (itemType === 'Flag') {\n                result[key] = true;\n            }\n            else if (!val) {\n                result[key] = true;\n            }\n            else {\n                const isNumber = itemType === 'Integer' || itemType === 'Float';\n                const rawItems = val.split(',');\n                const itemsLen = rawItems.length;\n                if (hasDecode) {\n                    const items = [];\n                    for (let j = 0; j < itemsLen; j++) {\n                        const v = rawItems[j];\n                        if (v === '.') {\n                            items.push(undefined);\n                        }\n                        else {\n                            const decoded = decodeURIComponentNoThrow(v);\n                            items.push(isNumber ? Number(decoded) : decoded);\n                        }\n                    }\n                    result[key] = items;\n                }\n                else {\n                    const items = [];\n                    for (let j = 0; j < itemsLen; j++) {\n                        const v = rawItems[j];\n                        if (v === '.') {\n                            items.push(undefined);\n                        }\n                        else {\n                            items.push(isNumber ? Number(v) : v);\n                        }\n                    }\n                    result[key] = items;\n                }\n            }\n        }\n        return result;\n    }\n    parseSamples(format, prerest) {\n        const genotypes = {};\n        if (format) {\n            const rest = prerest.split('\\t');\n            const formatKeys = format.split(':');\n            const formatMeta = this.metadata.FORMAT;\n            const isNumberType = [];\n            for (let i = 0; i < formatKeys.length; i++) {\n                const r = formatMeta[formatKeys[i]]?.Type;\n                isNumberType.push(r === 'Integer' || r === 'Float');\n            }\n            const numKeys = formatKeys.length;\n            const samplesLen = this.samples.length;\n            for (let i = 0; i < samplesLen; i++) {\n                const sample = this.samples[i];\n                const sampleData = {};\n                const sampleStr = rest[i];\n                const sampleStrLen = sampleStr.length;\n                let colStart = 0;\n                let colIdx = 0;\n                for (let j = 0; j <= sampleStrLen; j++) {\n                    if (j === sampleStrLen || sampleStr[j] === ':') {\n                        const val = sampleStr.slice(colStart, j);\n                        if (val === '' || val === '.') {\n                            sampleData[formatKeys[colIdx]] = undefined;\n                        }\n                        else {\n                            const items = val.split(',');\n                            const result = [];\n                            if (isNumberType[colIdx]) {\n                                for (let k = 0; k < items.length; k++) {\n                                    const ent = items[k];\n                                    result.push(ent === '.' ? undefined : +ent);\n                                }\n                            }\n                            else {\n                                for (let k = 0; k < items.length; k++) {\n                                    const ent = items[k];\n                                    result.push(ent === '.' ? undefined : ent);\n                                }\n                            }\n                            sampleData[formatKeys[colIdx]] = result;\n                        }\n                        colStart = j + 1;\n                        colIdx += 1;\n                        if (colIdx >= numKeys) {\n                            break;\n                        }\n                    }\n                }\n                genotypes[sample] = sampleData;\n            }\n        }\n        return genotypes;\n    }\n    /**\n     * Parse a VCF metadata line (i.e. a line that starts with \"##\") and add its\n     * properties to the object.\n     *\n     * @param {string} line - A line from the VCF. Supports both LF and CRLF\n     * newlines.\n     */\n    parseMetadata(line) {\n        const match = /^##(.+?)=(.*)/.exec(line.trim());\n        if (!match) {\n            throw new Error(`Line is not a valid metadata line: ${line}`);\n        }\n        const [metaKey, metaVal] = match.slice(1, 3);\n        const r = metaKey;\n        if (metaVal?.startsWith('<')) {\n            if (!(r in this.metadata)) {\n                this.metadata[r] = {};\n            }\n            const [id, keyVals] = this.parseStructuredMetaVal(metaVal);\n            if (id) {\n                // if there is an ID field in the <> metadata\n                // e.g. ##INFO=<ID=AF_ESP,...>\n                ;\n                this.metadata[r][id] = keyVals;\n            }\n            else {\n                // if there is not an ID field in the <> metadata\n                // e.g. ##ID=<Description=\"ClinVar Variation ID\">\n                this.metadata[r] = keyVals;\n            }\n        }\n        else {\n            this.metadata[r] = metaVal;\n        }\n    }\n    /**\n     * Parse a VCF header structured meta string (i.e. a meta value that starts\n     * with \"<ID=...\")\n     *\n     * @param {string} metaVal - The VCF metadata value\n     *\n     * @returns {Array} - Array with two entries, 1) a string of the metadata ID\n     * and 2) an object with the other key-value pairs in the metadata\n     */\n    parseStructuredMetaVal(metaVal) {\n        const keyVals = parseMetaString(metaVal);\n        const id = keyVals.ID;\n        delete keyVals.ID;\n        if ('Number' in keyVals) {\n            if (!Number.isNaN(Number(keyVals.Number))) {\n                keyVals.Number = Number(keyVals.Number);\n            }\n        }\n        return [id, keyVals];\n    }\n    /**\n     * Get metadata filtered by the elements in args. For example, can pass\n     * ('INFO', 'DP') to only get info on an metadata tag that was like\n     * \"##INFO=<ID=DP,...>\"\n     *\n     * @param  {...string} args - List of metadata filter strings.\n     *\n     * @returns {any} An object, string, or number, depending on the filtering\n     */\n    getMetadata(...args) {\n        let filteredMetadata = this.metadata;\n        const argsLen = args.length;\n        for (let i = 0; i < argsLen; i++) {\n            filteredMetadata = filteredMetadata[args[i]];\n            if (!filteredMetadata) {\n                return filteredMetadata;\n            }\n        }\n        return filteredMetadata;\n    }\n    /**\n     * Parse a VCF line into an object like\n     *\n     * ```typescript\n     * {\n     *   CHROM: 'contigA',\n     *   POS: 3000,\n     *   ID: ['rs17883296'],\n     *   REF: 'G',\n     *   ALT: ['T', 'A'],\n     *   QUAL: 100,\n     *   FILTER: 'PASS',\n     *   INFO: {\n     *     NS: [3],\n     *     DP: [14],\n     *     AF: [0.5],\n     *     DB: true,\n     *     XYZ: ['5'],\n     *   },\n     *   SAMPLES: () => ({\n     *     HG00096: {\n     *       GT: ['0|0'],\n     *       AP: ['0.000', '0.000'],\n     *     }\n     *   }),\n     *   GENOTYPES: () => ({\n     *     HG00096: '0|0'\n     *   })\n     * }\n     * ```\n     *\n     * SAMPLES and GENOTYPES methods are functions instead of static data fields\n     * because it avoids parsing the potentially long list of samples from e.g.\n     * 1000 genotypes data unless requested.\n     *\n     * The SAMPLES function gives all info about the samples\n     *\n     * The GENOTYPES function only extracts the raw GT string if it exists, for\n     * potentially optimized parsing by programs that need it\n     *\n     * @param {string} line - A string of a line from a VCF\n     */\n    parseLine(line) {\n        let currChar = 0;\n        let tabCount = 0;\n        while (currChar < line.length && tabCount < 9) {\n            if (line[currChar] === '\\t') {\n                tabCount += 1;\n            }\n            currChar += 1;\n        }\n        const splitPos = tabCount === 9 ? currChar - 1 : currChar;\n        const fields = line.slice(0, splitPos).split('\\t');\n        const rest = line.slice(splitPos + 1);\n        const [CHROM, POS, ID, REF, ALT, QUAL, FILTER] = fields;\n        const chrom = CHROM;\n        const pos = +POS;\n        const id = ID === '.' ? undefined : ID.split(';');\n        const ref = REF;\n        const alt = ALT === '.' ? undefined : ALT.split(',');\n        const qual = QUAL === '.' ? undefined : +QUAL;\n        const filter = FILTER === '.' ? undefined : FILTER.split(';');\n        const format = fields[8];\n        if (this.strict && !fields[7]) {\n            throw new Error(\"no INFO field specified, must contain at least a '.' (turn off strict mode to allow)\");\n        }\n        const info = fields[7] === undefined || fields[7] === '.'\n            ? {}\n            : this.parseInfo(fields[7]);\n        return {\n            CHROM: chrom,\n            POS: pos,\n            ALT: alt,\n            INFO: info,\n            REF: ref,\n            FILTER: filter?.length === 1 && filter[0] === 'PASS' ? 'PASS' : filter,\n            ID: id,\n            QUAL: qual,\n            FORMAT: format,\n            SAMPLES: () => this.parseSamples(fields[8] ?? '', rest),\n            GENOTYPES: () => parseGenotypesOnly(fields[8] ?? '', rest, this.samples),\n        };\n    }\n}\n//# sourceMappingURL=parse.js.map","import { max } from '@jbrowse/core/util';\nimport { getSOTermAndDescription } from './util';\nfunction dataFromVariant(variant, parser) {\n    const { REF = '', ALT, POS, CHROM, ID } = variant;\n    const start = POS - 1;\n    const [type, description] = getSOTermAndDescription(REF, ALT, parser);\n    return {\n        refName: CHROM,\n        start,\n        end: getEnd(variant),\n        description,\n        type,\n        name: ID === null || ID === void 0 ? void 0 : ID.join(','),\n    };\n}\nfunction getEnd(variant) {\n    var _a;\n    const { POS, REF = '', ALT = [] } = variant;\n    const isTRA = ALT.includes('<TRA>');\n    const start = POS - 1;\n    const isSymbolic = ALT.some(f => f.includes('<'));\n    if (isSymbolic) {\n        const info = variant.INFO;\n        if (info.END && !isTRA) {\n            return +info.END[0];\n        }\n        const lens = [];\n        if (info.SVLEN && !isTRA) {\n            const svlens = info.SVLEN;\n            for (let i = 0; i < svlens.length; i++) {\n                const svlen = svlens[i];\n                if ((_a = ALT[i]) === null || _a === void 0 ? void 0 : _a.startsWith('<INS')) {\n                    lens.push(1);\n                }\n                else {\n                    lens.push(Math.abs(+svlen));\n                }\n            }\n            return start + max(lens);\n        }\n    }\n    return start + REF.length;\n}\nexport default class VCFFeature {\n    constructor(args) {\n        this.variant = args.variant;\n        this.parser = args.parser;\n        this.data = dataFromVariant(this.variant, this.parser);\n        this._id = args.id;\n    }\n    get(field) {\n        var _a;\n        return field === 'samples'\n            ? this.variant.SAMPLES()\n            : field === 'genotypes'\n                ? this.variant.GENOTYPES()\n                : ((_a = this.data[field]) !== null && _a !== void 0 ? _a : this.variant[field]);\n    }\n    parent() {\n        return undefined;\n    }\n    children() {\n        return undefined;\n    }\n    id() {\n        return this._id;\n    }\n    toJSON() {\n        const { SAMPLES, GENOTYPES, ...rest } = this.variant;\n        return {\n            uniqueId: this._id,\n            ...rest,\n            ...this.data,\n            samples: this.variant.SAMPLES(),\n        };\n    }\n}\n"],"names":["parseGenotypesOnly","format","prerest","samples","genotypes","samplesLen","prerestLen","TAB","COLON","pos","idx","start","gtIdx","colonCount","j","sampleStart","tabIdx","colons","fieldStart","customSplit","str","result","chars","inQuotes","inBrackets","strLen","i","char","splitFirst","split","index","parseMetaString","metaString","inside","parts","entries","f","key","val","items","vcfReserved","decodeURIComponentNoThrow","uri","VCFParser","header","strict","headerLines","lastLine","line","fields","thisHeader","correctHeader","value","infoStr","hasDecode","infoPairs","infoMeta","pairsLen","pair","eqIdx","itemType","_a","isNumber","rawItems","itemsLen","v","decoded","rest","formatKeys","formatMeta","isNumberType","r","numKeys","sample","sampleData","sampleStr","sampleStrLen","colStart","colIdx","k","ent","match","metaKey","metaVal","id","keyVals","args","filteredMetadata","argsLen","currChar","tabCount","splitPos","CHROM","POS","ID","REF","ALT","QUAL","FILTER","chrom","ref","alt","qual","filter","info","dataFromVariant","variant","parser","type","description","getSOTermAndDescription","getEnd","isTRA","lens","svlens","svlen","max","VCFFeature","field","SAMPLES","GENOTYPES"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}